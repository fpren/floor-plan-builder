<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Blueprint Builder - Wall Segment Selection</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-dark: #1a1a1a;
            --bg-panel: #242424;
            --bg-tool: #2d2d2d;
            --border: #3a3a3a;
            --text: #e0e0e0;
            --text-dim: #888;
            --accent: #f4d03f;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif; background: var(--bg-dark); color: var(--text); height: 100vh; height: 100dvh; overflow: hidden; touch-action: none; }
        .app { display: flex; flex-direction: column; height: 100%; }

        .topbar { display: flex; align-items: center; padding: 6px 8px; background: var(--bg-panel); border-bottom: 1px solid var(--border); gap: 4px; flex-wrap: nowrap; overflow-x: auto; min-height: 44px; }
        .topbar::-webkit-scrollbar { display: none; }
        .btn { padding: 8px 10px; background: var(--bg-tool); border: 1px solid var(--border); color: var(--text); border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer; white-space: nowrap; min-height: 32px; }
        .btn:active { background: var(--accent-blue); }
        .btn.active { background: var(--accent-blue); border-color: var(--accent-blue); }
        .btn.warn { background: var(--accent-red); border-color: var(--accent-red); }
        .sep { width: 1px; height: 24px; background: var(--border); margin: 0 4px; flex-shrink: 0; }

        .main { display: flex; flex: 1; overflow: hidden; }

        .sidebar-left { width: 170px; background: var(--bg-panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .sidebar-toggle { padding: 8px; background: var(--bg-tool); border: none; color: var(--accent); font-size: 16px; cursor: pointer; border-bottom: 1px solid var(--border); }
        .sidebar-scroll { flex: 1; overflow-y: auto; overflow-x: hidden; }
        .section { border-bottom: 1px solid var(--border); }
        .section-header { padding: 8px; font-size: 9px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .section-content { padding: 6px; }

        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; }
        .tool-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 6px 2px; background: var(--bg-tool); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 7px; font-weight: 500; cursor: pointer; min-height: 44px; }
        .tool-btn:active, .tool-btn.active { background: var(--accent-blue); border-color: var(--accent-blue); }
        .tool-btn svg { width: 18px; height: 18px; margin-bottom: 2px; }
        .tool-btn svg * { stroke: currentColor; fill: none; stroke-width: 1.5; }
        .tool-btn.filled svg * { fill: currentColor; stroke: none; }

        .tree-group { margin-bottom: 4px; }
        .tree-label { font-size: 9px; color: var(--accent); padding: 4px 6px; font-weight: 600; }
        .tree-item { display: flex; align-items: center; gap: 6px; padding: 5px 8px; font-size: 10px; cursor: pointer; border-radius: 4px; }
        .tree-item:active, .tree-item.selected { background: rgba(59,130,246,0.3); }
        .tree-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }

        .canvas-wrap { flex: 1; background: #111; position: relative; overflow: hidden; }
        #stage { width: 100%; height: 100%; }
        .north-arrow { position: absolute; top: 10px; right: 10px; width: 36px; height: 36px; background: rgba(0,0,0,0.7); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; color: var(--accent); border: 2px solid var(--accent); }
        .scale-label { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; font-size: 10px; color: var(--text-dim); }
        .qa-badge { position: absolute; top: 10px; left: 10px; background: var(--accent-green); color: #000; padding: 4px 10px; border-radius: 12px; font-size: 10px; font-weight: 600; }
        .qa-badge.error { background: var(--accent-red); color: #fff; }
        .tool-hint { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 8px 16px; border-radius: 8px; font-size: 11px; color: var(--accent); display: none; }
        .tool-hint.show { display: block; }

        .sidebar-right { width: 180px; background: var(--bg-panel); border-left: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .inspector { padding: 10px; flex: 1; overflow-y: auto; }
        .inspector-title { font-size: 12px; font-weight: 600; color: var(--accent); margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid var(--border); }
        .inspector-section { margin-bottom: 10px; }
        .inspector-section-title { font-size: 9px; color: var(--accent-cyan); text-transform: uppercase; margin-bottom: 4px; }
        .inspector-row { font-size: 10px; color: var(--text-dim); margin-bottom: 3px; display: flex; justify-content: space-between; }
        .inspector-row span { color: var(--text); }
        .inspector-row.highlight { background: rgba(6,182,212,0.2); padding: 4px 6px; border-radius: 4px; margin: 4px -6px; }
        .attach-list { margin-top: 6px; }
        .attach-item { font-size: 9px; color: var(--text-dim); padding: 2px 0; border-bottom: 1px dashed var(--border); }
        .attach-item:last-child { border: none; }
        .reattach-btn { margin-top: 8px; width: 100%; padding: 6px; background: var(--accent-orange); border: none; border-radius: 4px; color: #000; font-size: 10px; font-weight: 600; cursor: pointer; }

        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal.show { display: flex; }
        .modal-box { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; max-width: 420px; width: 100%; max-height: 80vh; overflow: auto; }
        .modal-head { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 14px; font-weight: 600; color: var(--accent); }
        .modal-close { background: none; border: none; color: var(--text); font-size: 20px; cursor: pointer; }
        .modal-body { padding: 16px; font-size: 11px; }
        .qa-item { padding: 6px 0; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; }
        .qa-pass { color: var(--accent-green); }
        .qa-fail { color: var(--accent-red); }

        @media (max-width: 600px) {
            .sidebar-left { width: 130px; }
            .sidebar-right { width: 150px; }
            .tool-grid { grid-template-columns: repeat(2, 1fr); }
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
<div class="app">
    <div class="topbar">
        <button class="btn" onclick="App.newDoc()">New</button>
        <button class="btn" onclick="$('#fbgInput').click()">Load</button>
        <input type="file" id="fbgInput" accept=".fbg,.fgs,.json" onchange="App.loadFBG(event)">
        <button class="btn" onclick="App.exportPDF()">PDF</button>
        <div class="sep"></div>
        <button class="btn active" id="btnGrid" onclick="App.toggle('grid')">Grid</button>
        <button class="btn active" id="btnWallIds" onclick="App.toggle('wallIds')">W-ID</button>
        <button class="btn active" id="btnDims" onclick="App.toggle('dims')">Dims</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.resetView()">Reset</button>
        <button class="btn active" id="btnSelect" onclick="App.setTool('select')">Select</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.showQA()">QA</button>
    </div>
    <div class="main">
        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-toggle" onclick="App.toggleSidebar()">☰</button>
            <div class="sidebar-scroll">
                <div class="section">
                    <div class="section-header">Geometry</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('room')"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1"/></svg>Room</button>
                            <button class="tool-btn" onclick="App.setTool('closet')"><svg viewBox="0 0 24 24"><rect x="4" y="5" width="16" height="14" rx="1"/><line x1="12" y1="5" x2="12" y2="19"/></svg>Closet</button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Openings (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('door')"><svg viewBox="0 0 24 24"><rect x="6" y="3" width="12" height="18" rx="1"/><circle cx="15" cy="12" r="1.5" fill="currentColor"/></svg>Door</button>
                            <button class="tool-btn" onclick="App.setTool('window')"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="1"/><line x1="12" y1="7" x2="12" y2="17"/></svg>Window</button>
                            <button class="tool-btn" onclick="App.setTool('cased')"><svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3,2"/></svg>Cased</button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">MEP (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('pipe')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>Pipe</button>
                            <button class="tool-btn filled" onclick="App.setTool('gas')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>Gas</button>
                            <button class="tool-btn" onclick="App.setTool('radiator')"><svg viewBox="0 0 24 24"><rect x="3" y="8" width="18" height="10" rx="1"/></svg>Radiator</button>
                            <button class="tool-btn" onclick="App.setTool('riser')"><svg viewBox="0 0 24 24"><rect x="8" y="4" width="8" height="16" rx="1"/></svg>Riser</button>
                            <button class="tool-btn" onclick="App.setTool('poe')"><svg viewBox="0 0 24 24"><polygon points="12,2 22,12 17,12 17,22 7,22 7,12 2,12" fill="currentColor"/></svg>POE</button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Objects</div>
                    <div class="section-content" id="objectTree"></div>
                </div>
            </div>
        </div>
        <div class="canvas-wrap">
            <div id="stage"></div>
            <div class="north-arrow">N</div>
            <div class="scale-label">1/4" = 1'-0"</div>
            <div class="qa-badge" id="qaBadge">QA: --</div>
            <div class="tool-hint" id="toolHint">Tap a wall segment to place</div>
        </div>
        <div class="sidebar-right">
            <div class="inspector" id="inspector">
                <div class="inspector-title">Properties</div>
                <div class="inspector-row">Tap wall or object to select</div>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="qaModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">QA Validation</div>
            <button class="modal-close" onclick="App.hideModal('qa')">&times;</button>
        </div>
        <div class="modal-body" id="qaContent"></div>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ========== CONSTANTS ==========
const SCALE = 4;
const INCH = SCALE;
const FOOT = 12 * SCALE;
const WALL_EXT = 6 * INCH;
const WALL_INT = 4.5 * INCH;
const SNAP_DISTANCE = 24; // Mobile-friendly snap distance in pixels
const HIT_WIDTH = 28; // Hit region width for wall segments

// ========== DOCUMENT MODEL ==========
const Doc = {
    create() {
        return {
            id: this.uid(),
            version: '4.0',
            address: '2BR/1BA Blueprint',
            counters: { room: 0, wallSegment: 0, door: 0, window: 0, closet: 0, cased: 0, pipe: 0, gas: 0, riser: 0, radiator: 0, poe: 0 },
            rooms: [],
            wallSegments: [],  // All wall segments indexed here
            doors: [],
            windows: [],
            casedOpenings: [],
            closets: [],
            mep: [],
            dimensions: []
        };
    },
    uid() { return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); },
    label(doc, type) {
        doc.counters[type] = (doc.counters[type] || 0) + 1;
        const prefixes = { room: 'Rm', wallSegment: 'WS', door: 'D', window: 'WIN', closet: 'CL', cased: 'OP', pipe: 'PIPE', gas: 'GAS', riser: 'RSR', radiator: 'RAD', poe: 'POE' };
        const n = doc.counters[type];
        return (prefixes[type] || type.toUpperCase()) + '-' + (n < 10 ? '0' : '') + n;
    }
};

// ========== WALL SEGMENT CREATION ==========
function createWallSegments(room, doc) {
    const g = room.geometry;
    // Create 4 segments for rectangular room: S, W, N, E
    // Segments defined by endpoints, ordered clockwise
    const segments = [
        { side: 'south', x1: g.x, y1: g.y + g.height, x2: g.x + g.width, y2: g.y + g.height },
        { side: 'west',  x1: g.x, y1: g.y + g.height, x2: g.x, y2: g.y },
        { side: 'north', x1: g.x, y1: g.y, x2: g.x + g.width, y2: g.y },
        { side: 'east',  x1: g.x + g.width, y1: g.y, x2: g.x + g.width, y2: g.y + g.height }
    ];

    // Determine which segment is SOUTH-most (highest Y average)
    let southIdx = 0;
    let maxY = -Infinity;
    segments.forEach((seg, i) => {
        const avgY = (seg.y1 + seg.y2) / 2;
        if (avgY > maxY) { maxY = avgY; southIdx = i; }
    });

    // Reorder so W1 is the SOUTH-most, then clockwise
    const ordered = [];
    for (let i = 0; i < 4; i++) {
        ordered.push(segments[(southIdx + i) % 4]);
    }

    // Create WallSegment objects
    const wallSegments = ordered.map((seg, idx) => {
        const ws = {
            id: Doc.uid(),
            roomId: room.id,
            roomLabel: room.label,
            index: idx + 1,
            label: 'W' + (idx + 1),
            side: seg.side,
            x1: seg.x1, y1: seg.y1, x2: seg.x2, y2: seg.y2,
            thickness: room.isExterior ? WALL_EXT : WALL_INT,
            type: room.isExterior ? 'exterior' : 'interior',
            attachedObjects: []
        };
        doc.wallSegments.push(ws);
        return ws;
    });

    room.wallSegmentIds = wallSegments.map(ws => ws.id);
    return wallSegments;
}

function getSegmentLength(seg) {
    return Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
}

function getSegmentMidpoint(seg) {
    return { x: (seg.x1 + seg.x2) / 2, y: (seg.y1 + seg.y2) / 2 };
}

function getSegmentAngle(seg) {
    return Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1);
}

function pointToSegmentDistance(px, py, seg) {
    const dx = seg.x2 - seg.x1;
    const dy = seg.y2 - seg.y1;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.sqrt((px - seg.x1) ** 2 + (py - seg.y1) ** 2);
    let t = ((px - seg.x1) * dx + (py - seg.y1) * dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = seg.x1 + t * dx;
    const nearY = seg.y1 + t * dy;
    return { distance: Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2), t, nearX, nearY };
}

function findNearestWallSegment(x, y, doc) {
    let nearest = null;
    let minDist = Infinity;
    let nearestT = 0;
    let nearestPoint = null;

    doc.wallSegments.forEach(seg => {
        const result = pointToSegmentDistance(x, y, seg);
        if (result.distance < minDist) {
            minDist = result.distance;
            nearest = seg;
            nearestT = result.t;
            nearestPoint = { x: result.nearX, y: result.nearY };
        }
    });

    return { segment: nearest, distance: minDist, t: nearestT, point: nearestPoint };
}

// ========== GENERATE 2BR/1BA ==========
function generate2BR1BA() {
    const doc = Doc.create();

    // Layout: Clean 2x3 grid with shared walls, no gaps
    // Total exterior: 26' x 20' (compact ranch-style)
    //
    //      0      12     16      26
    //      +------+------+-------+  0
    //      | Bed1 | Hall |Kitchen|
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 10
    //      |Living| Bath | Bed 2 |
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 20
    //
    const startX = 60, startY = 60;

    // Grid columns (x positions)
    const col1 = startX;                    // Left edge
    const col2 = startX + 12 * FOOT;        // 12'
    const col3 = col2 + 4 * FOOT;           // 16'
    const col4 = col3 + 10 * FOOT;          // 26' (right edge)

    // Grid rows (y positions)
    const row1 = startY;                    // Top edge
    const row2 = startY + 10 * FOOT;        // 10'
    const row3 = row2 + 10 * FOOT;          // 20' (bottom edge)

    // ========== ROW 1: Bed1 | Hall | Kitchen ==========
    // Bedroom 1: Top-left (12' x 10')
    const bed1 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 1', isExterior: true,
        geometry: { x: col1, y: row1, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed1, doc);
    doc.rooms.push(bed1);

    // Hall: Top-center (4' x 10')
    const hall = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Hall', isExterior: false,
        geometry: { x: col2, y: row1, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(hall, doc);
    doc.rooms.push(hall);

    // Kitchen: Top-right (10' x 10')
    const kitchen = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Kitchen', isExterior: true,
        geometry: { x: col3, y: row1, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(kitchen, doc);
    doc.rooms.push(kitchen);

    // ========== ROW 2: Living | Bath | Bed2 ==========
    // Living: Bottom-left (12' x 10')
    const living = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Living', isExterior: true,
        geometry: { x: col1, y: row2, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(living, doc);
    doc.rooms.push(living);

    // Bathroom: Bottom-center (4' x 10')
    const bath = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bathroom', isExterior: false,
        geometry: { x: col2, y: row2, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bath, doc);
    doc.rooms.push(bath);

    // Bedroom 2: Bottom-right (10' x 10')
    const bed2 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 2', isExterior: true,
        geometry: { x: col3, y: row2, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed2, doc);
    doc.rooms.push(bed2);

    // ========== CLOSETS (with parentRoomId and wall segments) ==========
    // CL-01: Inside Bedroom 1 (4' x 2.5')
    const cl1 = {
        id: Doc.uid(), label: Doc.label(doc, 'closet'), type: 'Closet',
        parentRoomId: bed1.id,
        parentRoomLabel: bed1.label,
        isExterior: false,
        geometry: {
            x: bed1.geometry.x + bed1.geometry.width - 4.5 * FOOT,
            y: bed1.geometry.y + 0.5 * FOOT,
            width: 4 * FOOT,
            height: 2.5 * FOOT
        }
    };
    createWallSegments(cl1, doc);  // Closets now have wall segments!
    doc.closets.push(cl1);

    // CL-02: Inside Bedroom 2 (4' x 2.5')
    const cl2 = {
        id: Doc.uid(), label: Doc.label(doc, 'closet'), type: 'Closet',
        parentRoomId: bed2.id,
        parentRoomLabel: bed2.label,
        isExterior: false,
        geometry: {
            x: bed2.geometry.x + 0.5 * FOOT,
            y: bed2.geometry.y + 0.5 * FOOT,
            width: 4 * FOOT,
            height: 2.5 * FOOT
        }
    };
    createWallSegments(cl2, doc);  // Closets now have wall segments!
    doc.closets.push(cl2);

    // ========== DOORS ==========
    // New layout wall reference:
    // W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south)
    //
    // Circulation path: Entry(Living W1) → Living → Bath(W4/W2) → Hall(W3/W1) → Bed1(W2/W4) + Kitchen(W4/W2)
    //                   Bath → Bed2 (W4/W2)

    // D-01: Entry door on Living south wall (W1) - exterior entry
    const livingSouthWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W1');
    if (livingSouthWall) {
        const d1 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d1);
        livingSouthWall.attachedObjects.push({ type: 'door', id: d1.id, label: d1.label });

        // POE anchored to entry door
        const poe1 = {
            id: Doc.uid(), label: Doc.label(doc, 'poe'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            anchorDoorId: d1.id,
            distanceFromStart: 4.5 * FOOT
        };
        doc.mep.push(poe1);
        livingSouthWall.attachedObjects.push({ type: 'poe', id: poe1.id, label: poe1.label });
    }

    // D-02: Bed 1 to Hall - on Bed1's east wall (W4)
    const bed1EastWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W4');
    if (bed1EastWall) {
        const d2 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed1EastWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d2);
        bed1EastWall.attachedObjects.push({ type: 'door', id: d2.id, label: d2.label });
    }

    // D-03: Bath to Hall - on Bath's north wall (W3)
    const bathNorthWall = doc.wallSegments.find(ws => ws.roomId === bath.id && ws.label === 'W3');
    if (bathNorthWall) {
        const d3 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bathNorthWall.id,
            parentRoomId: bath.id,
            distanceFromStart: 0.5 * FOOT,
            width: 2.5 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d3);
        bathNorthWall.attachedObjects.push({ type: 'door', id: d3.id, label: d3.label });
    }

    // D-04: Bed 2 to Bath - on Bed2's west wall (W2)
    const bed2WestWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W2');
    if (bed2WestWall) {
        const d4 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed2WestWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d4);
        bed2WestWall.attachedObjects.push({ type: 'door', id: d4.id, label: d4.label });
    }

    // D-05: Kitchen to Hall - on Kitchen's west wall (W2)
    const kitchenWestWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W2');
    if (kitchenWestWall) {
        const d5 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: kitchenWestWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d5);
        kitchenWestWall.attachedObjects.push({ type: 'door', id: d5.id, label: d5.label });
    }

    // D-06: Living to Bath - on Living's east wall (W4)
    const livingEastWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W4');
    if (livingEastWall) {
        const d6 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: livingEastWall.id,
            parentRoomId: living.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'out', swingDir: 'right'
        };
        doc.doors.push(d6);
        livingEastWall.attachedObjects.push({ type: 'door', id: d6.id, label: d6.label });
    }

    // ========== WINDOWS ==========
    // WIN-01: Living west wall
    const livingWestWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W2');
    if (livingWestWall) {
        const w1 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 2 * FOOT,
            width: 5 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w1);
        livingWestWall.attachedObjects.push({ type: 'window', id: w1.id, label: w1.label });
    }

    // WIN-02: Bed 1 north wall
    const bed1NorthWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W3');
    if (bed1NorthWall) {
        const w2 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed1NorthWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 3 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w2);
        bed1NorthWall.attachedObjects.push({ type: 'window', id: w2.id, label: w2.label });
    }

    // WIN-03: Bed 2 south wall
    const bed2SouthWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W1');
    if (bed2SouthWall) {
        const w3 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed2SouthWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w3);
        bed2SouthWall.attachedObjects.push({ type: 'window', id: w3.id, label: w3.label });
    }

    // WIN-04: Kitchen east wall
    const kitchenEastWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W4');
    if (kitchenEastWall) {
        const w4 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: kitchenEastWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            sillHeight: 42 * INCH
        };
        doc.windows.push(w4);
        kitchenEastWall.attachedObjects.push({ type: 'window', id: w4.id, label: w4.label });
    }

    // ========== MEP ==========
    // Radiator in Living
    if (livingWestWall) {
        const rad1 = {
            id: Doc.uid(), label: Doc.label(doc, 'radiator'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 8 * FOOT,
            width: 3 * FOOT, height: 1 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rad1);
        livingWestWall.attachedObjects.push({ type: 'radiator', id: rad1.id, label: rad1.label });

        // Riser near radiator
        const rsr1 = {
            id: Doc.uid(), label: Doc.label(doc, 'riser'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 7.5 * FOOT,
            width: 0.5 * FOOT, height: 0.5 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rsr1);
        livingWestWall.attachedObjects.push({ type: 'riser', id: rsr1.id, label: rsr1.label });
    }

    // ========== DIMENSIONS ==========
    const totalW = col4 - col1;  // 26'
    const totalH = row3 - row1;  // 20'
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalW / FOOT)}'-0"`, x1: startX, y1: startY - 25, x2: startX + totalW, y2: startY - 25 });
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalH / FOOT)}'-0"`, x1: startX - 25, y1: startY, x2: startX - 25, y2: startY + totalH, vertical: true });

    return doc;
}

// ========== RENDERER ==========
const Render = {
    stage: null,
    layers: {},
    wallGroups: {},
    selection: { type: null, id: null },

    init(containerId) {
        const c = document.getElementById(containerId);
        if (!c) return false;
        const r = c.getBoundingClientRect();
        this.stage = new Konva.Stage({ container: containerId, width: r.width, height: r.height, draggable: true });

        this.layers.grid = new Konva.Layer();
        this.layers.rooms = new Konva.Layer();
        this.layers.walls = new Konva.Layer();
        this.layers.openings = new Konva.Layer();
        this.layers.mep = new Konva.Layer();
        this.layers.labels = new Konva.Layer();
        this.layers.dims = new Konva.Layer();
        this.layers.hit = new Konva.Layer(); // Hit regions layer

        this.stage.add(this.layers.grid, this.layers.rooms, this.layers.walls, this.layers.hit, this.layers.openings, this.layers.mep, this.layers.labels, this.layers.dims);

        this.stage.on('wheel', e => {
            e.evt.preventDefault();
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            const mousePointTo = { x: (pointer.x - this.stage.x()) / oldScale, y: (pointer.y - this.stage.y()) / oldScale };
            const newScale = e.evt.deltaY > 0 ? oldScale / 1.1 : oldScale * 1.1;
            this.stage.scale({ x: newScale, y: newScale });
            this.stage.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
        });

        new ResizeObserver(() => {
            const rect = c.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                this.stage.width(rect.width);
                this.stage.height(rect.height);
            }
        }).observe(c);

        this.drawGrid();
        return true;
    },

    drawGrid() {
        const layer = this.layers.grid;
        layer.destroyChildren();
        const w = 2000, h = 1500;
        for (let x = 0; x < w; x += 6 * INCH) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#222', strokeWidth: 0.5 }));
        for (let y = 0; y < h; y += 6 * INCH) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#222', strokeWidth: 0.5 }));
        for (let x = 0; x < w; x += FOOT) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#333', strokeWidth: 1 }));
        for (let y = 0; y < h; y += FOOT) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#333', strokeWidth: 1 }));
        layer.batchDraw();
    },

    render(doc, opts = {}) {
        if (!this.stage) return;
        const { showWallIds = true, showDims = true } = opts;

        ['rooms', 'walls', 'hit', 'openings', 'mep', 'labels', 'dims'].forEach(l => this.layers[l].destroyChildren());
        this.wallGroups = {};

        // Room fills (non-listening)
        doc.rooms.forEach(r => this.renderRoomFill(r));

        // Wall segments (with hit regions)
        doc.wallSegments.forEach(ws => this.renderWallSegment(ws, doc, showWallIds));

        // Closets
        doc.closets.forEach(c => this.renderCloset(c, doc));

        // Doors
        doc.doors.forEach(d => this.renderDoor(d, doc));

        // Windows
        doc.windows.forEach(w => this.renderWindow(w, doc));

        // Cased openings
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));

        // MEP
        doc.mep.forEach(m => this.renderMEP(m, doc));

        // Dimensions
        if (showDims) doc.dimensions.forEach(d => this.renderDimension(d));

        Object.values(this.layers).forEach(l => l.batchDraw());
    },

    renderRoomFill(room) {
        const g = room.geometry;
        this.layers.rooms.add(new Konva.Rect({
            x: g.x, y: g.y, width: g.width, height: g.height,
            fill: '#252525',
            listening: false // CRITICAL: Don't block wall clicks
        }));

        // Room label
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 16, width: g.width,
            text: room.label, fontSize: 13, fontStyle: 'bold', fill: '#f4d03f', align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
            text: room.type, fontSize: 10, fill: '#777', align: 'center', listening: false
        }));
    },

    renderWallSegment(ws, doc, showWallIds) {
        const room = doc.rooms.find(r => r.id === ws.roomId);
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;

        // Wall group
        const group = new Konva.Group({ id: ws.id });
        this.wallGroups[ws.id] = group;

        // Visible wall line
        const visibleLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: isSelected ? '#06b6d4' : '#f4d03f',
            strokeWidth: isSelected ? 4 : 3,
            lineCap: 'round',
            listening: false
        });
        group.add(visibleLine);

        // HIT REGION (invisible, wide stroke for mobile tapping)
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        hitLine.on('pointerdown', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);

        // Wall ID label
        if (showWallIds) {
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#666', fontStyle: 'bold', listening: false
            }));
        }

        this.layers.walls.add(group);
    },

    getLabelOffset(ws, room) {
        if (!room) return { x: 0, y: 0 };
        const g = room.geometry;
        const mid = getSegmentMidpoint(ws);
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: -(dx / dist) * 14, y: -(dy / dist) * 10 };
    },

    renderCloset(closet, doc) {
        const g = closet.geometry;
        const isSelected = this.selection.type === 'closet' && this.selection.id === closet.id;
        const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);

        // Closet fill (slightly different from room)
        const rect = new Konva.Rect({
            x: g.x, y: g.y, width: g.width, height: g.height,
            fill: '#1f1f1f', stroke: isSelected ? '#06b6d4' : '#888', strokeWidth: 2, dash: [6, 3]
        });
        rect.on('tap click', () => App.onObjectTap('closet', closet.id));
        this.layers.openings.add(rect);

        // Closet label with parent room indicator
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
            text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#06b6d4' : '#888', align: 'center', listening: false
        }));

        // Show parent room connection
        if (parentRoom) {
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                text: `(${parentRoom.label})`, fontSize: 8, fill: '#666', align: 'center', listening: false
            }));
        }

        // Render closet wall segments if they exist
        if (closet.wallSegmentIds) {
            const closetWalls = doc.wallSegments.filter(ws => ws.roomId === closet.id);
            closetWalls.forEach(ws => this.renderWallSegment(ws, doc, App.showWallIds));
        }
    },

    renderDoor(door, doc) {
        const ws = doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, door.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isVertical = Math.abs(Math.sin(angle)) > 0.5;
        const isSelected = this.selection.type === 'door' && this.selection.id === door.id;

        const doorGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        // Door opening (gap in wall)
        doorGroup.add(new Konva.Rect({
            x: 0, y: -ws.thickness / 2, width: door.width, height: ws.thickness,
            fill: '#1a1a1a', stroke: isSelected ? '#06b6d4' : '#fff', strokeWidth: 1
        }));

        // Swing arc
        const arcDir = door.swingDir === 'left' ? -1 : 1;
        doorGroup.add(new Konva.Arc({
            x: 0, y: arcDir * ws.thickness / 2, innerRadius: 0, outerRadius: door.width * 0.75,
            angle: 90, rotation: arcDir > 0 ? -90 : 0,
            stroke: '#555', strokeWidth: 1, dash: [4, 4]
        }));

        doorGroup.on('tap click', () => App.onObjectTap('door', door.id));
        this.layers.openings.add(doorGroup);

        // Label
        this.layers.labels.add(new Konva.Text({
            x: pos.x + (isVertical ? 12 : 0), y: pos.y + (isVertical ? 0 : -14),
            text: door.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#3b82f6', listening: false
        }));
    },

    renderWindow(win, doc) {
        const ws = doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, win.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'window' && this.selection.id === win.id;

        const winGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        winGroup.add(new Konva.Rect({
            x: 0, y: -ws.thickness / 2, width: win.width, height: ws.thickness,
            fill: '#1a1a1a', stroke: isSelected ? '#06b6d4' : '#87ceeb', strokeWidth: 2
        }));
        // Mullion
        winGroup.add(new Konva.Line({
            points: [win.width / 2, -ws.thickness / 2, win.width / 2, ws.thickness / 2],
            stroke: '#87ceeb', strokeWidth: 1
        }));

        winGroup.on('tap click', () => App.onObjectTap('window', win.id));
        this.layers.openings.add(winGroup);

        this.layers.labels.add(new Konva.Text({
            x: pos.x + win.width / 2 - 15, y: pos.y - 14,
            text: win.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#87ceeb', listening: false
        }));
    },

    renderCasedOpening(op, doc) {
        const ws = doc.wallSegments.find(s => s.id === op.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, op.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'cased' && this.selection.id === op.id;

        const opGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        // Dashed line "---------"
        opGroup.add(new Konva.Line({
            points: [0, 0, op.width, 0],
            stroke: isSelected ? '#06b6d4' : '#aaa', strokeWidth: 2, dash: [6, 3]
        }));

        opGroup.on('tap click', () => App.onObjectTap('cased', op.id));
        this.layers.openings.add(opGroup);

        this.layers.labels.add(new Konva.Text({
            x: pos.x + op.width / 2 - 10, y: pos.y - 12,
            text: op.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#aaa', listening: false
        }));
    },

    renderMEP(mep, doc) {
        const ws = doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, mep.distanceFromStart);
        const isSelected = this.selection.type === 'mep' && this.selection.id === mep.id;
        const color = isSelected ? '#06b6d4' : (mep.label.startsWith('GAS') ? '#f97316' : mep.label.startsWith('POE') ? '#ef4444' : '#22c55e');

        let shape;
        if (mep.label.startsWith('PIPE')) {
            shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, stroke: color, strokeWidth: 2, fill: 'transparent' });
        } else if (mep.label.startsWith('GAS')) {
            shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, fill: color });
        } else if (mep.label.startsWith('POE')) {
            shape = new Konva.RegularPolygon({ x: pos.x, y: pos.y, sides: 3, radius: 12, fill: color, rotation: 0 });
        } else if (mep.label.startsWith('RAD')) {
            const offset = this.getInteriorOffset(ws, doc);
            shape = new Konva.Rect({
                x: pos.x + offset.x * 0.5, y: pos.y + offset.y * 0.5 - mep.height / 2,
                width: mep.width, height: mep.height,
                fill: '#333', stroke: color, strokeWidth: 2
            });
        } else if (mep.label.startsWith('RSR')) {
            const offset = this.getInteriorOffset(ws, doc);
            shape = new Konva.Rect({
                x: pos.x + offset.x * 0.3, y: pos.y + offset.y * 0.3 - (mep.height || 20) / 2,
                width: mep.width || 20, height: mep.height || 20,
                fill: '#444', stroke: color, strokeWidth: 1
            });
        }

        if (shape) {
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        }

        this.layers.labels.add(new Konva.Text({
            x: pos.x + 14, y: pos.y - 5,
            text: mep.label, fontSize: 8, fill: color, listening: false
        }));
    },

    getPositionOnSegment(seg, distFromStart) {
        const len = getSegmentLength(seg);
        const t = Math.min(distFromStart / len, 1);
        return {
            x: seg.x1 + t * (seg.x2 - seg.x1),
            y: seg.y1 + t * (seg.y2 - seg.y1)
        };
    },

    getInteriorOffset(ws, doc) {
        const room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) return { x: 0, y: 0 };
        const mid = getSegmentMidpoint(ws);
        const g = room.geometry;
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    renderDimension(dim) {
        const layer = this.layers.dims;
        const isVert = dim.vertical;
        layer.add(new Konva.Line({ points: [dim.x1, dim.y1, dim.x2, dim.y2], stroke: '#555', strokeWidth: 1 }));
        if (isVert) {
            layer.add(new Konva.Line({ points: [dim.x1 - 4, dim.y1, dim.x1 + 4, dim.y1], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2 - 4, dim.y2, dim.x2 + 4, dim.y2], stroke: '#555', strokeWidth: 1 }));
        } else {
            layer.add(new Konva.Line({ points: [dim.x1, dim.y1 - 4, dim.x1, dim.y1 + 4], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2, dim.y2 - 4, dim.x2, dim.y2 + 4], stroke: '#555', strokeWidth: 1 }));
        }
        const midX = (dim.x1 + dim.x2) / 2, midY = (dim.y1 + dim.y2) / 2;
        layer.add(new Konva.Text({
            x: isVert ? midX - 28 : midX - 18, y: isVert ? midY - 5 : midY - 12,
            text: dim.label, fontSize: 9, fill: '#777', listening: false
        }));
    },

    select(type, id) {
        this.selection = { type, id };
    },

    deselect() {
        this.selection = { type: null, id: null };
    },

    getImage() { return this.stage ? this.stage.toDataURL({ pixelRatio: 2 }) : null; }
};

// ========== QA VALIDATION ==========
function runQA(doc) {
    const results = [];

    // All rooms labeled
    results.push({ rule: 'All rooms labeled', pass: doc.rooms.every(r => r.label), detail: 'OK' });

    // All wall segments have W1=SOUTH
    const badWalls = doc.rooms.filter(r => {
        const segs = doc.wallSegments.filter(ws => ws.roomId === r.id);
        if (segs.length < 4) return true;
        const w1 = segs.find(ws => ws.label === 'W1');
        return !w1;
    });
    results.push({ rule: 'Wall IDs (W1 exists)', pass: badWalls.length === 0, detail: badWalls.length > 0 ? `${badWalls.length} rooms` : 'OK' });

    // Closets
    results.push({ rule: 'Closets (CL-01, CL-02)', pass: doc.closets.length >= 2, detail: `${doc.closets.length} closets` });

    // Doors attached to walls
    const unattachedDoors = doc.doors.filter(d => !d.parentWallSegmentId);
    results.push({ rule: 'Doors attached to walls', pass: unattachedDoors.length === 0, detail: unattachedDoors.length > 0 ? `${unattachedDoors.length} floating` : 'OK' });

    // Windows attached to walls
    const unattachedWindows = doc.windows.filter(w => !w.parentWallSegmentId);
    results.push({ rule: 'Windows attached to walls', pass: unattachedWindows.length === 0, detail: unattachedWindows.length > 0 ? `${unattachedWindows.length} floating` : 'OK' });

    // MEP attached (except free-placed)
    const unattachedMEP = doc.mep.filter(m => !m.parentWallSegmentId && !m.freePlaced);
    results.push({ rule: 'MEP attached to walls', pass: unattachedMEP.length === 0, detail: unattachedMEP.length > 0 ? `${unattachedMEP.length} floating` : 'OK' });

    // POE anchored
    const poe = doc.mep.find(m => m.label.startsWith('POE'));
    const entryDoor = doc.doors.find(d => d.type === 'entry');
    results.push({ rule: 'POE anchored to entry', pass: poe && poe.anchorDoorId === entryDoor?.id, detail: poe ? 'OK' : 'Missing' });

    // Dimensions
    results.push({ rule: 'Dimensions present', pass: doc.dimensions.length > 0, detail: `${doc.dimensions.length}` });

    return results;
}

// ========== APP ==========
const App = {
    doc: null,
    currentTool: 'select',
    showGrid: true,
    showWallIds: true,
    showDims: true,
    pendingAttachment: null,

    init() {
        if (!Render.init('stage')) { alert('Init failed'); return; }
        this.doc = generate2BR1BA();
        this.render();
        this.updateTree();
        this.updateQABadge();
        console.log('App ready - tap walls to select');
    },

    newDoc() {
        this.doc = generate2BR1BA();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
    },

    render() {
        Render.render(this.doc, { showWallIds: this.showWallIds, showDims: this.showDims });
    },

    onWallTap(wallSegmentId) {
        const ws = this.doc.wallSegments.find(s => s.id === wallSegmentId);
        if (!ws) return;

        if (this.currentTool === 'select') {
            Render.select('wall', wallSegmentId);
            this.render();
            this.updateInspector();
            this.highlightTreeItem('wall', wallSegmentId);
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(this.currentTool)) {
            this.placeOnWall(ws, this.currentTool);
        }
    },

    onObjectTap(type, id) {
        Render.select(type, id);
        this.render();
        this.updateInspector();
        this.highlightTreeItem(type, id);
    },

    placeOnWall(ws, toolType) {
        const room = this.doc.rooms.find(r => r.id === ws.roomId);
        const segLen = getSegmentLength(ws);
        const defaultOffset = segLen * 0.3;

        let obj;
        switch (toolType) {
            case 'door':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'door'), type: 'interior',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 2.67 * FOOT, swing: 'in', swingDir: 'left'
                };
                this.doc.doors.push(obj);
                break;
            case 'window':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'window'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT, sillHeight: 36 * INCH
                };
                this.doc.windows.push(obj);
                break;
            case 'cased':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'cased'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT
                };
                this.doc.casedOpenings.push(obj);
                break;
            case 'pipe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'pipe'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
            case 'gas':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'gas'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
            case 'radiator':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'radiator'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT, height: 1 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'riser':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'riser'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 0.5 * FOOT, height: 0.5 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'poe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'poe'), type: 'entry',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
        }

        if (obj) {
            ws.attachedObjects.push({ type: toolType, id: obj.id, label: obj.label });
            Render.select(toolType === 'door' || toolType === 'window' || toolType === 'cased' ? toolType : 'mep', obj.id);
            this.render();
            this.updateTree();
            this.updateInspector();
            this.updateQABadge();
            this.setTool('select');
        }
    },

    setTool(tool) {
        this.currentTool = tool;
        $$('.tool-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.tool-btn[onclick*="'${tool}'"]`);
        if (btn) btn.classList.add('active');
        $('#btnSelect').classList.toggle('active', tool === 'select');

        // Show hint for placement tools
        const hint = $('#toolHint');
        if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(tool)) {
            hint.textContent = `Tap a wall to place ${tool.toUpperCase()}`;
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }
    },

    updateInspector() {
        const insp = $('#inspector');
        const sel = Render.selection;

        if (!sel.type || !sel.id) {
            insp.innerHTML = '<div class="inspector-title">Properties</div><div class="inspector-row">Tap wall or object to select</div>';
            return;
        }

        let html = '<div class="inspector-title">Properties</div>';

        if (sel.type === 'wall') {
            const ws = this.doc.wallSegments.find(s => s.id === sel.id);
            const room = this.doc.rooms.find(r => r.id === ws.roomId);
            html += `
                <div class="inspector-section">
                    <div class="inspector-section-title">Wall Segment</div>
                    <div class="inspector-row highlight"><span>${room?.label} — ${ws.label} (${ws.side})</span></div>
                    <div class="inspector-row">Type: <span>${ws.type}</span></div>
                    <div class="inspector-row">Length: <span>${(getSegmentLength(ws) / FOOT).toFixed(1)}'</span></div>
                </div>
                <div class="inspector-section">
                    <div class="inspector-section-title">Attached Objects (${ws.attachedObjects.length})</div>
                    <div class="attach-list">
                        ${ws.attachedObjects.map(a => `<div class="attach-item">${a.label} (${a.type})</div>`).join('') || '<div class="attach-item">None</div>'}
                    </div>
                </div>
            `;
        } else {
            // Find object
            let obj, type = sel.type, collection;
            if (type === 'door') { collection = this.doc.doors; }
            else if (type === 'window') { collection = this.doc.windows; }
            else if (type === 'cased') { collection = this.doc.casedOpenings; }
            else if (type === 'closet') { collection = this.doc.closets; }
            else if (type === 'mep') { collection = this.doc.mep; }

            obj = collection?.find(o => o.id === sel.id);
            if (!obj) {
                insp.innerHTML = '<div class="inspector-title">Properties</div><div class="inspector-row">Object not found</div>';
                return;
            }

            const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
            const room = this.doc.rooms.find(r => r.id === (obj.parentRoomId || ws?.roomId));

            html += `<div class="inspector-section">
                <div class="inspector-section-title">${obj.label}</div>
                <div class="inspector-row">Type: <span>${obj.type || type}</span></div>`;

            if (obj.width) html += `<div class="inspector-row">Width: <span>${(obj.width / FOOT).toFixed(1)}'</span></div>`;
            if (obj.distanceFromStart !== undefined) html += `<div class="inspector-row">Offset: <span>${(obj.distanceFromStart / FOOT).toFixed(1)}'</span></div>`;

            html += `</div>`;

            // ATTACHED TO section (CRITICAL)
            if (ws && room) {
                html += `
                    <div class="inspector-section">
                        <div class="inspector-section-title">Attached To</div>
                        <div class="inspector-row highlight">Room: <span>${room.label} ${room.type}</span></div>
                        <div class="inspector-row highlight">Wall: <span>${ws.label} (${ws.side})</span></div>
                        <div class="inspector-row">Segment ID: <span style="font-size:8px">${ws.id.substr(0,12)}...</span></div>
                    </div>
                    <button class="reattach-btn" onclick="App.startReattach('${obj.id}', '${type}')">Reattach to Different Wall</button>
                `;
            } else if (type === 'closet') {
                html += `<div class="inspector-section">
                    <div class="inspector-section-title">Parent</div>
                    <div class="inspector-row">Room: <span>${obj.parentRoom || 'N/A'}</span></div>
                </div>`;
            }
        }

        insp.innerHTML = html;
    },

    startReattach(objId, objType) {
        this.pendingAttachment = { objId, objType };
        this.setTool('select');
        $('#toolHint').textContent = 'Tap a wall to reattach';
        $('#toolHint').classList.add('show');
        alert('Tap a wall segment to reattach this object');
    },

    updateTree() {
        const tree = $('#objectTree');
        tree.innerHTML = '';

        const addGroup = (title, items, color, type) => {
            if (items.length === 0) return;
            const grp = document.createElement('div');
            grp.className = 'tree-group';
            grp.innerHTML = `<div class="tree-label">${title} (${items.length})</div>`;
            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'tree-item';
                el.dataset.type = type;
                el.dataset.id = item.id;
                const ws = this.doc.wallSegments.find(s => s.id === item.parentWallSegmentId);
                const wallInfo = ws ? ` → ${ws.label}` : '';
                el.innerHTML = `<div class="tree-dot" style="background:${color}"></div><span>${item.label}${item.type ? ' (' + item.type + ')' : ''}${wallInfo}</span>`;
                el.onclick = () => this.onObjectTap(type, item.id);
                grp.appendChild(el);
            });
            tree.appendChild(grp);
        };

        // Rooms with wall segments
        if (this.doc.rooms.length > 0) {
            const roomGrp = document.createElement('div');
            roomGrp.className = 'tree-group';
            roomGrp.innerHTML = `<div class="tree-label">ROOMS (${this.doc.rooms.length})</div>`;
            this.doc.rooms.forEach(room => {
                const roomEl = document.createElement('div');
                roomEl.className = 'tree-item';
                roomEl.innerHTML = `<div class="tree-dot" style="background:#f4d03f"></div><span>${room.label} - ${room.type}</span>`;
                roomGrp.appendChild(roomEl);

                // Wall segments under room
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    const wsEl = document.createElement('div');
                    wsEl.className = 'tree-item';
                    wsEl.style.paddingLeft = '20px';
                    wsEl.dataset.type = 'wall';
                    wsEl.dataset.id = ws.id;
                    wsEl.innerHTML = `<div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>${ws.label} (${ws.side}) [${ws.attachedObjects.length}]</span>`;
                    wsEl.onclick = () => this.onWallTap(ws.id);
                    roomGrp.appendChild(wsEl);
                });
            });
            tree.appendChild(roomGrp);
        }

        addGroup('DOORS', this.doc.doors, '#3b82f6', 'door');
        addGroup('WINDOWS', this.doc.windows, '#87ceeb', 'window');
        addGroup('OPENINGS', this.doc.casedOpenings, '#aaa', 'cased');
        addGroup('CLOSETS', this.doc.closets, '#666', 'closet');
        addGroup('MEP', this.doc.mep, '#22c55e', 'mep');
    },

    highlightTreeItem(type, id) {
        $$('.tree-item').forEach(el => el.classList.remove('selected'));
        const el = document.querySelector(`.tree-item[data-type="${type}"][data-id="${id}"]`);
        if (el) el.classList.add('selected');
    },

    toggle(what) {
        switch (what) {
            case 'grid': this.showGrid = !this.showGrid; $('#btnGrid').classList.toggle('active', this.showGrid); Render.layers.grid.visible(this.showGrid); break;
            case 'wallIds': this.showWallIds = !this.showWallIds; $('#btnWallIds').classList.toggle('active', this.showWallIds); this.render(); break;
            case 'dims': this.showDims = !this.showDims; $('#btnDims').classList.toggle('active', this.showDims); this.render(); break;
        }
        Render.stage.batchDraw();
    },

    toggleSidebar() { $('#sidebarLeft').classList.toggle('collapsed'); },

    resetView() {
        Render.stage.scale({ x: 1, y: 1 });
        Render.stage.position({ x: 0, y: 0 });
        Render.stage.batchDraw();
    },

    updateQABadge() {
        const results = runQA(this.doc);
        const fails = results.filter(r => !r.pass).length;
        const badge = $('#qaBadge');
        badge.textContent = fails === 0 ? 'QA: PASS' : `QA: ${fails} errors`;
        badge.className = 'qa-badge' + (fails > 0 ? ' error' : '');
    },

    showQA() {
        const results = runQA(this.doc);
        $('#qaContent').innerHTML = results.map(r => `
            <div class="qa-item">
                <span class="${r.pass ? 'qa-pass' : 'qa-fail'}">${r.pass ? '✓' : '✗'}</span>
                <span>${r.rule}</span>
                <span style="color:#888;margin-left:auto">${r.detail}</span>
            </div>
        `).join('');
        $('#qaModal').classList.add('show');
    },

    hideModal(which) { $(`#${which}Modal`).classList.remove('show'); },

    loadFBG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                this.doc = this.importFBG(data);
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateQABadge();
                this.updateInspector();
            } catch (err) { alert('Load error: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    },

    importFBG(data) {
        const doc = Doc.create();
        doc.address = data.address || '';
        const level = data.levels?.[data.currentLevelIndex || 0];
        if (!level) return doc;

        const objs = level.canvasObjects || [];
        let minX = Infinity, minY = Infinity;
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                minX = Math.min(minX, o.startX || 0, o.endX || 0);
                minY = Math.min(minY, o.startY || 0, o.endY || 0);
            }
        });
        const offX = isFinite(minX) ? 60 - minX : 0;
        const offY = isFinite(minY) ? 60 - minY : 0;

        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                if (isCloset) {
                    doc.closets.push({ id: Doc.uid(), label: Doc.label(doc, 'closet'), fbgName: o.name, geometry: { x, y, width: w, height: h } });
                } else {
                    const room = { id: Doc.uid(), label: Doc.label(doc, 'room'), type: rt.name || abbr, fbgName: o.name, isExterior: true, geometry: { x, y, width: w, height: h } };
                    createWallSegments(room, doc);
                    doc.rooms.push(room);
                }
            }
        });
        return doc;
    },

    exportPDF() {
        const qa = runQA(this.doc);
        const fails = qa.filter(r => !r.pass).length;
        if (fails > 0 && !confirm(`QA has ${fails} errors. Export anyway?`)) return;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'pt', 'letter');

        pdf.setFontSize(14);
        pdf.text('2BR/1BA Blueprint - Wall Segment Attachments', 40, 30);
        pdf.setFontSize(9);
        pdf.text(`Address: ${this.doc.address}`, 40, 45);
        pdf.text(`Date: ${new Date().toLocaleDateString()}`, 40, 57);
        pdf.text(`Rooms: ${this.doc.rooms.length} | Doors: ${this.doc.doors.length} | Windows: ${this.doc.windows.length}`, 40, 69);
        pdf.text(`QA: ${fails === 0 ? 'PASS' : fails + ' errors'}`, 300, 45);

        const img = Render.getImage();
        if (img) pdf.addImage(img, 'PNG', 40, 85, 700, 420);

        pdf.setFontSize(7);
        pdf.text('Wall IDs: W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south-most wall)', 40, 520);

        // Attachment summary
        let y = 535;
        pdf.setFontSize(8);
        pdf.text('Attachments:', 40, y);
        y += 10;
        this.doc.wallSegments.forEach(ws => {
            if (ws.attachedObjects.length > 0) {
                const room = this.doc.rooms.find(r => r.id === ws.roomId);
                const items = ws.attachedObjects.map(a => a.label).join(', ');
                pdf.text(`${room?.label} ${ws.label}: ${items}`, 50, y);
                y += 9;
                if (y > 580) { y = 535; pdf.addPage(); }
            }
        });

        pdf.save(`Blueprint_WallAttach_${new Date().toISOString().split('T')[0]}.pdf`);
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());
</script>
</body>
</html>
