<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Blueprint Builder - Wall Segment Selection</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-canvas: #ffffff;
            --bg-panel: rgba(245, 247, 250, 0.92);
            --bg-tool: rgba(255, 255, 255, 0.8);
            --bg-tool-hover: rgba(59, 130, 246, 0.1);
            --border: transparent;
            --text: #1f2937;
            --text-dim: #6b7280;
            --accent: #2563eb;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
            --wall-color: #2d3748;
            --grid-color: #bfdbfe;
            --grid-major: #93c5fd;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif; background: var(--bg-canvas); color: var(--text); height: 100vh; height: 100dvh; overflow: hidden; touch-action: none; }
        .app { display: flex; flex-direction: column; height: 100%; }

        .topbar { display: flex; align-items: center; padding: 6px 12px; background: var(--bg-panel); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-bottom: none; gap: 6px; flex-wrap: nowrap; overflow-x: auto; min-height: 44px; }
        .topbar::-webkit-scrollbar { display: none; }
        .btn { padding: 8px 12px; background: var(--bg-tool); border: none; color: var(--text); border-radius: 8px; font-size: 11px; font-weight: 500; cursor: pointer; white-space: nowrap; min-height: 32px; transition: all 0.15s ease; }
        .btn:hover { background: var(--bg-tool-hover); }
        .btn:active { background: var(--accent-blue); color: white; }
        .btn.active { background: var(--accent-blue); color: white; }
        .btn.warn { background: var(--accent-red); color: white; }
        .sep { width: 1px; height: 20px; background: #e5e7eb; margin: 0 6px; flex-shrink: 0; }

        .main { display: flex; flex: 1; overflow: hidden; position: relative; }

        .sidebar-left { width: 180px; background: var(--bg-panel); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-right: none; display: flex; flex-direction: column; overflow: hidden; transition: width 0.2s ease; position: relative; z-index: 10; }
        .sidebar-left.collapsed { width: 44px; }
        .sidebar-left.collapsed .sidebar-scroll { display: none; }
        .sidebar-left.collapsed .sidebar-toggle { writing-mode: vertical-rl; text-orientation: mixed; padding: 12px 8px; }
        .sidebar-toggle { padding: 10px; background: transparent; border: none; color: var(--accent); font-size: 16px; cursor: pointer; border-bottom: none; }
        .sidebar-scroll { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 8px; }
        .sidebar-scroll::-webkit-scrollbar { width: 4px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 2px; }
        .section { margin-bottom: 12px; }
        .section-header { padding: 6px 8px; font-size: 9px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .section-content { padding: 4px; }
        .section-content.collapsed { display: none; }

        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .tool-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px 4px; background: var(--bg-tool); border: none; border-radius: 10px; color: var(--text); font-size: 8px; font-weight: 500; cursor: pointer; min-height: 48px; transition: all 0.15s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .tool-btn:hover { background: var(--bg-tool-hover); transform: translateY(-1px); }
        .tool-btn:active, .tool-btn.active { background: var(--accent-blue); color: white; }
        .tool-btn svg { width: 20px; height: 20px; margin-bottom: 3px; }
        .tool-btn svg * { stroke: currentColor; fill: none; stroke-width: 1.5; }
        .tool-btn.filled svg * { fill: currentColor; stroke: none; }

        .tree-group { margin-bottom: 8px; }
        .tree-label { font-size: 9px; color: var(--accent); padding: 4px 8px; font-weight: 600; }
        .tree-item { display: flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 10px; cursor: pointer; border-radius: 6px; transition: background 0.1s; }
        .tree-item:hover { background: var(--bg-tool-hover); }
        .tree-item:active, .tree-item.selected { background: rgba(59,130,246,0.2); }
        .tree-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }

        .canvas-wrap { flex: 1; background: var(--bg-canvas); position: relative; overflow: hidden; }
        #stage { width: 100%; height: 100%; }
        .north-arrow { position: absolute; top: 12px; right: 12px; width: 36px; height: 36px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; color: var(--accent); border: 2px solid var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .scale-label { position: absolute; bottom: 12px; left: 12px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); padding: 6px 12px; border-radius: 6px; font-size: 10px; color: var(--text-dim); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .qa-badge { position: absolute; top: 12px; left: 12px; background: var(--accent-green); color: #fff; padding: 5px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .qa-badge.error { background: var(--accent-red); }
        .tool-hint { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 10px; font-size: 11px; color: var(--accent); display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .tool-hint.show { display: block; }

        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal.show { display: flex; }
        .modal-box { background: white; border: none; border-radius: 16px; max-width: 420px; width: 100%; max-height: 80vh; overflow: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
        .modal-head { padding: 16px 20px; border-bottom: 1px solid #f3f4f6; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 15px; font-weight: 600; color: var(--text); }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; }
        .modal-body { padding: 20px; font-size: 12px; }
        .qa-item { padding: 8px 0; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; gap: 10px; }
        .qa-pass { color: var(--accent-green); }
        .qa-fail { color: var(--accent-red); }

        @media (max-width: 600px) {
            .sidebar-left { width: 140px; }
            .tool-grid { grid-template-columns: repeat(2, 1fr); }
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
<div class="app">
    <div class="topbar">
        <button class="btn" onclick="App.newDoc()">New</button>
        <button class="btn" onclick="$('#fbgInput').click()">Load</button>
        <input type="file" id="fbgInput" accept=".fbg,.fgs,.json" onchange="App.loadFBG(event)">
        <button class="btn" onclick="App.exportPDF()">PDF</button>
        <div class="sep"></div>
        <button class="btn active" id="btnGrid" onclick="App.toggle('grid')">Grid</button>
        <button class="btn active" id="btnWallIds" onclick="App.toggle('wallIds')">W-ID</button>
        <button class="btn active" id="btnDims" onclick="App.toggle('dims')">Dims</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.resetView()">Reset</button>
        <button class="btn active" id="btnSelect" onclick="App.setTool('select')">Select</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.showQA()">QA</button>
    </div>
    <div class="main">
        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-toggle" onclick="App.toggleSidebar()">☰</button>
            <div class="sidebar-scroll">
                <div class="section">
                    <div class="section-header">Geometry (draw)</div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr 1fr;">
                            <button class="tool-btn" onclick="App.setTool('room')"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1" stroke-dasharray="3,2"/><line x1="12" y1="8" x2="12" y2="16" stroke-width="2"/><line x1="8" y1="12" x2="16" y2="12" stroke-width="2"/></svg>Room</button>
                            <button class="tool-btn" onclick="App.setTool('editShape')" style="background: #22c55e; color: white;"><svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="1" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="4" cy="4" r="3" fill="currentColor"/><circle cx="20" cy="4" r="3" fill="currentColor"/><circle cx="20" cy="20" r="3" fill="currentColor"/><circle cx="4" cy="20" r="3" fill="currentColor"/><rect x="10" y="2" width="4" height="4" fill="currentColor" rx="1"/></svg>Edit Shape</button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Openings (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('door')"><svg viewBox="0 0 24 24"><rect x="6" y="3" width="12" height="18" rx="1"/><circle cx="15" cy="12" r="1.5" fill="currentColor"/></svg>Door</button>
                            <button class="tool-btn" onclick="App.setTool('window')"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="1"/><line x1="12" y1="7" x2="12" y2="17"/></svg>Window</button>
                            <button class="tool-btn" onclick="App.setTool('cased')"><svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3,2"/></svg>Cased</button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">MEP (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('pipe')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>Pipe</button>
                            <button class="tool-btn filled" onclick="App.setTool('gas')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>Gas</button>
                            <button class="tool-btn" onclick="App.setTool('radiator')"><svg viewBox="0 0 24 24"><rect x="3" y="8" width="18" height="10" rx="1"/><line x1="6" y1="9" x2="6" y2="17"/><line x1="9" y1="9" x2="9" y2="17"/><line x1="12" y1="9" x2="12" y2="17"/><line x1="15" y1="9" x2="15" y2="17"/><line x1="18" y1="9" x2="18" y2="17"/></svg>Radiator</button>
                            <button class="tool-btn" onclick="App.setTool('riser')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="3"/></svg>Pipe Riser</button>
                            <button class="tool-btn" onclick="App.setTool('poe')"><svg viewBox="0 0 24 24"><polygon points="12,2 22,12 17,12 17,22 7,22 7,12 2,12" fill="currentColor"/></svg>POE</button>
                        </div>
                    </div>
                </div>
                <div class="section" id="objectSection">
                    <div class="section-header" onclick="App.toggleObjectPanel()">Objects <span id="objectToggle">▶</span></div>
                    <div class="section-content collapsed" id="objectTree"></div>
                </div>
                <div class="section">
                    <div class="section-header">Actions</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" id="btnUndo" onclick="App.undo()" title="Undo (Ctrl+Z)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M3 10h10a5 5 0 015 5v2M3 10l5-5M3 10l5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                Undo
                            </button>
                            <button class="tool-btn" id="btnRedo" onclick="App.redo()" title="Redo (Ctrl+Y)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M21 10H11a5 5 0 00-5 5v2M21 10l-5-5M21 10l-5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                Redo
                            </button>
                            <button class="tool-btn" id="deleteBtn" onclick="App.deleteSelected()" title="Delete selected" style="background: var(--accent-red); border-color: var(--accent-red); opacity: 0.4;" disabled>
                                <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14M10 11v6M14 11v6" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-wrap">
            <div id="stage"></div>
            <div class="north-arrow">N</div>
            <div class="scale-label">1/4" = 1'-0"</div>
            <div class="qa-badge" id="qaBadge">QA: --</div>
            <div class="tool-hint" id="toolHint">Tap a wall segment to place</div>
        </div>
    </div>
</div>

<div class="modal" id="qaModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">QA Validation</div>
            <button class="modal-close" onclick="App.hideModal('qa')">&times;</button>
        </div>
        <div class="modal-body" id="qaContent"></div>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ========== CONSTANTS ==========
const SCALE = 4;
const INCH = SCALE;
const FOOT = 12 * SCALE;
const WALL_EXT = 6 * INCH;
const WALL_INT = 4.5 * INCH;
const SNAP_DISTANCE = 24; // Mobile-friendly snap distance in pixels
const HIT_WIDTH = 28; // Hit region width for wall segments
const GRID_SNAP = FOOT; // Snap to 1-foot grid
const VERTEX_HANDLE_RADIUS = 10; // Vertex drag handle radius
const EDGE_HANDLE_SIZE = 8; // Edge drag handle size

// ========== POLYGON GEOMETRY HELPERS ==========
// Get wall edges derived from room vertices (Room-First model)
function getWallEdges(room) {
    const edges = [];
    const verts = room.vertices;
    if (!verts || verts.length < 3) return edges;
    const n = verts.length;

    // Find SOUTH-most edge (highest Y midpoint)
    let southIdx = 0;
    let maxMidY = -Infinity;
    for (let i = 0; i < n; i++) {
        const midY = (verts[i].y + verts[(i + 1) % n].y) / 2;
        if (midY > maxMidY) {
            maxMidY = midY;
            southIdx = i;
        }
    }

    // Build edges starting from south-most, clockwise
    for (let i = 0; i < n; i++) {
        const idx = (southIdx + i) % n;
        const nextIdx = (idx + 1) % n;
        edges.push({
            edgeIndex: i,
            label: 'W' + (i + 1),
            roomId: room.id,
            roomLabel: room.label,
            start: { x: verts[idx].x, y: verts[idx].y },
            end: { x: verts[nextIdx].x, y: verts[nextIdx].y },
            isExterior: room.isExterior
        });
    }
    return edges;
}

// Get edge length
function getEdgeLength(edge) {
    return Math.sqrt(
        Math.pow(edge.end.x - edge.start.x, 2) +
        Math.pow(edge.end.y - edge.start.y, 2)
    );
}

// Get world position from normalized edge position (t: 0-1)
function getPositionOnEdge(edge, t) {
    return {
        x: edge.start.x + t * (edge.end.x - edge.start.x),
        y: edge.start.y + t * (edge.end.y - edge.start.y)
    };
}

// Convert world position to t value (0-1) on edge
function getTOnEdge(edge, worldX, worldY) {
    const len = getEdgeLength(edge);
    if (len === 0) return 0;
    const dx = edge.end.x - edge.start.x;
    const dy = edge.end.y - edge.start.y;
    return Math.max(0, Math.min(1,
        ((worldX - edge.start.x) * dx + (worldY - edge.start.y) * dy) / (len * len)
    ));
}

// Get edge midpoint
function getEdgeMidpoint(edge) {
    return {
        x: (edge.start.x + edge.end.x) / 2,
        y: (edge.start.y + edge.end.y) / 2
    };
}

// Get edge angle in radians
function getEdgeAngle(edge) {
    return Math.atan2(edge.end.y - edge.start.y, edge.end.x - edge.start.x);
}

// Point to line distance for edge-based hit detection
function pointToEdgeDistance(px, py, edge) {
    const dx = edge.end.x - edge.start.x;
    const dy = edge.end.y - edge.start.y;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.sqrt((px - edge.start.x) ** 2 + (py - edge.start.y) ** 2);
    let t = ((px - edge.start.x) * dx + (py - edge.start.y) * dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = edge.start.x + t * dx;
    const nearY = edge.start.y + t * dy;
    return { distance: Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2), t, nearX, nearY };
}

// Find nearest wall edge within a room or across all rooms
function findNearestWallEdge(x, y, doc, roomId = null) {
    let nearest = null;
    let minDist = HIT_WIDTH;
    let nearestT = 0;
    let nearestPoint = null;
    let nearestRoom = null;

    const roomsToCheck = roomId
        ? doc.rooms.filter(r => r.id === roomId)
        : doc.rooms;

    roomsToCheck.forEach(room => {
        const edges = getWallEdges(room);
        edges.forEach((edge, idx) => {
            const result = pointToEdgeDistance(x, y, edge);
            if (result.distance < minDist) {
                minDist = result.distance;
                nearest = edge;
                nearestT = result.t;
                nearestPoint = { x: result.nearX, y: result.nearY };
                nearestRoom = room;
            }
        });
    });

    return { edge: nearest, distance: minDist, t: nearestT, point: nearestPoint, room: nearestRoom };
}

// Convert geometry (x, y, width, height) to vertices array (clockwise from bottom-left)
function geometryToVertices(g) {
    return [
        { x: g.x, y: g.y + g.height },           // bottom-left (SW)
        { x: g.x + g.width, y: g.y + g.height }, // bottom-right (SE)
        { x: g.x + g.width, y: g.y },            // top-right (NE)
        { x: g.x, y: g.y }                       // top-left (NW)
    ];
}

// Get bounding box from vertices
function getVerticesBounds(vertices) {
    if (!vertices || vertices.length === 0) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    vertices.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
    });
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

// Check if a point is inside a polygon (vertices)
function pointInPolygon(px, py, vertices) {
    let inside = false;
    const n = vertices.length;
    for (let i = 0, j = n - 1; i < n; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;
        if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    return inside;
}

// ========== SNAPPING FUNCTIONS ==========
function snapToGrid(value) {
    return Math.round(value / GRID_SNAP) * GRID_SNAP;
}

// Find all corner points for wall snapping (room vertices + closet vertices)
function findWallSnapPoints(doc) {
    const points = [];

    // Room vertices
    doc.rooms.forEach(room => {
        if (room.vertices) {
            room.vertices.forEach((v, idx) => {
                points.push({ x: v.x, y: v.y, type: 'room-corner', roomId: room.id, vertexIdx: idx });
            });
        }
    });

    // Closet vertices
    doc.closets.forEach(closet => {
        if (closet.vertices) {
            closet.vertices.forEach((v, idx) => {
                points.push({ x: v.x, y: v.y, type: 'closet-corner', closetId: closet.id, vertexIdx: idx });
            });
        }
    });

    return points;
}

// Snap a point to nearest corner or grid
function snapWallPoint(x, y, snapPoints) {
    let bestPoint = null;
    let bestDist = SNAP_DISTANCE;

    for (const pt of snapPoints) {
        const dist = Math.sqrt(Math.pow(x - pt.x, 2) + Math.pow(y - pt.y, 2));
        if (dist < bestDist) {
            bestDist = dist;
            bestPoint = pt;
        }
    }

    if (bestPoint) {
        return { x: bestPoint.x, y: bestPoint.y, snapped: true, type: bestPoint.type };
    }

    // Fall back to grid snap
    return { x: snapToGrid(x), y: snapToGrid(y), snapped: false, type: 'grid' };
}

function findRoomSnapPoints(doc, excludeRoomId) {
    // Get all room vertex coordinates for snapping (excluding current room)
    const snapPoints = { x: [], y: [] };
    doc.rooms.forEach(room => {
        if (room.id === excludeRoomId) return;
        if (room.vertices) {
            room.vertices.forEach(v => {
                if (!snapPoints.x.includes(v.x)) snapPoints.x.push(v.x);
                if (!snapPoints.y.includes(v.y)) snapPoints.y.push(v.y);
            });
        }
    });
    return snapPoints;
}

function snapRoomPosition(x, y, width, height, snapPoints) {
    let snappedX = x;
    let snappedY = y;

    // Check left edge
    for (const sx of snapPoints.x) {
        if (Math.abs(x - sx) < SNAP_DISTANCE) { snappedX = sx; break; }
        if (Math.abs(x + width - sx) < SNAP_DISTANCE) { snappedX = sx - width; break; }
    }

    // Check top edge
    for (const sy of snapPoints.y) {
        if (Math.abs(y - sy) < SNAP_DISTANCE) { snappedY = sy; break; }
        if (Math.abs(y + height - sy) < SNAP_DISTANCE) { snappedY = sy - height; break; }
    }

    // Also snap to grid if not snapped to room
    if (snappedX === x) snappedX = snapToGrid(x);
    if (snappedY === y) snappedY = snapToGrid(y);

    return { x: snappedX, y: snappedY };
}

// ========== DOCUMENT MODEL ==========
const Doc = {
    create() {
        return {
            id: this.uid(),
            version: '5.0',  // Updated for Room-First polygon model
            address: '2BR/1BA Blueprint',
            counters: { room: 0, door: 0, window: 0, closet: 0, cased: 0, pipe: 0, gas: 0, riser: 0, radiator: 0, poe: 0 },
            rooms: [],       // Rooms with vertices arrays
            doors: [],       // Attachments use parentRoomId + parentWallEdgeIndex + tAlongEdge
            windows: [],
            casedOpenings: [],
            closets: [],     // Closets with hostRoomId for sub-room linking
            mep: [],
            dimensions: []
        };
    },
    uid() { return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); },
    label(doc, type) {
        doc.counters[type] = (doc.counters[type] || 0) + 1;
        const prefixes = { room: 'Rm', door: 'D', window: 'WIN', closet: 'CL', cased: 'OP', pipe: 'PIPE', gas: 'GAS', riser: 'PRSR', radiator: 'RAD', poe: 'POE' };
        const n = doc.counters[type];
        return (prefixes[type] || type.toUpperCase()) + '-' + (n < 10 ? '0' : '') + n;
    }
};

// ========== ROOM CREATION HELPERS ==========
// Create a room with vertices from geometry (for backwards compatibility and new room creation)
function createRoomFromGeometry(geometry, doc, options = {}) {
    const vertices = geometryToVertices(geometry);
    const room = {
        id: Doc.uid(),
        label: Doc.label(doc, 'room'),
        type: options.type || 'Room',
        roomType: options.roomType || 'Room',  // 'Room' | 'Closet'
        isExterior: options.isExterior !== undefined ? options.isExterior : true,
        vertices: vertices
    };
    return room;
}

// Legacy helpers for segment-like access (redirect to edge functions)
function getSegmentLength(seg) {
    // Works with both old segment format and new edge format
    if (seg.start && seg.end) {
        return getEdgeLength(seg);
    }
    return Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
}

function getSegmentMidpoint(seg) {
    if (seg.start && seg.end) {
        return getEdgeMidpoint(seg);
    }
    return { x: (seg.x1 + seg.x2) / 2, y: (seg.y1 + seg.y2) / 2 };
}

function getSegmentAngle(seg) {
    if (seg.start && seg.end) {
        return getEdgeAngle(seg);
    }
    return Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1);
}

// Get all attachments (doors, windows, MEP) for a specific room and edge
function getAttachmentsOnEdge(doc, roomId, edgeIndex) {
    const attachments = [];
    const collections = [
        { items: doc.doors, type: 'door' },
        { items: doc.windows, type: 'window' },
        { items: doc.casedOpenings, type: 'cased' },
        { items: doc.mep, type: 'mep' }
    ];

    collections.forEach(({ items, type }) => {
        items.forEach(item => {
            if (item.parentRoomId === roomId && item.parentWallEdgeIndex === edgeIndex) {
                attachments.push({ ...item, attachmentType: type });
            }
        });
    });

    return attachments;
}

// ========== MARK EXTERIOR WALLS ==========
// Determines which room edges are on the building perimeter (exterior) vs shared with other rooms (interior)
// Stores exterior edge info in room.exteriorEdges array
function markExteriorWalls(doc) {
    if (doc.rooms.length === 0) return;

    // Find building bounding box from all room vertices
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    doc.rooms.forEach(room => {
        if (room.vertices) {
            room.vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
        }
    });

    // Tolerance for edge detection (walls on perimeter)
    const tolerance = 2;

    // Mark each room's exterior edges
    doc.rooms.forEach(room => {
        room.exteriorEdges = [];
        const edges = getWallEdges(room);

        edges.forEach((edge, idx) => {
            const midX = (edge.start.x + edge.end.x) / 2;
            const midY = (edge.start.y + edge.end.y) / 2;
            const isVertical = Math.abs(edge.start.x - edge.end.x) < tolerance;
            const isHorizontal = Math.abs(edge.start.y - edge.end.y) < tolerance;

            let isExterior = false;

            if (isHorizontal) {
                // Check if on top or bottom edge of building
                if (Math.abs(midY - minY) < tolerance || Math.abs(midY - maxY) < tolerance) {
                    isExterior = true;
                }
            }
            if (isVertical) {
                // Check if on left or right edge of building
                if (Math.abs(midX - minX) < tolerance || Math.abs(midX - maxX) < tolerance) {
                    isExterior = true;
                }
            }

            if (isExterior) {
                room.exteriorEdges.push(idx);
            }
        });
    });
}

// Check if a specific edge of a room is exterior
function isEdgeExterior(room, edgeIndex) {
    return room.exteriorEdges && room.exteriorEdges.includes(edgeIndex);
}

// ========== GENERATE 2BR/1BA ==========
function generate2BR1BA() {
    const doc = Doc.create();

    // Layout: Clean 2x3 grid with shared walls, no gaps
    // Total exterior: 26' x 20' (compact ranch-style)
    //
    //      0      12     16      26
    //      +------+------+-------+  0
    //      | Bed1 | Hall |Kitchen|
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 10
    //      |Living| Bath | Bed 2 |
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 20
    //
    const startX = 60, startY = 60;

    // Grid columns (x positions)
    const col1 = startX;                    // Left edge
    const col2 = startX + 12 * FOOT;        // 12'
    const col3 = col2 + 4 * FOOT;           // 16'
    const col4 = col3 + 10 * FOOT;          // 26' (right edge)

    // Grid rows (y positions)
    const row1 = startY;                    // Top edge
    const row2 = startY + 10 * FOOT;        // 10'
    const row3 = row2 + 10 * FOOT;          // 20' (bottom edge)

    // Helper to create room with vertices (clockwise from bottom-left for W1=south)
    const makeRoom = (x, y, w, h, type, isExterior) => {
        return {
            id: Doc.uid(),
            label: Doc.label(doc, 'room'),
            type: type,
            roomType: 'Room',
            isExterior: isExterior,
            vertices: [
                { x: x, y: y + h },           // bottom-left (SW)
                { x: x + w, y: y + h },       // bottom-right (SE)
                { x: x + w, y: y },           // top-right (NE)
                { x: x, y: y }                // top-left (NW)
            ]
        };
    };

    // ========== ROW 1: Bed1 | Hall | Kitchen ==========
    const bed1 = makeRoom(col1, row1, 12 * FOOT, 10 * FOOT, 'Bedroom 1', true);
    doc.rooms.push(bed1);

    const hall = makeRoom(col2, row1, 4 * FOOT, 10 * FOOT, 'Hall', false);
    doc.rooms.push(hall);

    const kitchen = makeRoom(col3, row1, 10 * FOOT, 10 * FOOT, 'Kitchen', true);
    doc.rooms.push(kitchen);

    // ========== ROW 2: Living | Bath | Bed2 ==========
    const living = makeRoom(col1, row2, 12 * FOOT, 10 * FOOT, 'Living', true);
    doc.rooms.push(living);

    const bath = makeRoom(col2, row2, 4 * FOOT, 10 * FOOT, 'Bathroom', false);
    doc.rooms.push(bath);

    const bed2 = makeRoom(col3, row2, 10 * FOOT, 10 * FOOT, 'Bedroom 2', true);
    doc.rooms.push(bed2);

    // Mark which edges are actually on the building exterior vs interior (shared)
    markExteriorWalls(doc);

    // ========== CLOSETS (as sub-rooms with vertices) ==========
    // CL-01: Inside Bedroom 1, NE corner (4' x 3')
    const bed1Bounds = getVerticesBounds(bed1.vertices);
    const cl1 = {
        id: Doc.uid(),
        label: Doc.label(doc, 'closet'),
        type: 'Closet',
        roomType: 'Closet',
        hostRoomId: bed1.id,
        hostEdgeIndex: 2,  // W3 (north wall)
        tStart: 0.67, tEnd: 1.0,  // Right side of north wall
        depth: 3 * FOOT,
        vertices: geometryToVertices({
            x: bed1Bounds.x + bed1Bounds.width - 4 * FOOT,
            y: bed1Bounds.y,
            width: 4 * FOOT,
            height: 3 * FOOT
        })
    };
    doc.closets.push(cl1);

    // CL-02: Inside Bedroom 2, NW corner (4' x 3')
    const bed2Bounds = getVerticesBounds(bed2.vertices);
    const cl2 = {
        id: Doc.uid(),
        label: Doc.label(doc, 'closet'),
        type: 'Closet',
        roomType: 'Closet',
        hostRoomId: bed2.id,
        hostEdgeIndex: 2,  // W3 (north wall)
        tStart: 0.0, tEnd: 0.4,  // Left side of north wall
        depth: 3 * FOOT,
        vertices: geometryToVertices({
            x: bed2Bounds.x,
            y: bed2Bounds.y,
            width: 4 * FOOT,
            height: 3 * FOOT
        })
    };
    doc.closets.push(cl2);

    // ========== DOORS ==========
    // Wall reference (clockwise from south): W1=SOUTH (edgeIndex 0), W2=EAST (1), W3=NORTH (2), W4=WEST (3)
    // tAlongEdge: 0 = start of edge, 1 = end of edge

    // Helper: convert absolute distance to tAlongEdge for a room/closet
    const closetDistToT = (closet, edgeIndex, dist) => {
        const edges = getWallEdges(closet);
        if (!edges[edgeIndex]) return 0.5;
        const edgeLen = getEdgeLength(edges[edgeIndex]);
        return dist / edgeLen;
    };

    // Closet doors (on closet's south wall W1 which faces into bedroom)
    // CL-01 door
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'closet',
        parentRoomId: cl1.id,
        parentWallEdgeIndex: 0,  // W1 (south wall of closet)
        tAlongEdge: closetDistToT(cl1, 0, 1.5 * FOOT),
        width: 2 * FOOT,
        swing: 'out', swingDir: 'left'
    });

    // CL-02 door
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'closet',
        parentRoomId: cl2.id,
        parentWallEdgeIndex: 0,  // W1 (south wall of closet)
        tAlongEdge: closetDistToT(cl2, 0, 1.5 * FOOT),
        width: 2 * FOOT,
        swing: 'out', swingDir: 'right'
    });

    // Helper: convert absolute distance to tAlongEdge
    const distToT = (room, edgeIndex, dist) => {
        const edges = getWallEdges(room);
        const edgeLen = getEdgeLength(edges[edgeIndex]);
        return dist / edgeLen;
    };

    // D-01: Entry door on Living south wall (W1)
    const d1 = {
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'entry',
        parentRoomId: living.id,
        parentWallEdgeIndex: 0,  // W1 (south)
        tAlongEdge: distToT(living, 0, 3 * FOOT),
        width: 3 * FOOT,
        swing: 'in', swingDir: 'left'
    };
    doc.doors.push(d1);

    // POE anchored to entry door
    const poe1 = {
        id: Doc.uid(), label: Doc.label(doc, 'poe'), type: 'entry',
        parentRoomId: living.id,
        parentWallEdgeIndex: 0,
        tAlongEdge: distToT(living, 0, 4.5 * FOOT),
        anchorDoorId: d1.id
    };
    doc.mep.push(poe1);

    // D-02: Bed 1 to Hall - on Bed1's east wall (W2, edgeIndex 1)
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
        parentRoomId: bed1.id,
        parentWallEdgeIndex: 1,  // W2 (east)
        tAlongEdge: distToT(bed1, 1, 4 * FOOT),
        width: 2.67 * FOOT,
        swing: 'in', swingDir: 'right'
    });

    // D-03: Bath to Hall - on Bath's north wall (W3, edgeIndex 2)
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
        parentRoomId: bath.id,
        parentWallEdgeIndex: 2,  // W3 (north)
        tAlongEdge: distToT(bath, 2, 0.5 * FOOT),
        width: 2.5 * FOOT,
        swing: 'in', swingDir: 'right'
    });

    // D-04: Bed 2 to Bath - on Bed2's west wall (W4, edgeIndex 3)
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
        parentRoomId: bed2.id,
        parentWallEdgeIndex: 3,  // W4 (west)
        tAlongEdge: distToT(bed2, 3, 4 * FOOT),
        width: 2.67 * FOOT,
        swing: 'in', swingDir: 'left'
    });

    // D-05: Kitchen to Hall - on Kitchen's west wall (W4, edgeIndex 3)
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
        parentRoomId: kitchen.id,
        parentWallEdgeIndex: 3,  // W4 (west)
        tAlongEdge: distToT(kitchen, 3, 4 * FOOT),
        width: 2.67 * FOOT,
        swing: 'in', swingDir: 'left'
    });

    // D-06: Living to Bath - on Living's east wall (W2, edgeIndex 1)
    doc.doors.push({
        id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
        parentRoomId: living.id,
        parentWallEdgeIndex: 1,  // W2 (east)
        tAlongEdge: distToT(living, 1, 4 * FOOT),
        width: 2.67 * FOOT,
        swing: 'out', swingDir: 'right'
    });

    // ========== WINDOWS ==========
    // WIN-01: Living west wall (W4, edgeIndex 3) - exterior
    doc.windows.push({
        id: Doc.uid(), label: Doc.label(doc, 'window'),
        parentRoomId: living.id,
        parentWallEdgeIndex: 3,  // W4 (west) - exterior
        tAlongEdge: distToT(living, 3, 2 * FOOT),
        width: 5 * FOOT,
        sillHeight: 36 * INCH
    });

    // WIN-02: Bed 1 north wall (W3, edgeIndex 2)
    doc.windows.push({
        id: Doc.uid(), label: Doc.label(doc, 'window'),
        parentRoomId: bed1.id,
        parentWallEdgeIndex: 2,  // W3 (north)
        tAlongEdge: distToT(bed1, 2, 3 * FOOT),
        width: 4 * FOOT,
        sillHeight: 36 * INCH
    });

    // WIN-03: Bed 2 south wall (W1, edgeIndex 0)
    doc.windows.push({
        id: Doc.uid(), label: Doc.label(doc, 'window'),
        parentRoomId: bed2.id,
        parentWallEdgeIndex: 0,  // W1 (south)
        tAlongEdge: distToT(bed2, 0, 4 * FOOT),
        width: 4 * FOOT,
        sillHeight: 36 * INCH
    });

    // WIN-04: Kitchen east wall (W2, edgeIndex 1) - exterior
    doc.windows.push({
        id: Doc.uid(), label: Doc.label(doc, 'window'),
        parentRoomId: kitchen.id,
        parentWallEdgeIndex: 1,  // W2 (east) - exterior
        tAlongEdge: distToT(kitchen, 1, 3 * FOOT),
        width: 3 * FOOT,
        sillHeight: 42 * INCH
    });

    // ========== MEP ==========
    // Radiator in Living on west wall (W4, edgeIndex 3) - near window
    doc.mep.push({
        id: Doc.uid(), label: Doc.label(doc, 'radiator'),
        parentRoomId: living.id,
        parentWallEdgeIndex: 3,  // W4 (west) - exterior, near window
        tAlongEdge: distToT(living, 3, 8 * FOOT),
        width: 3 * FOOT, height: 1 * FOOT,
        side: 'interior'
    });

    // Riser near radiator on west wall (W4, edgeIndex 3)
    doc.mep.push({
        id: Doc.uid(), label: Doc.label(doc, 'riser'),
        parentRoomId: living.id,
        parentWallEdgeIndex: 3,  // W4 (west) - near radiator
        tAlongEdge: distToT(living, 3, 7.5 * FOOT),
        width: 0.5 * FOOT, height: 0.5 * FOOT,
        side: 'interior'
    });

    // ========== DIMENSIONS ==========
    const totalW = col4 - col1;  // 26'
    const totalH = row3 - row1;  // 20'
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalW / FOOT)}'-0"`, x1: startX, y1: startY - 25, x2: startX + totalW, y2: startY - 25 });
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalH / FOOT)}'-0"`, x1: startX - 25, y1: startY, x2: startX - 25, y2: startY + totalH, vertical: true });

    return doc;
}

// ========== RENDERER ==========
const Render = {
    stage: null,
    layers: {},
    wallGroups: {},
    selection: { type: null, id: null },

    init(containerId) {
        const c = document.getElementById(containerId);
        if (!c) return false;
        const r = c.getBoundingClientRect();
        this.stage = new Konva.Stage({ container: containerId, width: r.width, height: r.height, draggable: true });

        this.layers.grid = new Konva.Layer();
        this.layers.rooms = new Konva.Layer();
        this.layers.walls = new Konva.Layer();
        this.layers.openings = new Konva.Layer();
        this.layers.mep = new Konva.Layer();
        this.layers.labels = new Konva.Layer();
        this.layers.dims = new Konva.Layer();
        this.layers.hit = new Konva.Layer(); // Hit regions layer

        this.stage.add(this.layers.grid, this.layers.rooms, this.layers.walls, this.layers.hit, this.layers.openings, this.layers.mep, this.layers.labels, this.layers.dims);

        this.stage.on('wheel', e => {
            e.evt.preventDefault();
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            const mousePointTo = { x: (pointer.x - this.stage.x()) / oldScale, y: (pointer.y - this.stage.y()) / oldScale };

            // Gentler zoom factor (1.03 instead of 1.1) with min/max limits
            const zoomFactor = 1.03;
            const minScale = 0.3;
            const maxScale = 3;
            let newScale = e.evt.deltaY > 0 ? oldScale / zoomFactor : oldScale * zoomFactor;
            newScale = Math.max(minScale, Math.min(maxScale, newScale));

            this.stage.scale({ x: newScale, y: newScale });
            this.stage.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
        });

        // Click on empty canvas to deselect
        this.stage.on('click tap', (e) => {
            // Only deselect if clicking directly on stage (not on objects)
            if (e.target === this.stage) {
                App.deselect();
            }
        });

        new ResizeObserver(() => {
            const rect = c.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                this.stage.width(rect.width);
                this.stage.height(rect.height);
            }
        }).observe(c);

        this.drawGrid();
        return true;
    },

    drawGrid() {
        const layer = this.layers.grid;
        layer.destroyChildren();
        const w = 2000, h = 1500;
        // Light blue minor grid (6 inch)
        for (let x = 0; x < w; x += 6 * INCH) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#dbeafe', strokeWidth: 0.5 }));
        for (let y = 0; y < h; y += 6 * INCH) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#dbeafe', strokeWidth: 0.5 }));
        // Medium blue major grid (1 foot)
        for (let x = 0; x < w; x += FOOT) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#93c5fd', strokeWidth: 0.75 }));
        for (let y = 0; y < h; y += FOOT) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#93c5fd', strokeWidth: 0.75 }));
        layer.batchDraw();
    },

    render(doc, opts = {}) {
        if (!this.stage) return;
        const { showWallIds = true, showDims = true } = opts;

        ['rooms', 'walls', 'hit', 'openings', 'mep', 'labels', 'dims'].forEach(l => this.layers[l].destroyChildren());
        this.wallGroups = {};

        // Room fills and walls (derived from vertices)
        doc.rooms.forEach(r => {
            this.renderRoomFill(r, doc);
            this.renderRoomWalls(r, doc, showWallIds);
        });

        // Closets
        doc.closets.forEach(c => this.renderCloset(c, doc));

        // Doors
        doc.doors.forEach(d => this.renderDoor(d, doc));

        // Windows
        doc.windows.forEach(w => this.renderWindow(w, doc));

        // Cased openings
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));

        // MEP
        doc.mep.forEach(m => this.renderMEP(m, doc));

        // Dimensions
        if (showDims) doc.dimensions.forEach(d => this.renderDimension(d));

        Object.values(this.layers).forEach(l => l.batchDraw());
    },

    renderRoomFill(room, doc) {
        if (!room || !room.vertices || room.vertices.length < 3) return;

        const isSelected = this.selection.type === 'room' && this.selection.id === room.id;
        const self = this;
        const bounds = getVerticesBounds(room.vertices);
        if (!bounds) return;

        // Find closets that belong to this room (hostRoomId) and have valid vertices
        const roomClosets = doc.closets.filter(c => c.hostRoomId === room.id && c.vertices && c.vertices.length >= 3);

        // Create a group for the room (for dragging)
        const roomGroup = new Konva.Group({
            x: 0, y: 0,
            draggable: isSelected
        });

        // Room fill - white/light with subtle border
        const roomFill = '#fafbfc';
        const roomBorder = isSelected ? '#3b82f6' : '#e5e7eb';

        // Draw room polygon with closet cutouts using evenodd fill rule
        const roomShape = new Konva.Shape({
            sceneFunc: (context, shape) => {
                context.beginPath();
                // Outer room polygon (from vertices) - clockwise
                const verts = room.vertices;
                context.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < verts.length; i++) {
                    context.lineTo(verts[i].x, verts[i].y);
                }
                context.closePath();

                // Cut out closet areas (counter-clockwise to create holes)
                roomClosets.forEach(closet => {
                    if (closet.vertices && closet.vertices.length >= 3) {
                        const cv = closet.vertices;
                        // Draw counter-clockwise for cutout
                        context.moveTo(cv[cv.length - 1].x, cv[cv.length - 1].y);
                        for (let i = cv.length - 2; i >= 0; i--) {
                            context.lineTo(cv[i].x, cv[i].y);
                        }
                        context.closePath();
                    }
                });

                // Use evenodd fill rule for proper cutouts
                context.fillStyle = shape.fill();
                context.fill('evenodd');
                context.strokeStyle = shape.stroke();
                context.lineWidth = shape.strokeWidth();
                context.stroke();
            },
            // Hit function for click detection - just the outer polygon
            hitFunc: (context, shape) => {
                context.beginPath();
                const verts = room.vertices;
                context.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < verts.length; i++) {
                    context.lineTo(verts[i].x, verts[i].y);
                }
                context.closePath();
                context.fillStrokeShape(shape);
            },
            fill: roomFill,
            stroke: roomBorder,
            strokeWidth: isSelected ? 2 : 1
        });
        roomGroup.add(roomShape);

        // Add tap handler for room selection
        roomGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onRoomTap(room.id);
        });

        // Add drag handlers for room movement
        if (isSelected) {
            let startVertices = [];
            let startClosetVertices = [];
            let snapPoints = null;

            roomGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                // Store initial vertex positions
                startVertices = room.vertices.map(v => ({ ...v }));
                // Store initial closet vertex positions
                startClosetVertices = roomClosets.map(c => ({
                    id: c.id,
                    vertices: c.vertices ? c.vertices.map(v => ({ ...v })) : []
                }));
                // Get snap points from other rooms
                snapPoints = findRoomSnapPoints(doc, room.id);
            });

            roomGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                // Let Konva handle visual movement smoothly - no re-render during drag
            });

            roomGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                // Calculate final delta from group position
                const dx = this.x();
                const dy = this.y();

                // Apply snapping
                const startBounds = getVerticesBounds(startVertices);
                const rawX = startBounds.x + dx;
                const rawY = startBounds.y + dy;
                const snapped = snapRoomPosition(rawX, rawY, startBounds.width, startBounds.height, snapPoints);
                const actualDx = snapped.x - startBounds.x;
                const actualDy = snapped.y - startBounds.y;

                // Update room vertices
                room.vertices = startVertices.map(v => ({
                    x: v.x + actualDx,
                    y: v.y + actualDy
                }));

                // Update closet vertices
                roomClosets.forEach(closet => {
                    const startData = startClosetVertices.find(p => p.id === closet.id);
                    if (startData && startData.vertices.length > 0) {
                        closet.vertices = startData.vertices.map(v => ({
                            x: v.x + actualDx,
                            y: v.y + actualDy
                        }));
                    }
                });

                // Reset group position
                this.x(0);
                this.y(0);

                // Recalculate exterior walls
                markExteriorWalls(doc);

                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });

            // Add vertex handles when selected
            self.renderVertexHandles(room, doc, roomGroup);
        }

        this.layers.rooms.add(roomGroup);

        // Room label (inside, using bounds)
        this.layers.labels.add(new Konva.Text({
            x: bounds.x, y: bounds.y + bounds.height / 2 - 16, width: bounds.width,
            text: room.label, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: bounds.x, y: bounds.y + bounds.height / 2 + 2, width: bounds.width,
            text: room.type, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
        }));

        // Room dimensions (outside) - L x W format
        const widthFt = Math.round(bounds.width / FOOT);
        const heightFt = Math.round(bounds.height / FOOT);

        // Width dimension (below room)
        this.layers.dims.add(new Konva.Text({
            x: bounds.x, y: bounds.y + bounds.height + 8, width: bounds.width,
            text: `${widthFt}'-0"`, fontSize: 9, fill: '#6b7280', align: 'center', listening: false
        }));

        // Height dimension (right of room, rotated)
        this.layers.dims.add(new Konva.Text({
            x: bounds.x + bounds.width + 12, y: bounds.y + bounds.height / 2 + 15,
            text: `${heightFt}'-0"`, fontSize: 9, fill: '#6b7280', rotation: -90, listening: false
        }));
    },

    // Render vertex handles for room editing
    renderVertexHandles(room, doc, parentGroup) {
        const self = this;

        // Vertex handles (blue circles) - drag to move, double-tap to delete
        room.vertices.forEach((vertex, idx) => {
            const handle = new Konva.Circle({
                x: vertex.x,
                y: vertex.y,
                radius: VERTEX_HANDLE_RADIUS,
                fill: '#3b82f6',
                stroke: '#fff',
                strokeWidth: 2,
                draggable: true
            });

            let startX, startY;

            handle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                startX = vertex.x;
                startY = vertex.y;
            });

            handle.on('dragmove', function(e) {
                e.cancelBubble = true;
                // Snap to grid
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                this.x(newX);
                this.y(newY);
                room.vertices[idx] = { x: newX, y: newY };
            });

            handle.on('dragend', function(e) {
                self.stage.draggable(true);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
                App.updateQABadge();
            });

            // Double-tap to delete vertex (if >3 vertices)
            handle.on('dblclick dbltap', function(e) {
                e.cancelBubble = true;
                if (room.vertices.length > 3) {
                    room.vertices.splice(idx, 1);
                    markExteriorWalls(doc);
                    App.saveState();
                    App.render();
                    App.updateQABadge();
                }
            });

            this.layers.openings.add(handle);
        });

        // Edge midpoint handles (green squares with +) - drag or tap to add vertex
        const n = room.vertices.length;
        for (let i = 0; i < n; i++) {
            const v1 = room.vertices[i];
            const v2 = room.vertices[(i + 1) % n];
            const midX = (v1.x + v2.x) / 2;
            const midY = (v1.y + v2.y) / 2;

            // Green square handle at edge midpoint
            const addHandle = new Konva.Group({
                x: midX,
                y: midY,
                draggable: true
            });

            // Square background
            addHandle.add(new Konva.Rect({
                x: -8,
                y: -8,
                width: 16,
                height: 16,
                fill: '#22c55e',
                stroke: '#fff',
                strokeWidth: 2,
                cornerRadius: 3
            }));

            // Plus sign
            addHandle.add(new Konva.Text({
                x: -5,
                y: -7,
                text: '+',
                fontSize: 14,
                fontStyle: 'bold',
                fill: '#fff'
            }));

            const edgeIdx = i; // Capture for closure
            let isDragging = false;

            addHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                isDragging = true;

                // Insert new vertex at midpoint
                const newVertex = { x: snapToGrid(midX), y: snapToGrid(midY) };
                room.vertices.splice(edgeIdx + 1, 0, newVertex);
            });

            addHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                // Move the newly inserted vertex
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                room.vertices[edgeIdx + 1] = { x: newX, y: newY };
            });

            addHandle.on('dragend', function(e) {
                self.stage.draggable(true);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
                App.updateQABadge();
            });

            // Tap to insert vertex at midpoint
            addHandle.on('tap click', function(e) {
                if (isDragging) {
                    isDragging = false;
                    return;
                }
                e.cancelBubble = true;
                // Insert vertex at midpoint
                const newVertex = { x: snapToGrid(midX), y: snapToGrid(midY) };
                room.vertices.splice(edgeIdx + 1, 0, newVertex);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
                App.updateQABadge();
            });

            this.layers.openings.add(addHandle);
        }
    },

    // Render room wall edges (derived from vertices)
    renderRoomWalls(room, doc, showWallIds) {
        const edges = getWallEdges(room);
        const isRoomSelected = this.selection.type === 'room' && this.selection.id === room.id;

        edges.forEach((edge, edgeIndex) => {
            const isExterior = isEdgeExterior(room, edgeIndex);
            const wallKey = `${room.id}_${edgeIndex}`;
            const isSelected = this.selection.type === 'wall' && this.selection.id === wallKey;

            // Visible wall line
            const wallColor = isSelected ? '#3b82f6' : '#2d3748';
            const wallWidth = isSelected ? 5 : (isExterior ? 4 : 2);
            const visibleLine = new Konva.Line({
                points: [edge.start.x, edge.start.y, edge.end.x, edge.end.y],
                stroke: wallColor,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            });
            this.layers.walls.add(visibleLine);

            // Hit region for wall selection
            const hitLine = new Konva.Line({
                points: [edge.start.x, edge.start.y, edge.end.x, edge.end.y],
                stroke: 'transparent',
                strokeWidth: HIT_WIDTH,
                lineCap: 'round',
                hitStrokeWidth: HIT_WIDTH
            });
            hitLine.on('tap click', () => App.onWallEdgeTap(room.id, edgeIndex));
            this.layers.hit.add(hitLine);

            // Wall ID label
            if (showWallIds) {
                const mid = getEdgeMidpoint(edge);
                const labelOffset = this.getWallLabelOffset(edge, room);
                this.layers.labels.add(new Konva.Text({
                    x: mid.x + labelOffset.x - 8,
                    y: mid.y + labelOffset.y - 5,
                    text: edge.label,
                    fontSize: 9,
                    fill: isSelected ? '#3b82f6' : '#9ca3af',
                    fontStyle: 'bold',
                    listening: false
                }));
            }

            // Edge drag handle (for moving entire edge) - only show when room selected
            if (isRoomSelected) {
                const mid = getEdgeMidpoint(edge);
                const edgeHandle = new Konva.Rect({
                    x: mid.x - EDGE_HANDLE_SIZE / 2,
                    y: mid.y - EDGE_HANDLE_SIZE / 2,
                    width: EDGE_HANDLE_SIZE,
                    height: EDGE_HANDLE_SIZE,
                    fill: '#22c55e',
                    stroke: '#fff',
                    strokeWidth: 1,
                    cornerRadius: 2,
                    draggable: true
                });
                this.setupEdgeDragHandler(edgeHandle, room, edgeIndex, doc);
                this.layers.openings.add(edgeHandle);
            }
        });
    },

    // Setup drag handler for edge movement
    setupEdgeDragHandler(handle, room, edgeIndex, doc) {
        const self = this;
        const edges = getWallEdges(room);
        const edge = edges[edgeIndex];
        const n = room.vertices.length;

        // Find which vertices belong to this edge
        let southIdx = 0;
        let maxMidY = -Infinity;
        for (let i = 0; i < n; i++) {
            const midY = (room.vertices[i].y + room.vertices[(i + 1) % n].y) / 2;
            if (midY > maxMidY) {
                maxMidY = midY;
                southIdx = i;
            }
        }
        const v1Idx = (southIdx + edgeIndex) % n;
        const v2Idx = (v1Idx + 1) % n;

        let startV1, startV2, startHandleX, startHandleY;

        handle.on('dragstart', function(e) {
            e.cancelBubble = true;
            self.stage.draggable(false);
            startV1 = { ...room.vertices[v1Idx] };
            startV2 = { ...room.vertices[v2Idx] };
            startHandleX = this.x();
            startHandleY = this.y();
        });

        handle.on('dragmove', function(e) {
            e.cancelBubble = true;
            const dx = this.x() - startHandleX;
            const dy = this.y() - startHandleY;

            // Determine if edge is horizontal or vertical
            const isHorizontal = Math.abs(edge.start.y - edge.end.y) < 2;
            const isVertical = Math.abs(edge.start.x - edge.end.x) < 2;

            if (isHorizontal) {
                // Move only in Y direction
                const newY = snapToGrid(startV1.y + dy);
                room.vertices[v1Idx] = { x: startV1.x, y: newY };
                room.vertices[v2Idx] = { x: startV2.x, y: newY };
            } else if (isVertical) {
                // Move only in X direction
                const newX = snapToGrid(startV1.x + dx);
                room.vertices[v1Idx] = { x: newX, y: startV1.y };
                room.vertices[v2Idx] = { x: newX, y: startV2.y };
            }
        });

        handle.on('dragend', function(e) {
            self.stage.draggable(true);
            markExteriorWalls(doc);
            App.saveState();
            App.render();
            App.updateQABadge();
        });
    },

    getWallLabelOffset(edge, room) {
        const bounds = getVerticesBounds(room.vertices);
        const mid = getEdgeMidpoint(edge);
        const cx = bounds.x + bounds.width / 2;
        const cy = bounds.y + bounds.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: -(dx / dist) * 14, y: -(dy / dist) * 10 };
    },

    // Legacy function - redirect to new edge-based approach
    renderWallSegment(ws, doc, showWallIds) {
        // This function is now deprecated - walls are rendered from room vertices
        // Keep for backwards compatibility during transition
        const room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) return;

        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const isExterior = ws.type === 'exterior';

        // Wall group
        const group = new Konva.Group({ id: ws.id });
        this.wallGroups[ws.id] = group;

        // Visible wall line - dark grey, exterior walls thicker
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = isSelected ? 5 : (isExterior ? 4 : 2);
        const visibleLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: wallColor,
            strokeWidth: wallWidth,
            lineCap: 'round',
            listening: false
        });
        group.add(visibleLine);

        // HIT REGION (invisible, wide stroke for mobile tapping)
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        hitLine.on('pointerdown', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);

        // Wall ID label
        if (showWallIds) {
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        }

        this.layers.walls.add(group);
    },

    getLabelOffset(ws, room) {
        if (!room || !room.vertices) return { x: 0, y: 0 };
        const bounds = getVerticesBounds(room.vertices);
        const mid = getSegmentMidpoint(ws);
        const cx = bounds.x + bounds.width / 2;
        const cy = bounds.y + bounds.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: -(dx / dist) * 14, y: -(dy / dist) * 10 };
    },

    renderCloset(closet, doc) {
        if (!closet || !closet.vertices || closet.vertices.length < 3) return;

        const bounds = getVerticesBounds(closet.vertices);
        if (!bounds) return;

        const isSelected = this.selection.type === 'closet' && this.selection.id === closet.id;
        const hostRoom = doc.rooms.find(r => r.id === closet.hostRoomId);
        const hostBounds = hostRoom && hostRoom.vertices ? getVerticesBounds(hostRoom.vertices) : null;
        const self = this;

        // Create closet group for dragging
        const closetGroup = new Konva.Group({
            x: 0, y: 0,
            draggable: isSelected
        });

        // Closet fill with light grey (polygon)
        const closetShape = new Konva.Shape({
            sceneFunc: (context, shape) => {
                context.beginPath();
                const verts = closet.vertices;
                context.moveTo(verts[0].x, verts[0].y);
                for (let i = 1; i < verts.length; i++) {
                    context.lineTo(verts[i].x, verts[i].y);
                }
                context.closePath();
                context.fillStrokeShape(shape);
            },
            fill: '#f3f4f6',
            stroke: isSelected ? '#3b82f6' : '#d1d5db',
            strokeWidth: isSelected ? 2 : 1
        });
        closetGroup.add(closetShape);

        // Add drag handlers when selected
        if (isSelected) {
            let startVertices = [];

            closetGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                startVertices = closet.vertices.map(v => ({ ...v }));
            });

            closetGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                // Let Konva handle visual movement smoothly - no re-render during drag
            });

            closetGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                // Calculate final delta and apply snapping
                const dx = this.x();
                const dy = this.y();

                // Update closet vertices with snapping
                closet.vertices = startVertices.map(v => ({
                    x: snapToGrid(v.x + dx),
                    y: snapToGrid(v.y + dy)
                }));

                // Reset group position
                this.x(0);
                this.y(0);

                // Check if closet is now inside a different room
                const newBounds = getVerticesBounds(closet.vertices);
                const closetCenterX = newBounds.x + newBounds.width / 2;
                const closetCenterY = newBounds.y + newBounds.height / 2;

                const newHostRoom = doc.rooms.find(room => {
                    const roomBounds = getVerticesBounds(room.vertices);
                    return closetCenterX >= roomBounds.x && closetCenterX <= roomBounds.x + roomBounds.width &&
                           closetCenterY >= roomBounds.y && closetCenterY <= roomBounds.y + roomBounds.height;
                });

                // Update parent if changed
                if (newHostRoom && newHostRoom.id !== closet.hostRoomId) {
                    const oldHost = doc.rooms.find(r => r.id === closet.hostRoomId);
                    const oldName = oldHost ? oldHost.label : 'none';
                    if (confirm(`Move ${closet.label} from ${oldName} to ${newHostRoom.label}?`)) {
                        closet.hostRoomId = newHostRoom.id;
                    }
                } else if (!newHostRoom && closet.hostRoomId) {
                    // Closet moved outside all rooms
                    const oldHost = doc.rooms.find(r => r.id === closet.hostRoomId);
                    if (confirm(`${closet.label} is outside all rooms. Remove parent link to ${oldHost?.label}?`)) {
                        closet.hostRoomId = null;
                    }
                } else if (newHostRoom && !closet.hostRoomId) {
                    // Closet was unlinked, now inside a room
                    if (confirm(`Link ${closet.label} to ${newHostRoom.label}?`)) {
                        closet.hostRoomId = newHostRoom.id;
                    }
                }

                App.saveState();
                App.render();
                App.updateTree();
                App.updateQABadge();
            });
        }

        closetGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onObjectTap('closet', closet.id);
        });
        this.layers.openings.add(closetGroup);

        // Diagonal hatch lines (architectural convention for closets)
        const hatchGroup = new Konva.Group({ clip: { x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height } });
        const spacing = 12;
        const hatchColor = '#d1d5db';
        for (let i = -bounds.height; i < bounds.width + bounds.height; i += spacing) {
            hatchGroup.add(new Konva.Line({
                points: [bounds.x + i, bounds.y, bounds.x + i + bounds.height, bounds.y + bounds.height],
                stroke: hatchColor, strokeWidth: 1, listening: false
            }));
        }
        this.layers.openings.add(hatchGroup);

        // Draw only interior-facing walls (walls that don't touch host room edges)
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = 2;
        const tolerance = 2;

        if (hostBounds) {
            const closetEdges = getWallEdges(closet);
            closetEdges.forEach(edge => {
                const midY = (edge.start.y + edge.end.y) / 2;
                const midX = (edge.start.x + edge.end.x) / 2;
                const isHorizontal = Math.abs(edge.start.y - edge.end.y) < tolerance;
                const isVertical = Math.abs(edge.start.x - edge.end.x) < tolerance;

                let touchesHostEdge = false;
                if (isHorizontal) {
                    if (Math.abs(midY - hostBounds.y) < tolerance || Math.abs(midY - (hostBounds.y + hostBounds.height)) < tolerance) {
                        touchesHostEdge = true;
                    }
                }
                if (isVertical) {
                    if (Math.abs(midX - hostBounds.x) < tolerance || Math.abs(midX - (hostBounds.x + hostBounds.width)) < tolerance) {
                        touchesHostEdge = true;
                    }
                }

                // Only draw if doesn't touch host room edge
                if (!touchesHostEdge) {
                    this.layers.walls.add(new Konva.Line({
                        points: [edge.start.x, edge.start.y, edge.end.x, edge.end.y],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            });
        }

        // Closet label with parent room indicator
        const parentLabel = hostRoom ? ` (${hostRoom.label})` : ' (unlinked)';
        const labelColor = isSelected ? '#3b82f6' : (hostRoom ? '#6b7280' : '#ef4444');

        this.layers.labels.add(new Konva.Text({
            x: bounds.x, y: bounds.y + bounds.height / 2 - 12, width: bounds.width,
            text: closet.label, fontSize: 10, fontStyle: 'bold', fill: labelColor, align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: bounds.x, y: bounds.y + bounds.height / 2 + 1, width: bounds.width,
            text: hostRoom ? `→ ${hostRoom.label}` : '⚠ no parent', fontSize: 8, fill: labelColor, align: 'center', listening: false
        }));

        // Show connection line to parent room when selected
        if (isSelected && hostRoom && hostBounds) {
            const closetCenter = { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height / 2 };
            const roomCenter = { x: hostBounds.x + hostBounds.width / 2, y: hostBounds.y + hostBounds.height / 2 };
            this.layers.dims.add(new Konva.Line({
                points: [closetCenter.x, closetCenter.y, roomCenter.x, roomCenter.y],
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [5, 5],
                opacity: 0.5,
                listening: false
            }));
            // Highlight parent room
            this.layers.dims.add(new Konva.Rect({
                x: hostBounds.x - 3,
                y: hostBounds.y - 3,
                width: hostBounds.width + 6,
                height: hostBounds.height + 6,
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [8, 4],
                fill: 'transparent',
                listening: false
            }));
        }
    },

    renderDoor(door, doc) {
        // Get the parent room or closet and edge
        let room = doc.rooms.find(r => r.id === door.parentRoomId);
        if (!room) {
            // Check if parent is a closet
            room = doc.closets.find(c => c.id === door.parentRoomId);
        }
        if (!room || !room.vertices) return;

        const edges = getWallEdges(room);
        const edge = edges[door.parentWallEdgeIndex];
        if (!edge) return;

        // Calculate position from tAlongEdge
        const pos = getPositionOnEdge(edge, door.tAlongEdge);
        const angle = getEdgeAngle(edge);
        const isVertical = Math.abs(Math.sin(angle)) > 0.5;
        const isSelected = this.selection.type === 'door' && this.selection.id === door.id;
        const isExterior = isEdgeExterior(room, door.parentWallEdgeIndex);

        // Wall thickness based on exterior/interior
        const wallThickness = isExterior ? WALL_EXT : WALL_INT;
        const edgeLength = getEdgeLength(edge);

        const doorGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected
        });

        // Door opening (gap in wall) - match room fill color
        const doorRect = new Konva.Rect({
            x: 0, y: -3,
            width: door.width,
            height: 6,
            fill: '#fafbfc',
            stroke: 'transparent'
        });
        doorGroup.add(doorRect);

        // Door jambs (thin lines at edges of opening)
        const jambColor = '#2d3748';
        doorGroup.add(new Konva.Line({
            points: [0, -3, 0, 3],
            stroke: jambColor, strokeWidth: 1
        }));
        doorGroup.add(new Konva.Line({
            points: [door.width, -3, door.width, 3],
            stroke: jambColor, strokeWidth: 1
        }));

        // Door geometry - hinge point and swing direction
        const swingOut = door.swing === 'out' ? -1 : 1;
        const hingeLeft = door.swingDir === 'left';

        // Hinge position
        const hingeX = hingeLeft ? 0 : door.width;
        const hingeY = swingOut * wallThickness / 2;

        // Door leaf length
        const leafLength = door.width * 0.9;
        const leafEndX = hingeX;
        const leafEndY = hingeY + swingOut * leafLength;

        // Swing arc
        const swingArc = new Konva.Arc({
            x: hingeX,
            y: hingeY,
            innerRadius: leafLength - 1,
            outerRadius: leafLength,
            angle: 90,
            rotation: hingeLeft ? (swingOut > 0 ? 0 : -90) : (swingOut > 0 ? 90 : 180),
            stroke: '#9ca3af',
            strokeWidth: 1,
            dash: [4, 3]
        });
        doorGroup.add(swingArc);

        // Door leaf
        const doorLeaf = new Konva.Line({
            points: [hingeX, hingeY, leafEndX, leafEndY],
            stroke: isSelected ? '#3b82f6' : '#2d3748',
            strokeWidth: 3,
            lineCap: 'round'
        });
        doorGroup.add(doorLeaf);

        // Hit area
        const hitArea = new Konva.Rect({
            x: -5,
            y: Math.min(hingeY, leafEndY) - 5,
            width: door.width + 10,
            height: Math.abs(leafEndY - hingeY) + 15,
            fill: 'transparent',
            stroke: 'transparent'
        });
        doorGroup.add(hitArea);

        doorGroup.on('tap click', () => App.onObjectTap('door', door.id));
        this.layers.openings.add(doorGroup);

        // Label
        const doorLabel = new Konva.Text({
            x: pos.x + (isVertical ? 12 : 0), y: pos.y + (isVertical ? 0 : -14),
            text: door.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#6b7280', listening: false
        });
        this.layers.labels.add(doorLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;
            const self = this;

            // Calculate right position using tAlongEdge + width
            const widthAsT = door.width / edgeLength;
            const rightT = Math.min(1, door.tAlongEdge + widthAsT);
            const rightPos = getPositionOnEdge(edge, rightT);

            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Drag-to-move the entire door along wall
            doorGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            doorGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newT = getTOnEdge(edge, pointer.x, pointer.y);
                const maxT = 1 - (door.width / edgeLength);

                // Constrain to wall bounds
                const clampedT = Math.max(0, Math.min(newT, maxT));
                door.tAlongEdge = clampedT;

                // Update position
                const newPos = getPositionOnEdge(edge, clampedT);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightT = Math.min(1, clampedT + door.width / edgeLength);
                const newRightPos = getPositionOnEdge(edge, newRightT);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            doorGroup.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newT = getTOnEdge(edge, pointer.x, pointer.y);
                const oldEndT = door.tAlongEdge + door.width / edgeLength;
                const minWidthT = (0.5 * FOOT) / edgeLength;

                if (newT >= 0 && (oldEndT - newT) >= minWidthT) {
                    door.width = (oldEndT - newT) * edgeLength;
                    door.tAlongEdge = newT;

                    // Update door group
                    const newPos = getPositionOnEdge(edge, newT);
                    doorGroup.x(newPos.x);
                    doorGroup.y(newPos.y);
                    doorRect.width(door.width);

                    // Update handles
                    leftHandle.x(newPos.x);
                    leftHandle.y(newPos.y);
                }
                const handlePos = getPositionOnEdge(edge, door.tAlongEdge);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEndT = getTOnEdge(edge, pointer.x, pointer.y);
                const newWidthT = newEndT - door.tAlongEdge;
                const minWidthT = (0.5 * FOOT) / edgeLength;

                if (newWidthT >= minWidthT && newEndT <= 1) {
                    door.width = newWidthT * edgeLength;

                    // Update door visuals
                    doorRect.width(door.width);
                }
                const handlePos = getPositionOnEdge(edge, door.tAlongEdge + door.width / edgeLength);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderWindow(win, doc) {
        // Get the parent room and edge
        const room = doc.rooms.find(r => r.id === win.parentRoomId);
        if (!room) return;

        const edges = getWallEdges(room);
        const edge = edges[win.parentWallEdgeIndex];
        if (!edge) return;

        // Calculate position from tAlongEdge
        const pos = getPositionOnEdge(edge, win.tAlongEdge);
        const angle = getEdgeAngle(edge);
        const isSelected = this.selection.type === 'window' && this.selection.id === win.id;
        const edgeLength = getEdgeLength(edge);

        const winGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected
        });

        // Window opening
        const winThickness = 8;
        const winRect = new Konva.Rect({
            x: 0, y: -winThickness / 2,
            width: win.width, height: winThickness,
            fill: '#fafbfc',
            stroke: 'transparent'
        });
        winGroup.add(winRect);

        // Window frame lines
        const frameColor = isSelected ? '#3b82f6' : '#60a5fa';
        const topSill = new Konva.Line({
            points: [0, -winThickness / 2, win.width, -winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(topSill);

        const bottomSill = new Konva.Line({
            points: [0, winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(bottomSill);

        const leftJamb = new Konva.Line({
            points: [0, -winThickness / 2, 0, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(leftJamb);

        const rightJamb = new Konva.Line({
            points: [win.width, -winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(rightJamb);

        const mullion = new Konva.Line({
            points: [win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2],
            stroke: frameColor, strokeWidth: 1
        });
        winGroup.add(mullion);

        winGroup.on('tap click', () => App.onObjectTap('window', win.id));
        this.layers.openings.add(winGroup);

        const winLabel = new Konva.Text({
            x: pos.x + win.width / 2 - 15, y: pos.y - 14,
            text: win.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#60a5fa', listening: false
        });
        this.layers.labels.add(winLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;
            const self = this;

            // Calculate right position
            const widthAsT = win.width / edgeLength;
            const rightT = Math.min(1, win.tAlongEdge + widthAsT);
            const rightPos = getPositionOnEdge(edge, rightT);

            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Drag-to-move the entire window along wall
            winGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            winGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newT = getTOnEdge(edge, pointer.x, pointer.y);
                const maxT = 1 - (win.width / edgeLength);

                // Constrain to wall bounds
                const clampedT = Math.max(0, Math.min(newT, maxT));
                win.tAlongEdge = clampedT;

                // Update position
                const newPos = getPositionOnEdge(edge, clampedT);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightT = Math.min(1, clampedT + win.width / edgeLength);
                const newRightPos = getPositionOnEdge(edge, newRightT);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            winGroup.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newT = getTOnEdge(edge, pointer.x, pointer.y);
                const oldEndT = win.tAlongEdge + win.width / edgeLength;
                const minWidthT = (1 * FOOT) / edgeLength;

                if (newT >= 0 && (oldEndT - newT) >= minWidthT) {
                    win.width = (oldEndT - newT) * edgeLength;
                    win.tAlongEdge = newT;

                    // Update visuals
                    const newPos = getPositionOnEdge(edge, newT);
                    winGroup.x(newPos.x);
                    winGroup.y(newPos.y);
                    winRect.width(win.width);
                    topSill.points([0, -winThickness / 2, win.width, -winThickness / 2]);
                    bottomSill.points([0, winThickness / 2, win.width, winThickness / 2]);
                    rightJamb.points([win.width, -winThickness / 2, win.width, winThickness / 2]);
                    mullion.points([win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2]);
                    leftHandle.x(newPos.x);
                    leftHandle.y(newPos.y);
                }
                const handlePos = getPositionOnEdge(edge, win.tAlongEdge);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEndT = getTOnEdge(edge, pointer.x, pointer.y);
                const newWidthT = newEndT - win.tAlongEdge;
                const minWidthT = (1 * FOOT) / edgeLength;

                if (newWidthT >= minWidthT && newEndT <= 1) {
                    win.width = newWidthT * edgeLength;
                    winRect.width(win.width);
                    topSill.points([0, -winThickness / 2, win.width, -winThickness / 2]);
                    bottomSill.points([0, winThickness / 2, win.width, winThickness / 2]);
                    rightJamb.points([win.width, -winThickness / 2, win.width, winThickness / 2]);
                    mullion.points([win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2]);
                }
                const handlePos = getPositionOnEdge(edge, win.tAlongEdge + win.width / edgeLength);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderCasedOpening(op, doc) {
        // Get the parent room and edge
        const room = doc.rooms.find(r => r.id === op.parentRoomId);
        if (!room) return;

        const edges = getWallEdges(room);
        const edge = edges[op.parentWallEdgeIndex];
        if (!edge) return;

        const pos = getPositionOnEdge(edge, op.tAlongEdge);
        const angle = getEdgeAngle(edge);
        const isSelected = this.selection.type === 'cased' && this.selection.id === op.id;

        const opGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        opGroup.add(new Konva.Line({
            points: [0, 0, op.width, 0],
            stroke: isSelected ? '#06b6d4' : '#aaa', strokeWidth: 2, dash: [6, 3]
        }));

        opGroup.on('tap click', () => App.onObjectTap('cased', op.id));
        this.layers.openings.add(opGroup);

        this.layers.labels.add(new Konva.Text({
            x: pos.x + op.width / 2 - 10, y: pos.y - 12,
            text: op.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#aaa', listening: false
        }));
    },

    renderMEP(mep, doc) {
        // Get the parent room and edge
        const room = doc.rooms.find(r => r.id === mep.parentRoomId);
        if (!room) return;

        const edges = getWallEdges(room);
        const edge = edges[mep.parentWallEdgeIndex];
        if (!edge) return;

        const pos = getPositionOnEdge(edge, mep.tAlongEdge);
        const isSelected = this.selection.type === 'mep' && this.selection.id === mep.id;
        const color = isSelected ? '#3b82f6' : (mep.label.startsWith('GAS') ? '#f97316' : mep.label.startsWith('POE') ? '#ef4444' : '#22c55e');

        if (mep.label.startsWith('PIPE')) {
            const shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, stroke: color, strokeWidth: 2, fill: '#fff' });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('GAS')) {
            const shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, fill: color });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('POE')) {
            const shape = new Konva.RegularPolygon({ x: pos.x, y: pos.y, sides: 3, radius: 12, fill: color, rotation: 0 });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('RAD')) {
            // Render radiator with fins
            const offset = this.getInteriorOffsetForEdge(edge, room);
            const radX = pos.x + offset.x * 0.5;
            const radY = pos.y + offset.y * 0.5 - mep.height / 2;
            const radGroup = new Konva.Group();

            radGroup.add(new Konva.Rect({
                x: radX, y: radY, width: mep.width, height: mep.height,
                fill: '#f9fafb', stroke: color, strokeWidth: 2, cornerRadius: 3
            }));

            const finCount = Math.max(3, Math.floor(mep.width / 12));
            const finSpacing = mep.width / (finCount + 1);
            const finPadding = 4;
            for (let i = 1; i <= finCount; i++) {
                radGroup.add(new Konva.Line({
                    points: [radX + i * finSpacing, radY + finPadding, radX + i * finSpacing, radY + mep.height - finPadding],
                    stroke: color, strokeWidth: 1.5, opacity: 0.7
                }));
            }

            // Top and bottom horizontal pipes
            radGroup.add(new Konva.Line({
                points: [radX + 4, radY + 6, radX + mep.width - 4, radY + 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));
            radGroup.add(new Konva.Line({
                points: [radX + 4, radY + mep.height - 6, radX + mep.width - 4, radY + mep.height - 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));

            radGroup.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(radGroup);
        } else if (mep.label.startsWith('PRSR')) {
            // Pipe Riser - concentric circles to show vertical pipe
            const offset = this.getInteriorOffsetForEdge(edge, room);
            const riserX = pos.x + offset.x * 0.3;
            const riserY = pos.y + offset.y * 0.3;
            const riserGroup = new Konva.Group();

            riserGroup.add(new Konva.Circle({
                x: riserX, y: riserY, radius: 12,
                fill: '#f3f4f6', stroke: color, strokeWidth: 2
            }));
            riserGroup.add(new Konva.Circle({
                x: riserX, y: riserY, radius: 6,
                fill: '#e5e7eb', stroke: color, strokeWidth: 1
            }));

            riserGroup.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(riserGroup);
        }

        this.layers.labels.add(new Konva.Text({
            x: pos.x + 14, y: pos.y - 5,
            text: mep.label, fontSize: 8, fill: color, listening: false
        }));
    },

    // Legacy function for backwards compatibility
    getPositionOnSegment(seg, distFromStart) {
        if (seg.start && seg.end) {
            const len = getEdgeLength(seg);
            const t = len > 0 ? Math.min(distFromStart / len, 1) : 0;
            return getPositionOnEdge(seg, t);
        }
        const len = getSegmentLength(seg);
        const t = Math.min(distFromStart / len, 1);
        return {
            x: seg.x1 + t * (seg.x2 - seg.x1),
            y: seg.y1 + t * (seg.y2 - seg.y1)
        };
    },

    getOffsetOnSegment(seg, px, py) {
        if (seg.start && seg.end) {
            return getTOnEdge(seg, px, py) * getEdgeLength(seg);
        }
        const dx = seg.x2 - seg.x1;
        const dy = seg.y2 - seg.y1;
        const len = getSegmentLength(seg);
        if (len === 0) return 0;
        const t = Math.max(0, Math.min(1, ((px - seg.x1) * dx + (py - seg.y1) * dy) / (len * len)));
        return t * len;
    },

    getInteriorOffset(ws, doc) {
        const room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room || !room.vertices) return { x: 0, y: 0 };
        const bounds = getVerticesBounds(room.vertices);
        const mid = getSegmentMidpoint(ws);
        const cx = bounds.x + bounds.width / 2;
        const cy = bounds.y + bounds.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    // Interior offset for edge-based model
    getInteriorOffsetForEdge(edge, room) {
        if (!room || !room.vertices) return { x: 0, y: 0 };
        const bounds = getVerticesBounds(room.vertices);
        const mid = getEdgeMidpoint(edge);
        const cx = bounds.x + bounds.width / 2;
        const cy = bounds.y + bounds.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    renderDimension(dim) {
        const layer = this.layers.dims;
        const isVert = dim.vertical;
        layer.add(new Konva.Line({ points: [dim.x1, dim.y1, dim.x2, dim.y2], stroke: '#555', strokeWidth: 1 }));
        if (isVert) {
            layer.add(new Konva.Line({ points: [dim.x1 - 4, dim.y1, dim.x1 + 4, dim.y1], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2 - 4, dim.y2, dim.x2 + 4, dim.y2], stroke: '#555', strokeWidth: 1 }));
        } else {
            layer.add(new Konva.Line({ points: [dim.x1, dim.y1 - 4, dim.x1, dim.y1 + 4], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2, dim.y2 - 4, dim.x2, dim.y2 + 4], stroke: '#555', strokeWidth: 1 }));
        }
        const midX = (dim.x1 + dim.x2) / 2, midY = (dim.y1 + dim.y2) / 2;
        layer.add(new Konva.Text({
            x: isVert ? midX - 28 : midX - 18, y: isVert ? midY - 5 : midY - 12,
            text: dim.label, fontSize: 9, fill: '#777', listening: false
        }));
    },

    select(type, id) {
        this.selection = { type, id };
    },

    deselect() {
        this.selection = { type: null, id: null };
    },

    getImage() { return this.stage ? this.stage.toDataURL({ pixelRatio: 2 }) : null; }
};

// ========== QA VALIDATION ==========
function runQA(doc) {
    const results = [];

    // All rooms labeled
    results.push({ rule: 'All rooms labeled', pass: doc.rooms.every(r => r.label), detail: 'OK' });

    // All rooms have valid vertices
    const badRooms = doc.rooms.filter(r => !r.vertices || r.vertices.length < 3);
    results.push({ rule: 'Room vertices valid', pass: badRooms.length === 0, detail: badRooms.length > 0 ? `${badRooms.length} invalid` : 'OK' });

    // All rooms have W1 (derived from vertices - south-most edge)
    const roomsWithEdges = doc.rooms.filter(r => r.vertices && r.vertices.length >= 3);
    const roomsWithW1 = roomsWithEdges.filter(r => {
        const edges = getWallEdges(r);
        return edges.length > 0 && edges[0].label === 'W1';
    });
    results.push({ rule: 'Wall IDs (W1 exists)', pass: roomsWithW1.length === roomsWithEdges.length, detail: 'OK' });

    // Closets with valid host rooms
    const closetsWithValidHost = doc.closets.filter(c => {
        if (!c.hostRoomId) return false;
        return doc.rooms.some(r => r.id === c.hostRoomId);
    });
    const unlinkedClosets = doc.closets.length - closetsWithValidHost.length;
    results.push({
        rule: 'Closets linked to rooms',
        pass: unlinkedClosets === 0,
        detail: unlinkedClosets > 0 ? `${unlinkedClosets} unlinked` : `${doc.closets.length} closets`
    });

    // Doors attached to rooms (using parentRoomId + parentWallEdgeIndex)
    const unattachedDoors = doc.doors.filter(d => {
        if (!d.parentRoomId) return true;
        const room = doc.rooms.find(r => r.id === d.parentRoomId);
        if (!room || !room.vertices) return true;
        const edgeCount = room.vertices.length;
        return d.parentWallEdgeIndex === undefined || d.parentWallEdgeIndex >= edgeCount;
    });
    results.push({ rule: 'Doors attached to walls', pass: unattachedDoors.length === 0, detail: unattachedDoors.length > 0 ? `${unattachedDoors.length} floating` : 'OK' });

    // Windows attached to rooms
    const unattachedWindows = doc.windows.filter(w => {
        if (!w.parentRoomId) return true;
        const room = doc.rooms.find(r => r.id === w.parentRoomId);
        if (!room || !room.vertices) return true;
        const edgeCount = room.vertices.length;
        return w.parentWallEdgeIndex === undefined || w.parentWallEdgeIndex >= edgeCount;
    });
    results.push({ rule: 'Windows attached to walls', pass: unattachedWindows.length === 0, detail: unattachedWindows.length > 0 ? `${unattachedWindows.length} floating` : 'OK' });

    // Windows must be on exterior walls only
    const windowsOnInterior = doc.windows.filter(w => {
        const room = doc.rooms.find(r => r.id === w.parentRoomId);
        if (!room) return false;
        return !isEdgeExterior(room, w.parentWallEdgeIndex);
    });
    results.push({ rule: 'Windows on exterior walls', pass: windowsOnInterior.length === 0, detail: windowsOnInterior.length > 0 ? `${windowsOnInterior.length} on interior` : 'OK' });

    // MEP attached (except free-placed)
    const unattachedMEP = doc.mep.filter(m => {
        if (m.freePlaced) return false;
        if (!m.parentRoomId) return true;
        const room = doc.rooms.find(r => r.id === m.parentRoomId);
        return !room;
    });
    results.push({ rule: 'MEP attached to walls', pass: unattachedMEP.length === 0, detail: unattachedMEP.length > 0 ? `${unattachedMEP.length} floating` : 'OK' });

    // POE anchored
    const poe = doc.mep.find(m => m.label.startsWith('POE'));
    const entryDoor = doc.doors.find(d => d.type === 'entry');
    results.push({ rule: 'POE anchored to entry', pass: poe && poe.anchorDoorId === entryDoor?.id, detail: poe ? 'OK' : 'Missing' });

    // Dimensions
    results.push({ rule: 'Dimensions present', pass: doc.dimensions.length > 0, detail: `${doc.dimensions.length}` });

    return results;
}

// ========== APP ==========
const App = {
    doc: null,
    currentTool: 'select',
    showGrid: true,
    showWallIds: true,
    showDims: true,
    undoStack: [],
    redoStack: [],
    maxHistory: 50,
    isDrawingRoom: false,
    roomDrawStart: null,
    roomPreview: null,
    isDrawingWall: false,
    wallDrawStart: null,
    wallPreview: null,

    init() {
        if (!Render.init('stage')) { alert('Init failed'); return; }
        this.doc = generate2BR1BA();
        this.saveState(); // Save initial state
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateUndoRedoButtons();
        this.setupKeyboardShortcuts();
        this.setupRoomDrawing();
        this.setupWallDrawing();
        console.log('App ready - tap walls to select');
    },

    setupRoomDrawing() {
        const stage = Render.stage;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'room') return;

            // Disable stage panning while drawing
            stage.draggable(false);

            const pos = stage.getPointerPosition();
            this.isDrawingRoom = true;
            this.roomDrawStart = { x: pos.x, y: pos.y };

            // Create preview rectangle
            this.roomPreview = new Konva.Rect({
                x: pos.x,
                y: pos.y,
                width: 0,
                height: 0,
                fill: 'rgba(59, 130, 246, 0.1)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [5, 5]
            });
            Render.layers.openings.add(this.roomPreview);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.roomDrawStart;

            // Calculate dimensions
            const x = Math.min(start.x, pos.x);
            const y = Math.min(start.y, pos.y);
            const width = Math.abs(pos.x - start.x);
            const height = Math.abs(pos.y - start.y);

            this.roomPreview.x(x);
            this.roomPreview.y(y);
            this.roomPreview.width(width);
            this.roomPreview.height(height);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.roomDrawStart;

            // Calculate final dimensions
            const x = Math.min(start.x, pos.x);
            const y = Math.min(start.y, pos.y);
            const width = Math.abs(pos.x - start.x);
            const height = Math.abs(pos.y - start.y);

            // Remove preview
            this.roomPreview.destroy();
            this.roomPreview = null;
            this.isDrawingRoom = false;
            stage.draggable(true);

            // Minimum size check (at least 2' x 2')
            if (width < 2 * FOOT || height < 2 * FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Check if drawing is inside an existing room (create closet) or outside (create room)
            const parentRoom = this.doc.rooms.find(room => {
                // Use vertices bounds instead of geometry
                const bounds = getVerticesBounds(room.vertices);
                // Check if the drawn rectangle is mostly inside this room
                const overlapX = Math.max(0, Math.min(x + width, bounds.x + bounds.width) - Math.max(x, bounds.x));
                const overlapY = Math.max(0, Math.min(y + height, bounds.y + bounds.height) - Math.max(y, bounds.y));
                const overlapArea = overlapX * overlapY;
                const drawnArea = width * height;
                return overlapArea > drawnArea * 0.5; // More than 50% inside room
            });

            const geometry = { x, y, width, height };

            if (parentRoom) {
                // Create a closet inside the room (with vertices and hostRoomId)
                const closet = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'closet'),
                    type: 'Closet',
                    hostRoomId: parentRoom.id,
                    isExterior: false,
                    vertices: geometryToVertices(geometry)
                };
                this.doc.closets.push(closet);
                Render.select('closet', closet.id);
            } else {
                // Create a new room (with vertices, no wallSegments)
                if (width < 4 * FOOT || height < 4 * FOOT) {
                    // Room needs to be at least 4x4
                    Render.layers.openings.batchDraw();
                    return;
                }
                const room = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'room'),
                    type: 'Room',
                    isExterior: true,
                    vertices: geometryToVertices(geometry)
                };
                this.doc.rooms.push(room);
                markExteriorWalls(this.doc);
            }

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            this.updateInspector();
            this.setTool('select');
        });
    },

    setupWallDrawing() {
        const stage = Render.stage;
        let snapPoints = [];
        let snapIndicators = [];

        // Show snap point indicators when wall tool is active
        const showSnapPoints = () => {
            clearSnapIndicators();
            snapPoints = findWallSnapPoints(this.doc);
            snapPoints.forEach(pt => {
                const indicator = new Konva.Circle({
                    x: pt.x, y: pt.y,
                    radius: 8,
                    fill: 'transparent',
                    stroke: '#3b82f6',
                    strokeWidth: 2,
                    dash: [3, 3],
                    opacity: 0.6
                });
                Render.layers.openings.add(indicator);
                snapIndicators.push(indicator);
            });
            Render.layers.openings.batchDraw();
        };

        const clearSnapIndicators = () => {
            snapIndicators.forEach(ind => ind.destroy());
            snapIndicators = [];
        };

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'wall') return;

            stage.draggable(false);
            showSnapPoints();

            const pos = stage.getPointerPosition();
            // Snap start point to corners or grid
            const snapped = snapWallPoint(pos.x, pos.y, snapPoints);

            this.isDrawingWall = true;
            this.wallDrawStart = { x: snapped.x, y: snapped.y, snapped: snapped.snapped };

            // Create preview line
            this.wallPreview = new Konva.Line({
                points: [snapped.x, snapped.y, snapped.x, snapped.y],
                stroke: '#2d3748',
                strokeWidth: 4,
                lineCap: 'round',
                dash: [8, 4]
            });
            Render.layers.openings.add(this.wallPreview);

            // Add start point indicator (green if snapped, blue if grid)
            this.wallStartPoint = new Konva.Circle({
                x: snapped.x,
                y: snapped.y,
                radius: snapped.snapped ? 8 : 6,
                fill: snapped.snapped ? '#22c55e' : '#3b82f6',
                stroke: '#fff',
                strokeWidth: 2
            });
            Render.layers.openings.add(this.wallStartPoint);

            // End point indicator
            this.wallEndPoint = new Konva.Circle({
                x: snapped.x, y: snapped.y,
                radius: 6,
                fill: '#3b82f6',
                stroke: '#fff',
                strokeWidth: 2
            });
            Render.layers.openings.add(this.wallEndPoint);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.wallDrawStart;

            // Snap end point to corners or grid
            let snapped = snapWallPoint(pos.x, pos.y, snapPoints);
            let endX = snapped.x;
            let endY = snapped.y;

            // If not snapped to a corner, constrain to horizontal or vertical
            if (!snapped.snapped) {
                const dx = Math.abs(endX - start.x);
                const dy = Math.abs(endY - start.y);
                if (dx > dy) {
                    endY = start.y; // Horizontal line
                } else {
                    endX = start.x; // Vertical line
                }
            }

            this.wallPreview.points([start.x, start.y, endX, endY]);

            // Update end point indicator
            if (this.wallEndPoint) {
                this.wallEndPoint.x(endX);
                this.wallEndPoint.y(endY);
                this.wallEndPoint.radius(snapped.snapped ? 8 : 6);
                this.wallEndPoint.fill(snapped.snapped ? '#22c55e' : '#3b82f6');
            }

            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.wallDrawStart;

            // Snap end point
            let snapped = snapWallPoint(pos.x, pos.y, snapPoints);
            let endX = snapped.x;
            let endY = snapped.y;

            // If not snapped, constrain to horizontal or vertical
            if (!snapped.snapped) {
                const dx = Math.abs(endX - start.x);
                const dy = Math.abs(endY - start.y);
                if (dx > dy) {
                    endY = start.y;
                } else {
                    endX = start.x;
                }
            }

            // Remove preview elements
            this.wallPreview.destroy();
            this.wallPreview = null;
            if (this.wallStartPoint) {
                this.wallStartPoint.destroy();
                this.wallStartPoint = null;
            }
            if (this.wallEndPoint) {
                this.wallEndPoint.destroy();
                this.wallEndPoint = null;
            }
            clearSnapIndicators();
            this.isDrawingWall = false;
            stage.draggable(true);

            // Minimum length check (at least 1 foot)
            const length = Math.sqrt(Math.pow(endX - start.x, 2) + Math.pow(endY - start.y, 2));
            if (length < FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // In the room-first model, standalone walls are not supported
            // Walls are derived from room polygon vertices
            // Show a hint to the user
            alert('In the room-first model, walls are derived from room vertices.\n\nTo add a wall, create a room first, then edit its vertices.');

            Render.layers.openings.batchDraw();
            this.setTool('select');
        });
    },

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Escape: Deselect
            if (e.key === 'Escape') {
                e.preventDefault();
                this.deselect();
            }
            // Undo: Ctrl+Z or Cmd+Z
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
            }
            // Redo: Ctrl+Y or Cmd+Y or Ctrl+Shift+Z
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                this.redo();
            }
        });
    },

    deselect() {
        Render.deselect();
        this.render();
        this.updateInspector();
        // Remove tree item highlight
        document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('selected'));
    },

    saveState() {
        // Deep clone current document state
        const state = JSON.stringify(this.doc);
        this.undoStack.push(state);
        // Limit history size
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        // Clear redo stack when new action is performed
        this.redoStack = [];
        this.updateUndoRedoButtons();
    },

    undo() {
        if (this.undoStack.length <= 1) return; // Keep at least initial state
        // Move current state to redo stack
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        // Restore previous state
        const prevState = this.undoStack[this.undoStack.length - 1];
        this.doc = JSON.parse(prevState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    redo() {
        if (this.redoStack.length === 0) return;
        // Pop from redo and push to undo
        const nextState = this.redoStack.pop();
        this.undoStack.push(nextState);
        // Restore the state
        this.doc = JSON.parse(nextState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    updateUndoRedoButtons() {
        const undoBtn = $('#btnUndo');
        const redoBtn = $('#btnRedo');
        if (undoBtn) {
            undoBtn.disabled = this.undoStack.length <= 1;
            undoBtn.style.opacity = this.undoStack.length <= 1 ? '0.4' : '1';
        }
        if (redoBtn) {
            redoBtn.disabled = this.redoStack.length === 0;
            redoBtn.style.opacity = this.redoStack.length === 0 ? '0.4' : '1';
        }
    },

    newDoc() {
        this.doc = generate2BR1BA();
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    render() {
        Render.render(this.doc, { showWallIds: this.showWallIds, showDims: this.showDims });
    },

    // Edge-based wall tap handler (roomId + edgeIndex)
    onWallEdgeTap(roomId, edgeIndex) {
        const room = this.doc.rooms.find(r => r.id === roomId);
        if (!room) return;

        const edges = getWallEdges(room);
        const edge = edges[edgeIndex];
        if (!edge) return;

        const wallKey = `${roomId}_${edgeIndex}`;

        if (this.currentTool === 'select') {
            Render.select('wall', wallKey);
            this.render();
            this.updateInspector();
            this.highlightTreeItem('wall', wallKey);
        } else if (this.currentTool === 'editShape') {
            // In editShape mode, clicking a wall selects the parent room for vertex editing
            Render.select('room', roomId);
            this.render();
            this.updateInspector();
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(this.currentTool)) {
            this.placeOnEdge(room, edgeIndex, this.currentTool);
        }
    },

    // Legacy wall tap handler (for backwards compatibility)
    onWallTap(wallSegmentId) {
        // Try to find room and edge from wallSegmentId
        // This is for legacy support during transition
        console.warn('onWallTap is deprecated, use onWallEdgeTap');
    },

    onObjectTap(type, id) {
        Render.select(type, id);
        this.render();
        this.updateInspector();
        this.highlightTreeItem(type, id);
    },

    onRoomTap(roomId) {
        // Allow room selection in select mode or editShape mode
        if (this.currentTool === 'select' || this.currentTool === 'editShape') {
            Render.select('room', roomId);
            this.render();
            this.updateInspector();
        }
    },

    // Place object on edge using new model (parentRoomId + parentWallEdgeIndex + tAlongEdge)
    placeOnEdge(room, edgeIndex, toolType) {
        const edges = getWallEdges(room);
        const edge = edges[edgeIndex];
        if (!edge) return;

        const edgeLen = getEdgeLength(edge);
        const defaultT = 0.3;  // 30% along edge

        // Check if edge is exterior
        const isExterior = isEdgeExterior(room, edgeIndex);

        // Windows can ONLY be placed on exterior walls
        if (toolType === 'window' && !isExterior) {
            alert(`Windows can only be placed on exterior walls.\n${room.label} ${edge.label} is an interior wall.`);
            return;
        }

        let obj;
        switch (toolType) {
            case 'door':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'door'), type: 'interior',
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT,
                    width: 2.67 * FOOT, swing: 'in', swingDir: 'left'
                };
                this.doc.doors.push(obj);
                break;
            case 'window':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'window'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT,
                    width: 4 * FOOT, sillHeight: 36 * INCH
                };
                this.doc.windows.push(obj);
                break;
            case 'cased':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'cased'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT,
                    width: 4 * FOOT
                };
                this.doc.casedOpenings.push(obj);
                break;
            case 'pipe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'pipe'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT
                };
                this.doc.mep.push(obj);
                break;
            case 'gas':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'gas'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT
                };
                this.doc.mep.push(obj);
                break;
            case 'radiator':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'radiator'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT,
                    width: 4 * FOOT, height: 1 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'riser':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'riser'),
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT,
                    width: 0.5 * FOOT, height: 0.5 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'poe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'poe'), type: 'entry',
                    parentRoomId: room.id,
                    parentWallEdgeIndex: edgeIndex,
                    tAlongEdge: defaultT
                };
                this.doc.mep.push(obj);
                break;
        }

        if (obj) {
            Render.select(toolType === 'door' || toolType === 'window' || toolType === 'cased' ? toolType : 'mep', obj.id);
            this.saveState();
            this.render();
            this.updateTree();
            this.updateInspector();
            this.updateQABadge();
            this.setTool('select');
        }
    },

    // Legacy placeOnWall - deprecated
    placeOnWall(ws, toolType) {
        console.warn('placeOnWall is deprecated, use placeOnEdge');
    },

    setTool(tool) {
        this.currentTool = tool;
        $$('.tool-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.tool-btn[onclick*="'${tool}'"]`);
        if (btn) btn.classList.add('active');
        $('#btnSelect').classList.toggle('active', tool === 'select');

        // Show hint for placement tools
        const hint = $('#toolHint');
        if (tool === 'room') {
            hint.textContent = 'Drag to draw room (outside) or closet (inside room)';
            hint.classList.add('show');
        } else if (tool === 'wall') {
            hint.textContent = 'Draw wall - snaps to corners (green = snapped)';
            hint.classList.add('show');
        } else if (tool === 'editShape') {
            hint.textContent = 'Click room to edit: drag corners, tap green + to add vertex';
            hint.classList.add('show');
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(tool)) {
            const toolName = tool === 'riser' ? 'PIPE RISER' : tool.toUpperCase();
            hint.textContent = `Tap a wall to place ${toolName}`;
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }
    },

    updateInspector() {
        // Update delete button state based on selection
        const sel = Render.selection;
        const deleteBtn = $('#deleteBtn');
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];

        // In the edge-based model, walls are derived from rooms and cannot be deleted independently
        // Only allow deleting attachments (doors, windows, etc.)
        let canDelete = sel.type && sel.id && deletableTypes.includes(sel.type);

        if (deleteBtn) {
            deleteBtn.disabled = !canDelete;
            deleteBtn.style.opacity = canDelete ? '1' : '0.4';
        }
    },

    deleteSelected() {
        const sel = Render.selection;
        if (sel.type && sel.id) {
            this.deleteObject(sel.id, sel.type);
        }
    },

    deleteObject(objId, objType) {
        // In the edge-based model, walls are derived from rooms and cannot be deleted
        if (objType === 'wall') {
            return;  // Walls cannot be deleted independently
        }

        // Only allow deleting actual objects, not rooms
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
        if (!deletableTypes.includes(objType)) {
            return;  // Silently ignore non-deletable types
        }

        let collection;
        if (objType === 'door') {
            collection = this.doc.doors;
        } else if (objType === 'window') {
            collection = this.doc.windows;
        } else if (objType === 'cased') {
            collection = this.doc.casedOpenings;
        } else if (objType === 'closet') {
            collection = this.doc.closets;
        } else if (objType === 'mep') {
            collection = this.doc.mep;
        }

        if (collection) {
            const index = collection.findIndex(o => o.id === objId);
            if (index !== -1) {
                // Remove from collection
                collection.splice(index, 1);

                // Clear selection and save state
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
        }
    },

    updateObjectWidth(objId, objType, newWidthFeet) {
        const width = parseFloat(newWidthFeet) * FOOT;
        if (isNaN(width) || width < 1 * FOOT || width > 12 * FOOT) {
            alert('Width must be between 1 and 12 feet');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            obj.width = width;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    // Update object offset using tAlongEdge (0-1) normalized position
    updateObjectOffset(objId, objType, newOffsetFeet) {
        const offsetDist = parseFloat(newOffsetFeet) * FOOT;
        if (isNaN(offsetDist) || offsetDist < 0) {
            alert('Offset must be 0 or greater');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;
        else if (objType === 'mep') collection = this.doc.mep;

        const obj = collection?.find(o => o.id === objId);
        if (obj && obj.parentRoomId && typeof obj.parentWallEdgeIndex === 'number') {
            // Get edge to calculate tAlongEdge
            const room = this.doc.rooms.find(r => r.id === obj.parentRoomId);
            if (!room) return;

            const edges = getWallEdges(room);
            const edge = edges[obj.parentWallEdgeIndex];
            if (!edge) return;

            const edgeLen = getEdgeLength(edge);
            const maxOffset = edgeLen - (obj.width || 0);

            if (offsetDist > maxOffset) {
                alert(`Offset too large. Max: ${(maxOffset / FOOT).toFixed(1)} ft`);
                return;
            }

            // Convert offset distance to tAlongEdge
            obj.tAlongEdge = offsetDist / edgeLen;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateTree() {
        const tree = $('#objectTree');
        while (tree.firstChild) tree.removeChild(tree.firstChild);

        // Helper to get wall label from parentRoomId and parentWallEdgeIndex
        const getWallLabel = (item) => {
            if (item.parentRoomId && typeof item.parentWallEdgeIndex === 'number') {
                const room = this.doc.rooms.find(r => r.id === item.parentRoomId);
                if (room) {
                    const edges = getWallEdges(room);
                    const edge = edges[item.parentWallEdgeIndex];
                    return edge ? ` → ${edge.label}` : '';
                }
            }
            return '';
        };

        const addGroup = (title, items, color, type) => {
            if (items.length === 0) return;
            const grp = document.createElement('div');
            grp.className = 'tree-group';
            const label = document.createElement('div');
            label.className = 'tree-label';
            label.textContent = `${title} (${items.length})`;
            grp.appendChild(label);

            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'tree-item';
                el.dataset.type = type;
                el.dataset.id = item.id;
                const wallInfo = getWallLabel(item);

                const dot = document.createElement('div');
                dot.className = 'tree-dot';
                dot.style.background = color;
                el.appendChild(dot);

                const span = document.createElement('span');
                span.textContent = `${item.label}${item.type ? ' (' + item.type + ')' : ''}${wallInfo}`;
                el.appendChild(span);

                el.onclick = () => this.onObjectTap(type, item.id);
                grp.appendChild(el);
            });
            tree.appendChild(grp);
        };

        // Rooms with derived wall edges
        if (this.doc.rooms.length > 0) {
            const roomGrp = document.createElement('div');
            roomGrp.className = 'tree-group';
            const roomLabel = document.createElement('div');
            roomLabel.className = 'tree-label';
            roomLabel.textContent = `ROOMS (${this.doc.rooms.length})`;
            roomGrp.appendChild(roomLabel);

            this.doc.rooms.forEach(room => {
                const roomEl = document.createElement('div');
                roomEl.className = 'tree-item';
                roomEl.dataset.type = 'room';
                roomEl.dataset.id = room.id;

                const dot = document.createElement('div');
                dot.className = 'tree-dot';
                dot.style.background = '#f4d03f';
                roomEl.appendChild(dot);

                const span = document.createElement('span');
                span.textContent = `${room.label} - ${room.type}`;
                roomEl.appendChild(span);

                roomEl.onclick = () => this.onRoomTap(room.id);
                roomGrp.appendChild(roomEl);

                // Derived wall edges under room
                const edges = getWallEdges(room);
                edges.forEach((edge, edgeIndex) => {
                    const wallKey = `${room.id}_${edgeIndex}`;
                    const isExterior = isEdgeExterior(room, edgeIndex);

                    // Count attachments on this edge
                    const attachCount =
                        this.doc.doors.filter(d => d.parentRoomId === room.id && d.parentWallEdgeIndex === edgeIndex).length +
                        this.doc.windows.filter(w => w.parentRoomId === room.id && w.parentWallEdgeIndex === edgeIndex).length +
                        this.doc.casedOpenings.filter(c => c.parentRoomId === room.id && c.parentWallEdgeIndex === edgeIndex).length +
                        this.doc.mep.filter(m => m.parentRoomId === room.id && m.parentWallEdgeIndex === edgeIndex).length;

                    const edgeEl = document.createElement('div');
                    edgeEl.className = 'tree-item';
                    edgeEl.style.paddingLeft = '20px';
                    edgeEl.dataset.type = 'wall';
                    edgeEl.dataset.id = wallKey;

                    const edgeDot = document.createElement('div');
                    edgeDot.className = 'tree-dot';
                    edgeDot.style.background = '#666';
                    edgeDot.style.width = '6px';
                    edgeDot.style.height = '6px';
                    edgeEl.appendChild(edgeDot);

                    const edgeSpan = document.createElement('span');
                    edgeSpan.textContent = `${edge.label} (${isExterior ? 'ext' : 'int'}) [${attachCount}]`;
                    edgeEl.appendChild(edgeSpan);

                    edgeEl.onclick = () => this.onWallEdgeTap(room.id, edgeIndex);
                    roomGrp.appendChild(edgeEl);
                });
            });
            tree.appendChild(roomGrp);
        }

        addGroup('DOORS', this.doc.doors, '#3b82f6', 'door');
        addGroup('WINDOWS', this.doc.windows, '#87ceeb', 'window');
        addGroup('OPENINGS', this.doc.casedOpenings, '#aaa', 'cased');
        addGroup('CLOSETS', this.doc.closets, '#666', 'closet');
        addGroup('MEP', this.doc.mep, '#22c55e', 'mep');
    },

    highlightTreeItem(type, id) {
        $$('.tree-item').forEach(el => el.classList.remove('selected'));
        const el = document.querySelector(`.tree-item[data-type="${type}"][data-id="${id}"]`);
        if (el) el.classList.add('selected');
    },

    toggle(what) {
        switch (what) {
            case 'grid': this.showGrid = !this.showGrid; $('#btnGrid').classList.toggle('active', this.showGrid); Render.layers.grid.visible(this.showGrid); break;
            case 'wallIds': this.showWallIds = !this.showWallIds; $('#btnWallIds').classList.toggle('active', this.showWallIds); this.render(); break;
            case 'dims': this.showDims = !this.showDims; $('#btnDims').classList.toggle('active', this.showDims); this.render(); break;
        }
        Render.stage.batchDraw();
    },

    toggleSidebar() { $('#sidebarLeft').classList.toggle('collapsed'); },

    toggleObjectPanel() {
        const tree = $('#objectTree');
        const toggle = $('#objectToggle');
        tree.classList.toggle('collapsed');
        toggle.textContent = tree.classList.contains('collapsed') ? '▶' : '▼';
    },

    resetView() {
        Render.stage.scale({ x: 1, y: 1 });
        Render.stage.position({ x: 0, y: 0 });
        Render.stage.batchDraw();
    },

    updateQABadge() {
        const results = runQA(this.doc);
        const fails = results.filter(r => !r.pass).length;
        const badge = $('#qaBadge');
        badge.textContent = fails === 0 ? 'QA: PASS' : `QA: ${fails} errors`;
        badge.className = 'qa-badge' + (fails > 0 ? ' error' : '');
    },

    showQA() {
        const results = runQA(this.doc);
        $('#qaContent').innerHTML = results.map(r => `
            <div class="qa-item">
                <span class="${r.pass ? 'qa-pass' : 'qa-fail'}">${r.pass ? '✓' : '✗'}</span>
                <span>${r.rule}</span>
                <span style="color:#888;margin-left:auto">${r.detail}</span>
            </div>
        `).join('');
        $('#qaModal').classList.add('show');
    },

    hideModal(which) { $(`#${which}Modal`).classList.remove('show'); },

    loadFBG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                this.doc = this.importFBG(data);
                this.undoStack = [];
                this.redoStack = [];
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateQABadge();
                this.updateInspector();
                this.updateUndoRedoButtons();
            } catch (err) { alert('Load error: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    },

    importFBG(data) {
        const doc = Doc.create();
        doc.address = data.address || '';
        const level = data.levels?.[data.currentLevelIndex || 0];
        if (!level) return doc;

        const objs = level.canvasObjects || [];
        let minX = Infinity, minY = Infinity;
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                minX = Math.min(minX, o.startX || 0, o.endX || 0);
                minY = Math.min(minY, o.startY || 0, o.endY || 0);
            }
        });
        const offX = isFinite(minX) ? 60 - minX : 0;
        const offY = isFinite(minY) ? 60 - minY : 0;

        // First pass: create rooms
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                if (isCloset) return; // Skip closets in first pass

                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                const geometry = { x, y, width: w, height: h };
                const room = {
                    id: Doc.uid(),
                    label: Doc.label(doc, 'room'),
                    type: rt.name || abbr,
                    fbgName: o.name,
                    isExterior: true,
                    vertices: geometryToVertices(geometry)
                };
                doc.rooms.push(room);
            }
        });

        // Second pass: create closets and link to containing rooms
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                if (!isCloset) return; // Only closets in second pass

                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                const geometry = { x, y, width: w, height: h };

                // Find host room (closet center should be inside or near a room)
                const closetCenterX = x + w / 2;
                const closetCenterY = y + h / 2;
                const hostRoom = doc.rooms.find(room => {
                    const bounds = getVerticesBounds(room.vertices);
                    return closetCenterX >= bounds.x && closetCenterX <= bounds.x + bounds.width &&
                           closetCenterY >= bounds.y && closetCenterY <= bounds.y + bounds.height;
                });

                doc.closets.push({
                    id: Doc.uid(),
                    label: Doc.label(doc, 'closet'),
                    fbgName: o.name,
                    hostRoomId: hostRoom ? hostRoom.id : null,
                    vertices: geometryToVertices(geometry)
                });
            }
        });

        // Mark exterior walls after all rooms are added
        markExteriorWalls(doc);
        return doc;
    },

    exportPDF() {
        const qa = runQA(this.doc);
        const fails = qa.filter(r => !r.pass).length;
        if (fails > 0 && !confirm(`QA has ${fails} errors. Export anyway?`)) return;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'pt', 'letter');

        pdf.setFontSize(14);
        pdf.text('2BR/1BA Blueprint - Wall Edge Attachments', 40, 30);
        pdf.setFontSize(9);
        pdf.text(`Address: ${this.doc.address}`, 40, 45);
        pdf.text(`Date: ${new Date().toLocaleDateString()}`, 40, 57);
        pdf.text(`Rooms: ${this.doc.rooms.length} | Doors: ${this.doc.doors.length} | Windows: ${this.doc.windows.length}`, 40, 69);
        pdf.text(`QA: ${fails === 0 ? 'PASS' : fails + ' errors'}`, 300, 45);

        const img = Render.getImage();
        if (img) pdf.addImage(img, 'PNG', 40, 85, 700, 420);

        pdf.setFontSize(7);
        pdf.text('Wall IDs: W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south-most wall)', 40, 520);

        // Attachment summary using edge-based model
        let y = 535;
        pdf.setFontSize(8);
        pdf.text('Attachments:', 40, y);
        y += 10;

        // Iterate through rooms and their edges
        this.doc.rooms.forEach(room => {
            const edges = getWallEdges(room);
            edges.forEach((edge, edgeIndex) => {
                // Find all attachments on this edge
                const attachments = [
                    ...this.doc.doors.filter(d => d.parentRoomId === room.id && d.parentWallEdgeIndex === edgeIndex),
                    ...this.doc.windows.filter(w => w.parentRoomId === room.id && w.parentWallEdgeIndex === edgeIndex),
                    ...this.doc.casedOpenings.filter(c => c.parentRoomId === room.id && c.parentWallEdgeIndex === edgeIndex),
                    ...this.doc.mep.filter(m => m.parentRoomId === room.id && m.parentWallEdgeIndex === edgeIndex)
                ];

                if (attachments.length > 0) {
                    const items = attachments.map(a => a.label).join(', ');
                    pdf.text(`${room.label} ${edge.label}: ${items}`, 50, y);
                    y += 9;
                    if (y > 580) { y = 535; pdf.addPage(); }
                }
            });
        });

        pdf.save(`Blueprint_WallAttach_${new Date().toISOString().split('T')[0]}.pdf`);
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// Keyboard shortcut for delete (objects only - walls cannot be deleted)
document.addEventListener('keydown', (e) => {
    const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
    if ((e.key === 'Delete' || e.key === 'Backspace') && Render.selection.type && Render.selection.id) {
        // Don't delete if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // In edge-based model, only attachments can be deleted (not walls)
        const canDelete = deletableTypes.includes(Render.selection.type);

        if (!canDelete) return;
        e.preventDefault();
        App.deleteObject(Render.selection.id, Render.selection.type);
    }
});
</script>
</body>
</html>
