<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Blueprint Builder - Wall Segment Selection</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-canvas: #ffffff;
            --bg-panel: rgba(245, 247, 250, 0.92);
            --bg-tool: rgba(255, 255, 255, 0.8);
            --bg-tool-hover: rgba(59, 130, 246, 0.1);
            --border: transparent;
            --text: #1f2937;
            --text-dim: #6b7280;
            --accent: #2563eb;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
            --wall-color: #2d3748;
            --grid-color: #bfdbfe;
            --grid-major: #93c5fd;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif; background: var(--bg-canvas); color: var(--text); height: 100vh; height: 100dvh; overflow: hidden; touch-action: none; }
        .app { display: flex; flex-direction: column; height: 100%; }

        .topbar { display: flex; align-items: center; padding: 6px 12px; background: var(--bg-panel); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-bottom: none; gap: 6px; flex-wrap: nowrap; overflow-x: auto; min-height: 44px; }
        .topbar::-webkit-scrollbar { display: none; }
        .btn { padding: 8px 12px; background: var(--bg-tool); border: none; color: var(--text); border-radius: 8px; font-size: 11px; font-weight: 500; cursor: pointer; white-space: nowrap; min-height: 32px; transition: all 0.15s ease; }
        .btn:hover { background: var(--bg-tool-hover); }
        .btn:active { background: var(--accent-blue); color: white; }
        .btn.active { background: var(--accent-blue); color: white; }
        .btn.warn { background: var(--accent-red); color: white; }
        .sep { width: 1px; height: 20px; background: #e5e7eb; margin: 0 6px; flex-shrink: 0; }

        .main { display: flex; flex: 1; overflow: hidden; position: relative; }

        .sidebar-left { width: 180px; background: var(--bg-panel); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-right: none; display: flex; flex-direction: column; overflow: hidden; transition: width 0.2s ease; position: relative; z-index: 10; }
        .sidebar-left.collapsed { width: 52px; }
        .sidebar-left.collapsed .sidebar-scroll { padding: 4px; }
        .sidebar-left.collapsed .section-header { display: none; }
        .sidebar-left.collapsed .section-content { padding: 2px; }
        .sidebar-left.collapsed .tool-grid { grid-template-columns: 1fr; gap: 4px; }
        .sidebar-left.collapsed .tool-btn { min-height: 40px; padding: 6px; }
        .sidebar-left.collapsed .tool-btn span { display: none; }
        .sidebar-left.collapsed .tool-btn svg { margin-bottom: 0; }
        .sidebar-left.collapsed #objectSection { display: none; }
        .sidebar-left.collapsed .sidebar-toggle { writing-mode: vertical-rl; text-orientation: mixed; padding: 12px 8px; }
        .sidebar-toggle { padding: 10px; background: transparent; border: none; color: var(--accent); font-size: 16px; cursor: pointer; border-bottom: none; }
        .sidebar-scroll { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 8px; }
        .sidebar-scroll::-webkit-scrollbar { width: 4px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 2px; }
        .section { margin-bottom: 12px; }
        .section-header { padding: 6px 8px; font-size: 9px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .section-content { padding: 4px; }
        .section-content.collapsed { display: none; }

        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .tool-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px 4px; background: var(--bg-tool); border: none; border-radius: 10px; color: var(--text); font-size: 8px; font-weight: 500; cursor: pointer; min-height: 48px; transition: all 0.15s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .tool-btn:hover { background: var(--bg-tool-hover); transform: translateY(-1px); }
        .tool-btn:active, .tool-btn.active { background: var(--accent-blue); color: white; }
        .tool-btn svg { width: 20px; height: 20px; margin-bottom: 3px; }
        .tool-btn svg * { stroke: currentColor; fill: none; stroke-width: 1.5; }
        .tool-btn.filled svg * { fill: currentColor; stroke: none; }

        .tree-group { margin-bottom: 8px; }
        .tree-label { font-size: 9px; color: var(--accent); padding: 4px 8px; font-weight: 600; }
        .tree-item { display: flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 10px; cursor: pointer; border-radius: 6px; transition: background 0.1s; }
        .tree-item:hover { background: var(--bg-tool-hover); }
        .tree-item:active, .tree-item.selected { background: rgba(59,130,246,0.2); }
        .tree-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }

        .canvas-wrap { flex: 1; background: var(--bg-canvas); position: relative; overflow: hidden; }
        #stage { width: 100%; height: 100%; }
        .north-arrow { position: absolute; top: 12px; right: 12px; width: 36px; height: 36px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; color: var(--accent); border: 2px solid var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .scale-label { position: absolute; bottom: 12px; left: 12px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); padding: 6px 12px; border-radius: 6px; font-size: 10px; color: var(--text-dim); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .qa-badge { position: absolute; top: 12px; left: 12px; background: var(--accent-green); color: #fff; padding: 5px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .qa-badge.error { background: var(--accent-red); }
        .tool-hint { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 10px; font-size: 11px; color: var(--accent); display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .tool-hint.show { display: block; }

        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal.show { display: flex; }
        .modal-box { background: white; border: none; border-radius: 16px; max-width: 420px; width: 100%; max-height: 80vh; overflow: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
        .modal-head { padding: 16px 20px; border-bottom: 1px solid #f3f4f6; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 15px; font-weight: 600; color: var(--text); }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; }
        .modal-body { padding: 20px; font-size: 12px; }
        .qa-item { padding: 8px 0; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; gap: 10px; }
        .qa-pass { color: var(--accent-green); }
        .qa-fail { color: var(--accent-red); }

        @media (max-width: 768px) {
            .topbar { padding: 4px 8px; min-height: 40px; }
            .btn { padding: 6px 10px; font-size: 10px; min-height: 28px; }
            .sidebar-left { width: 52px; }
            .sidebar-left .sidebar-scroll { padding: 4px; }
            .sidebar-left .section-header { display: none; }
            .sidebar-left .section-content { padding: 2px; }
            .sidebar-left .tool-grid { grid-template-columns: 1fr; gap: 4px; }
            .sidebar-left .tool-btn { min-height: 40px; padding: 6px; }
            .sidebar-left .tool-btn span { display: none; }
            .sidebar-left .tool-btn svg { margin-bottom: 0; }
            .sidebar-left #objectSection { display: none; }
            .north-arrow { width: 28px; height: 28px; font-size: 10px; top: 8px; right: 8px; }
            .scale-label { font-size: 9px; padding: 4px 8px; bottom: 8px; left: 8px; }
            .qa-badge { font-size: 9px; padding: 4px 10px; top: 8px; left: 8px; }
            .tool-hint { font-size: 10px; padding: 8px 14px; bottom: 40px; }
        }
        @media (max-width: 480px) {
            .topbar { flex-wrap: wrap; gap: 4px; }
            .sep { display: none; }
            .btn { padding: 5px 8px; font-size: 9px; }
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
<div class="app">
    <div class="topbar">
        <button class="btn" onclick="App.newDoc()">New</button>
        <button class="btn" onclick="$('#fbgInput').click()">Load</button>
        <input type="file" id="fbgInput" accept=".fbg,.fgs,.json" onchange="App.loadFBG(event)">
        <button class="btn" onclick="App.exportPDF()">PDF</button>
        <div class="sep"></div>
        <button class="btn active" id="btnGrid" onclick="App.toggle('grid')">Grid</button>
        <button class="btn active" id="btnWallIds" onclick="App.toggle('wallIds')">W-ID</button>
        <button class="btn active" id="btnDims" onclick="App.toggle('dims')">Dims</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.resetView()">Reset</button>
        <button class="btn" onclick="Render.fitToContent()">Fit</button>
        <button class="btn active" id="btnSelect" onclick="App.setTool('select')">Select</button>
        <div class="sep"></div>
        <button class="btn" onclick="App.showQA()">QA</button>
    </div>
    <div class="main">
        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-toggle" onclick="App.toggleSidebar()">☰</button>
            <div class="sidebar-scroll">
                <div class="section">
                    <div class="section-header">Geometry (draw)</div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr 1fr;">
                            <button class="tool-btn" onclick="App.setTool('room')"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1" stroke-dasharray="3,2"/><line x1="12" y1="8" x2="12" y2="16" stroke-width="2"/><line x1="8" y1="12" x2="16" y2="12" stroke-width="2"/></svg><span>Room</span></button>
                            <button class="tool-btn" onclick="App.setTool('wall')"><svg viewBox="0 0 24 24"><line x1="4" y1="20" x2="20" y2="4" stroke-width="3"/><circle cx="4" cy="20" r="2" fill="currentColor"/><circle cx="20" cy="4" r="2" fill="currentColor"/></svg><span>Wall</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Openings (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('door')"><svg viewBox="0 0 24 24"><rect x="6" y="3" width="12" height="18" rx="1"/><circle cx="15" cy="12" r="1.5" fill="currentColor"/></svg><span>Door</span></button>
                            <button class="tool-btn" onclick="App.setTool('window')"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="1"/><line x1="12" y1="7" x2="12" y2="17"/></svg><span>Window</span></button>
                            <button class="tool-btn" onclick="App.setTool('cased')"><svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3,2"/></svg><span>Cased</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">MEP (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('pipe')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg><span>Pipe</span></button>
                            <button class="tool-btn filled" onclick="App.setTool('gas')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg><span>Gas</span></button>
                            <button class="tool-btn" onclick="App.setTool('radiator')"><svg viewBox="0 0 24 24"><rect x="3" y="8" width="18" height="10" rx="1"/><line x1="6" y1="9" x2="6" y2="17"/><line x1="9" y1="9" x2="9" y2="17"/><line x1="12" y1="9" x2="12" y2="17"/><line x1="15" y1="9" x2="15" y2="17"/><line x1="18" y1="9" x2="18" y2="17"/></svg><span>Rad</span></button>
                            <button class="tool-btn" onclick="App.setTool('riser')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="3"/></svg><span>Riser</span></button>
                            <button class="tool-btn" onclick="App.setTool('poe')"><svg viewBox="0 0 24 24"><polygon points="12,2 22,12 17,12 17,22 7,22 7,12 2,12" fill="currentColor"/></svg><span>POE</span></button>
                        </div>
                    </div>
                </div>
                <div class="section" id="objectSection">
                    <div class="section-header" onclick="App.toggleObjectPanel()">Objects <span id="objectToggle">▶</span></div>
                    <div class="section-content collapsed" id="objectTree"></div>
                </div>
                <div class="section">
                    <div class="section-header">Actions</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.selectAll()" title="Select All (Ctrl+A)">
                                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" fill="none" stroke-width="2"/><path d="M9 12l2 2 4-4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>All</span>
                            </button>
                            <button class="tool-btn" onclick="App.copySelected()" title="Copy (Ctrl+C)">
                                <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" stroke="currentColor" fill="none" stroke-width="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Copy</span>
                            </button>
                            <button class="tool-btn" onclick="App.paste()" title="Paste (Ctrl+V)">
                                <svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" stroke="currentColor" fill="none" stroke-width="2"/><rect x="8" y="2" width="8" height="4" rx="1" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Paste</span>
                            </button>
                            <button class="tool-btn" id="btnUndo" onclick="App.undo()" title="Undo (Ctrl+Z)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M3 10h10a5 5 0 015 5v2M3 10l5-5M3 10l5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>Undo</span>
                            </button>
                            <button class="tool-btn" id="btnRedo" onclick="App.redo()" title="Redo (Ctrl+Y)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M21 10H11a5 5 0 00-5 5v2M21 10l-5-5M21 10l-5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>Redo</span>
                            </button>
                            <button class="tool-btn" id="deleteBtn" onclick="App.deleteSelected()" title="Delete selected" style="background: var(--accent-red); border-color: var(--accent-red); opacity: 0.4;" disabled>
                                <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14M10 11v6M14 11v6" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Delete</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-wrap">
            <div id="stage"></div>
            <div class="north-arrow">N</div>
            <div class="scale-label">1/4" = 1'-0"</div>
            <div class="qa-badge" id="qaBadge">QA: --</div>
            <div class="tool-hint" id="toolHint">Tap a wall segment to place</div>
        </div>
    </div>
</div>

<div class="modal" id="qaModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">QA Validation</div>
            <button class="modal-close" onclick="App.hideModal('qa')">&times;</button>
        </div>
        <div class="modal-body" id="qaContent"></div>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ========== CONSTANTS ==========
const SCALE = 4;
const INCH = SCALE;
const FOOT = 12 * SCALE;
const WALL_EXT = 6 * INCH;
const WALL_INT = 4.5 * INCH;
const SNAP_DISTANCE = 24; // Mobile-friendly snap distance in pixels
const HIT_WIDTH = 28; // Hit region width for wall segments
const GRID_SNAP = FOOT; // Snap to 1-foot grid

// Wall colors
const WALL_COLOR_EXTERIOR = '#2d3748';       // Dark grey for exterior walls
const WALL_COLOR_INTERIOR = '#4a5568';       // Medium grey for interior non-shared walls
const WALL_COLOR_SHARED_A = '#6366f1';       // Indigo for shared wall side A
const WALL_COLOR_SHARED_B = '#8b5cf6';       // Purple for shared wall side B
const WALL_COLOR_SELECTED = '#3b82f6';       // Blue for selected walls
const SHARED_WALL_GAP = 2;                   // Gap between dual strokes

// ========== SNAPPING FUNCTIONS ==========
function snapToGrid(value) {
    return Math.round(value / GRID_SNAP) * GRID_SNAP;
}

function findRoomSnapPoints(doc, excludeRoomId) {
    // Get all room edges for snapping (excluding current room)
    const snapPoints = { x: [], y: [] };
    doc.rooms.forEach(room => {
        if (room.id === excludeRoomId) return;
        const g = room.geometry;
        snapPoints.x.push(g.x, g.x + g.width);
        snapPoints.y.push(g.y, g.y + g.height);
    });
    return snapPoints;
}

function snapRoomPosition(x, y, width, height, snapPoints) {
    let snappedX = x;
    let snappedY = y;

    // Check left edge
    for (const sx of snapPoints.x) {
        if (Math.abs(x - sx) < SNAP_DISTANCE) { snappedX = sx; break; }
        if (Math.abs(x + width - sx) < SNAP_DISTANCE) { snappedX = sx - width; break; }
    }

    // Check top edge
    for (const sy of snapPoints.y) {
        if (Math.abs(y - sy) < SNAP_DISTANCE) { snappedY = sy; break; }
        if (Math.abs(y + height - sy) < SNAP_DISTANCE) { snappedY = sy - height; break; }
    }

    // Also snap to grid if not snapped to room
    if (snappedX === x) snappedX = snapToGrid(x);
    if (snappedY === y) snappedY = snapToGrid(y);

    return { x: snappedX, y: snappedY };
}

// ========== SHARED WALL DETECTION ==========
// Check if two line segments overlap (for detecting shared walls)
function segmentsOverlap(ws1, ws2, tolerance = 2) {
    // Check if segments are collinear and overlapping
    const isHorizontal1 = Math.abs(ws1.y1 - ws1.y2) < tolerance;
    const isHorizontal2 = Math.abs(ws2.y1 - ws2.y2) < tolerance;
    const isVertical1 = Math.abs(ws1.x1 - ws1.x2) < tolerance;
    const isVertical2 = Math.abs(ws2.x1 - ws2.x2) < tolerance;

    // Both horizontal and at same Y level
    if (isHorizontal1 && isHorizontal2 && Math.abs(ws1.y1 - ws2.y1) < tolerance) {
        const minX1 = Math.min(ws1.x1, ws1.x2), maxX1 = Math.max(ws1.x1, ws1.x2);
        const minX2 = Math.min(ws2.x1, ws2.x2), maxX2 = Math.max(ws2.x1, ws2.x2);
        // Check for overlap
        return maxX1 > minX2 + tolerance && maxX2 > minX1 + tolerance;
    }

    // Both vertical and at same X level
    if (isVertical1 && isVertical2 && Math.abs(ws1.x1 - ws2.x1) < tolerance) {
        const minY1 = Math.min(ws1.y1, ws1.y2), maxY1 = Math.max(ws1.y1, ws1.y2);
        const minY2 = Math.min(ws2.y1, ws2.y2), maxY2 = Math.max(ws2.y1, ws2.y2);
        // Check for overlap
        return maxY1 > minY2 + tolerance && maxY2 > minY1 + tolerance;
    }

    return false;
}

// Find the other room that shares this wall segment
function findSharedWallInfo(ws, doc) {
    if (!ws.roomId) return null;

    const thisRoom = doc.rooms.find(r => r.id === ws.roomId);
    if (!thisRoom) return null;

    // Look for walls from other rooms that overlap this one
    for (const otherWs of doc.wallSegments) {
        if (otherWs.id === ws.id) continue;
        if (otherWs.roomId === ws.roomId) continue;
        if (!otherWs.roomId) continue;

        const otherRoom = doc.rooms.find(r => r.id === otherWs.roomId);
        if (!otherRoom) continue;

        if (segmentsOverlap(ws, otherWs)) {
            // Determine which room is "first" (consistent ordering for color assignment)
            const roomIndex = doc.rooms.findIndex(r => r.id === ws.roomId);
            const otherRoomIndex = doc.rooms.findIndex(r => r.id === otherWs.roomId);

            return {
                isShared: true,
                otherRoom: otherRoom,
                otherWallSegment: otherWs,
                isFirstRoom: roomIndex < otherRoomIndex
            };
        }
    }

    return { isShared: false };
}

// ========== DOCUMENT MODEL ==========
const Doc = {
    create() {
        return {
            id: this.uid(),
            version: '4.0',
            address: '2BR/1BA Blueprint',
            counters: { room: 0, wallSegment: 0, door: 0, window: 0, closet: 0, cased: 0, pipe: 0, gas: 0, riser: 0, radiator: 0, poe: 0 },
            rooms: [],
            wallSegments: [],  // All wall segments indexed here
            doors: [],
            windows: [],
            casedOpenings: [],
            closets: [],
            mep: [],
            dimensions: []
        };
    },
    uid() { return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); },
    label(doc, type) {
        doc.counters[type] = (doc.counters[type] || 0) + 1;
        const prefixes = { room: 'Rm', wallSegment: 'WS', door: 'D', window: 'WIN', closet: 'CL', cased: 'OP', pipe: 'PIPE', gas: 'GAS', riser: 'PRSR', radiator: 'RAD', poe: 'POE' };
        const n = doc.counters[type];
        return (prefixes[type] || type.toUpperCase()) + '-' + (n < 10 ? '0' : '') + n;
    }
};

// ========== WALL SEGMENT CREATION ==========
function createWallSegments(room, doc) {
    const g = room.geometry;
    // Create 4 segments for rectangular room: S, W, N, E
    // Segments defined by endpoints, ordered clockwise
    const segments = [
        { side: 'south', x1: g.x, y1: g.y + g.height, x2: g.x + g.width, y2: g.y + g.height },
        { side: 'west',  x1: g.x, y1: g.y + g.height, x2: g.x, y2: g.y },
        { side: 'north', x1: g.x, y1: g.y, x2: g.x + g.width, y2: g.y },
        { side: 'east',  x1: g.x + g.width, y1: g.y, x2: g.x + g.width, y2: g.y + g.height }
    ];

    // Determine which segment is SOUTH-most (highest Y average)
    let southIdx = 0;
    let maxY = -Infinity;
    segments.forEach((seg, i) => {
        const avgY = (seg.y1 + seg.y2) / 2;
        if (avgY > maxY) { maxY = avgY; southIdx = i; }
    });

    // Reorder so W1 is the SOUTH-most, then clockwise
    const ordered = [];
    for (let i = 0; i < 4; i++) {
        ordered.push(segments[(southIdx + i) % 4]);
    }

    // Create WallSegment objects
    const wallSegments = ordered.map((seg, idx) => {
        const ws = {
            id: Doc.uid(),
            roomId: room.id,
            roomLabel: room.label,
            index: idx + 1,
            label: 'W' + (idx + 1),
            side: seg.side,
            x1: seg.x1, y1: seg.y1, x2: seg.x2, y2: seg.y2,
            thickness: room.isExterior ? WALL_EXT : WALL_INT,
            type: 'interior',  // Default to interior, will be set properly by markExteriorWalls()
            attachedObjects: []
        };
        doc.wallSegments.push(ws);
        return ws;
    });

    room.wallSegmentIds = wallSegments.map(ws => ws.id);
    return wallSegments;
}

function getSegmentLength(seg) {
    return Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
}

function getSegmentMidpoint(seg) {
    return { x: (seg.x1 + seg.x2) / 2, y: (seg.y1 + seg.y2) / 2 };
}

function getSegmentAngle(seg) {
    return Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1);
}

function pointToSegmentDistance(px, py, seg) {
    const dx = seg.x2 - seg.x1;
    const dy = seg.y2 - seg.y1;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.sqrt((px - seg.x1) ** 2 + (py - seg.y1) ** 2);
    let t = ((px - seg.x1) * dx + (py - seg.y1) * dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = seg.x1 + t * dx;
    const nearY = seg.y1 + t * dy;
    return { distance: Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2), t, nearX, nearY };
}

function findNearestWallSegment(x, y, doc) {
    let nearest = null;
    let minDist = Infinity;
    let nearestT = 0;
    let nearestPoint = null;

    doc.wallSegments.forEach(seg => {
        const result = pointToSegmentDistance(x, y, seg);
        if (result.distance < minDist) {
            minDist = result.distance;
            nearest = seg;
            nearestT = result.t;
            nearestPoint = { x: result.nearX, y: result.nearY };
        }
    });

    return { segment: nearest, distance: minDist, t: nearestT, point: nearestPoint };
}

// ========== MARK EXTERIOR WALLS ==========
// Determines which walls are on the building perimeter (exterior) vs shared with other rooms (interior)
function markExteriorWalls(doc) {
    if (doc.rooms.length === 0) return;

    // Find building bounding box from all rooms
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    doc.rooms.forEach(room => {
        const g = room.geometry;
        minX = Math.min(minX, g.x);
        minY = Math.min(minY, g.y);
        maxX = Math.max(maxX, g.x + g.width);
        maxY = Math.max(maxY, g.y + g.height);
    });

    // Tolerance for edge detection (walls on perimeter)
    const tolerance = 2;

    // Mark each wall segment as exterior if it's on the building perimeter
    doc.wallSegments.forEach(ws => {
        const midX = (ws.x1 + ws.x2) / 2;
        const midY = (ws.y1 + ws.y2) / 2;
        const isVertical = Math.abs(ws.x1 - ws.x2) < tolerance;
        const isHorizontal = Math.abs(ws.y1 - ws.y2) < tolerance;

        let isExterior = false;

        if (isHorizontal) {
            // Check if on top or bottom edge
            if (Math.abs(midY - minY) < tolerance || Math.abs(midY - maxY) < tolerance) {
                isExterior = true;
            }
        }
        if (isVertical) {
            // Check if on left or right edge
            if (Math.abs(midX - minX) < tolerance || Math.abs(midX - maxX) < tolerance) {
                isExterior = true;
            }
        }

        ws.type = isExterior ? 'exterior' : 'interior';
        ws.thickness = isExterior ? WALL_EXT : WALL_INT;
    });
}

// ========== GENERATE 2BR/1BA ==========
function generate2BR1BA() {
    const doc = Doc.create();

    // Layout: Clean 2x3 grid with shared walls, no gaps
    // Total exterior: 26' x 20' (compact ranch-style)
    //
    //      0      12     16      26
    //      +------+------+-------+  0
    //      | Bed1 | Hall |Kitchen|
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 10
    //      |Living| Bath | Bed 2 |
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 20
    //
    const startX = 60, startY = 60;

    // Grid columns (x positions)
    const col1 = startX;                    // Left edge
    const col2 = startX + 12 * FOOT;        // 12'
    const col3 = col2 + 4 * FOOT;           // 16'
    const col4 = col3 + 10 * FOOT;          // 26' (right edge)

    // Grid rows (y positions)
    const row1 = startY;                    // Top edge
    const row2 = startY + 10 * FOOT;        // 10'
    const row3 = row2 + 10 * FOOT;          // 20' (bottom edge)

    // ========== ROW 1: Bed1 | Hall | Kitchen ==========
    // Bedroom 1: Top-left (12' x 10')
    const bed1 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 1', isExterior: true,
        geometry: { x: col1, y: row1, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed1, doc);
    doc.rooms.push(bed1);

    // Hall: Top-center (4' x 10')
    const hall = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Hall', isExterior: false,
        geometry: { x: col2, y: row1, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(hall, doc);
    doc.rooms.push(hall);

    // Kitchen: Top-right (10' x 10')
    const kitchen = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Kitchen', isExterior: true,
        geometry: { x: col3, y: row1, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(kitchen, doc);
    doc.rooms.push(kitchen);

    // ========== ROW 2: Living | Bath | Bed2 ==========
    // Living: Bottom-left (12' x 10')
    const living = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Living', isExterior: true,
        geometry: { x: col1, y: row2, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(living, doc);
    doc.rooms.push(living);

    // Bathroom: Bottom-center (4' x 10')
    const bath = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bathroom', isExterior: false,
        geometry: { x: col2, y: row2, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bath, doc);
    doc.rooms.push(bath);

    // Bedroom 2: Bottom-right (10' x 10')
    const bed2 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 2', isExterior: true,
        geometry: { x: col3, y: row2, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed2, doc);
    doc.rooms.push(bed2);

    // Mark which walls are actually on the building exterior vs interior (shared)
    markExteriorWalls(doc);

    // ========== CLOSETS (with parentRoomId and wall segments) ==========
    // CL-01: Inside Bedroom 1, corner position (4' x 3') - shares north and east walls
    const cl1 = {
        id: Doc.uid(), label: Doc.label(doc, 'closet'), type: 'Closet',
        parentRoomId: bed1.id,
        parentRoomLabel: bed1.label,
        isExterior: false,
        geometry: {
            x: bed1.geometry.x + bed1.geometry.width - 4 * FOOT,  // Flush with east wall
            y: bed1.geometry.y,  // Flush with north wall
            width: 4 * FOOT,
            height: 3 * FOOT
        }
    };
    doc.closets.push(cl1);

    // CL-02: Inside Bedroom 2, corner position (4' x 3') - shares north and west walls
    const cl2 = {
        id: Doc.uid(), label: Doc.label(doc, 'closet'), type: 'Closet',
        parentRoomId: bed2.id,
        parentRoomLabel: bed2.label,
        isExterior: false,
        geometry: {
            x: bed2.geometry.x,  // Flush with west wall
            y: bed2.geometry.y,  // Flush with north wall
            width: 4 * FOOT,
            height: 3 * FOOT
        }
    };
    doc.closets.push(cl2);

    // ========== DOORS ==========
    // New layout wall reference:
    // W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south)
    //
    // Circulation path: Entry(Living W1) → Living → Bath(W4/W2) → Hall(W3/W1) → Bed1(W2/W4) + Kitchen(W4/W2)
    //                   Bath → Bed2 (W4/W2)

    // D-01: Entry door on Living south wall (W1) - exterior entry
    const livingSouthWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W1');
    if (livingSouthWall) {
        const d1 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d1);
        livingSouthWall.attachedObjects.push({ type: 'door', id: d1.id, label: d1.label });

        // POE anchored to entry door
        const poe1 = {
            id: Doc.uid(), label: Doc.label(doc, 'poe'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            anchorDoorId: d1.id,
            distanceFromStart: 4.5 * FOOT
        };
        doc.mep.push(poe1);
        livingSouthWall.attachedObjects.push({ type: 'poe', id: poe1.id, label: poe1.label });
    }

    // D-02: Bed 1 to Hall - on Bed1's east wall (W4)
    const bed1EastWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W4');
    if (bed1EastWall) {
        const d2 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed1EastWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d2);
        bed1EastWall.attachedObjects.push({ type: 'door', id: d2.id, label: d2.label });
    }

    // D-03: Bath to Hall - on Bath's north wall (W3)
    const bathNorthWall = doc.wallSegments.find(ws => ws.roomId === bath.id && ws.label === 'W3');
    if (bathNorthWall) {
        const d3 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bathNorthWall.id,
            parentRoomId: bath.id,
            distanceFromStart: 0.5 * FOOT,
            width: 2.5 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d3);
        bathNorthWall.attachedObjects.push({ type: 'door', id: d3.id, label: d3.label });
    }

    // D-04: Bed 2 to Bath - on Bed2's west wall (W2)
    const bed2WestWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W2');
    if (bed2WestWall) {
        const d4 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed2WestWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d4);
        bed2WestWall.attachedObjects.push({ type: 'door', id: d4.id, label: d4.label });
    }

    // D-05: Kitchen to Hall - on Kitchen's west wall (W2)
    const kitchenWestWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W2');
    if (kitchenWestWall) {
        const d5 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: kitchenWestWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d5);
        kitchenWestWall.attachedObjects.push({ type: 'door', id: d5.id, label: d5.label });
    }

    // D-06: Living to Bath - on Living's east wall (W4)
    const livingEastWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W4');
    if (livingEastWall) {
        const d6 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: livingEastWall.id,
            parentRoomId: living.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'out', swingDir: 'right'
        };
        doc.doors.push(d6);
        livingEastWall.attachedObjects.push({ type: 'door', id: d6.id, label: d6.label });
    }

    // ========== WINDOWS ==========
    // WIN-01: Living west wall
    const livingWestWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W2');
    if (livingWestWall) {
        const w1 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 2 * FOOT,
            width: 5 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w1);
        livingWestWall.attachedObjects.push({ type: 'window', id: w1.id, label: w1.label });
    }

    // WIN-02: Bed 1 north wall
    const bed1NorthWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W3');
    if (bed1NorthWall) {
        const w2 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed1NorthWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 3 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w2);
        bed1NorthWall.attachedObjects.push({ type: 'window', id: w2.id, label: w2.label });
    }

    // WIN-03: Bed 2 south wall
    const bed2SouthWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W1');
    if (bed2SouthWall) {
        const w3 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed2SouthWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w3);
        bed2SouthWall.attachedObjects.push({ type: 'window', id: w3.id, label: w3.label });
    }

    // WIN-04: Kitchen east wall
    const kitchenEastWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W4');
    if (kitchenEastWall) {
        const w4 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: kitchenEastWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            sillHeight: 42 * INCH
        };
        doc.windows.push(w4);
        kitchenEastWall.attachedObjects.push({ type: 'window', id: w4.id, label: w4.label });
    }

    // ========== MEP ==========
    // Radiator in Living
    if (livingWestWall) {
        const rad1 = {
            id: Doc.uid(), label: Doc.label(doc, 'radiator'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 8 * FOOT,
            width: 3 * FOOT, height: 1 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rad1);
        livingWestWall.attachedObjects.push({ type: 'radiator', id: rad1.id, label: rad1.label });

        // Riser near radiator
        const rsr1 = {
            id: Doc.uid(), label: Doc.label(doc, 'riser'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 7.5 * FOOT,
            width: 0.5 * FOOT, height: 0.5 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rsr1);
        livingWestWall.attachedObjects.push({ type: 'riser', id: rsr1.id, label: rsr1.label });
    }

    // ========== DIMENSIONS ==========
    const totalW = col4 - col1;  // 26'
    const totalH = row3 - row1;  // 20'
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalW / FOOT)}'-0"`, x1: startX, y1: startY - 25, x2: startX + totalW, y2: startY - 25 });
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalH / FOOT)}'-0"`, x1: startX - 25, y1: startY, x2: startX - 25, y2: startY + totalH, vertical: true });

    return doc;
}

// ========== RENDERER ==========
const Render = {
    stage: null,
    layers: {},
    wallGroups: {},
    selection: { type: null, id: null },
    multiSelection: [],  // Array of {type, id} for multi-select

    init(containerId) {
        const c = document.getElementById(containerId);
        if (!c) return false;
        const r = c.getBoundingClientRect();
        this.stage = new Konva.Stage({ container: containerId, width: r.width, height: r.height, draggable: true });

        this.layers.grid = new Konva.Layer();
        this.layers.rooms = new Konva.Layer();
        this.layers.walls = new Konva.Layer();
        this.layers.openings = new Konva.Layer();
        this.layers.mep = new Konva.Layer();
        this.layers.labels = new Konva.Layer();
        this.layers.dims = new Konva.Layer();
        this.layers.hit = new Konva.Layer(); // Hit regions layer

        this.stage.add(this.layers.grid, this.layers.rooms, this.layers.walls, this.layers.hit, this.layers.openings, this.layers.mep, this.layers.labels, this.layers.dims);

        this.stage.on('wheel', e => {
            e.evt.preventDefault();
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            const mousePointTo = { x: (pointer.x - this.stage.x()) / oldScale, y: (pointer.y - this.stage.y()) / oldScale };

            // Gentler zoom factor (1.03 instead of 1.1) with min/max limits
            const zoomFactor = 1.03;
            const minScale = 0.3;
            const maxScale = 3;
            let newScale = e.evt.deltaY > 0 ? oldScale / zoomFactor : oldScale * zoomFactor;
            newScale = Math.max(minScale, Math.min(maxScale, newScale));

            this.stage.scale({ x: newScale, y: newScale });
            this.stage.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
        });

        new ResizeObserver(() => {
            const rect = c.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                this.stage.width(rect.width);
                this.stage.height(rect.height);
            }
        }).observe(c);

        this.drawGrid();

        // Auto-fit on mobile
        if (window.innerWidth <= 768) {
            setTimeout(() => this.fitToContent(), 100);
        }

        return true;
    },

    // Fit the canvas to show all content with padding
    fitToContent(doc) {
        if (!doc) doc = App.doc;
        if (!doc || !doc.rooms || doc.rooms.length === 0) return;

        // Find bounding box of all rooms and closets
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        doc.rooms.forEach(room => {
            const g = room.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        doc.closets.forEach(closet => {
            const g = closet.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        if (minX === Infinity) return;

        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const padding = 60;

        const stageWidth = this.stage.width();
        const stageHeight = this.stage.height();

        // Calculate scale to fit content with padding
        const scaleX = (stageWidth - padding * 2) / contentWidth;
        const scaleY = (stageHeight - padding * 2) / contentHeight;
        const newScale = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x

        // Center the content
        const centerX = minX + contentWidth / 2;
        const centerY = minY + contentHeight / 2;
        const newX = stageWidth / 2 - centerX * newScale;
        const newY = stageHeight / 2 - centerY * newScale;

        this.stage.scale({ x: newScale, y: newScale });
        this.stage.position({ x: newX, y: newY });
        this.stage.batchDraw();
    },

    drawGrid() {
        const layer = this.layers.grid;
        layer.destroyChildren();
        const w = 2000, h = 1500;
        // Light blue minor grid (6 inch)
        for (let x = 0; x < w; x += 6 * INCH) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#dbeafe', strokeWidth: 0.5 }));
        for (let y = 0; y < h; y += 6 * INCH) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#dbeafe', strokeWidth: 0.5 }));
        // Medium blue major grid (1 foot)
        for (let x = 0; x < w; x += FOOT) layer.add(new Konva.Line({ points: [x, 0, x, h], stroke: '#93c5fd', strokeWidth: 0.75 }));
        for (let y = 0; y < h; y += FOOT) layer.add(new Konva.Line({ points: [0, y, w, y], stroke: '#93c5fd', strokeWidth: 0.75 }));
        layer.batchDraw();
    },

    render(doc, opts = {}) {
        if (!this.stage) return;
        const { showWallIds = true, showDims = true } = opts;

        ['rooms', 'walls', 'hit', 'openings', 'mep', 'labels', 'dims'].forEach(l => this.layers[l].destroyChildren());
        this.wallGroups = {};

        // Room fills (non-listening)
        doc.rooms.forEach(r => this.renderRoomFill(r, doc));

        // Wall segments (with hit regions)
        doc.wallSegments.forEach(ws => this.renderWallSegment(ws, doc, showWallIds));

        // Closets
        doc.closets.forEach(c => this.renderCloset(c, doc));

        // Doors
        doc.doors.forEach(d => this.renderDoor(d, doc));

        // Windows
        doc.windows.forEach(w => this.renderWindow(w, doc));

        // Cased openings
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));

        // MEP
        doc.mep.forEach(m => this.renderMEP(m, doc));

        // Dimensions
        if (showDims) doc.dimensions.forEach(d => this.renderDimension(d));

        Object.values(this.layers).forEach(l => l.batchDraw());
    },

    renderRoomFill(room, doc) {
        const g = room.geometry;
        const isSelected = this.isSelected('room', room.id);
        const self = this;

        // Find closets that belong to this room
        const roomClosets = doc.closets.filter(c => c.parentRoomId === room.id);

        // Create a group for the room (for dragging)
        const roomGroup = new Konva.Group({
            x: 0, y: 0,
            draggable: isSelected
        });

        // Room fill - white/light with subtle border
        const roomFill = '#fafbfc';
        const roomBorder = isSelected ? '#3b82f6' : '#e5e7eb';

        if (roomClosets.length === 0) {
            // Simple case: no closets, just draw rectangle
            roomGroup.add(new Konva.Rect({
                x: g.x, y: g.y, width: g.width, height: g.height,
                fill: roomFill,
                stroke: roomBorder,
                strokeWidth: isSelected ? 2 : 1
            }));
        } else {
            // Room has closets - draw room fill excluding closet areas
            // Use a custom shape to punch holes for closets
            const roomShape = new Konva.Shape({
                sceneFunc: (context, shape) => {
                    context.beginPath();
                    // Outer room rectangle (clockwise)
                    context.moveTo(g.x, g.y);
                    context.lineTo(g.x + g.width, g.y);
                    context.lineTo(g.x + g.width, g.y + g.height);
                    context.lineTo(g.x, g.y + g.height);
                    context.closePath();

                    // Cut out closet areas (counter-clockwise to create holes)
                    roomClosets.forEach(closet => {
                        const cg = closet.geometry;
                        context.moveTo(cg.x, cg.y);
                        context.lineTo(cg.x, cg.y + cg.height);
                        context.lineTo(cg.x + cg.width, cg.y + cg.height);
                        context.lineTo(cg.x + cg.width, cg.y);
                        context.closePath();
                    });

                    context.fillStrokeShape(shape);
                },
                fill: roomFill,
                stroke: roomBorder,
                strokeWidth: isSelected ? 2 : 1
            });
            roomGroup.add(roomShape);
        }

        // Add tap handler for room selection
        roomGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onRoomTap(room.id);
        });

        // Add drag handlers for room movement
        if (isSelected) {
            let startRoomX, startRoomY;
            let startClosetPositions = [];
            let snapPoints = null;

            roomGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                startRoomX = g.x;
                startRoomY = g.y;
                // Store initial closet positions
                startClosetPositions = roomClosets.map(c => ({ id: c.id, x: c.geometry.x, y: c.geometry.y }));
                // Get snap points from other rooms
                snapPoints = findRoomSnapPoints(doc, room.id);
            });

            roomGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const dx = this.x();
                const dy = this.y();

                // Calculate raw position
                const rawX = startRoomX + dx;
                const rawY = startRoomY + dy;

                // Apply snapping
                const snapped = snapRoomPosition(rawX, rawY, g.width, g.height, snapPoints);
                g.x = snapped.x;
                g.y = snapped.y;

                // Calculate actual delta after snapping (for closets)
                const actualDx = g.x - startRoomX;
                const actualDy = g.y - startRoomY;

                // Update wall segments for this room
                const segs = doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    const roomG = room.geometry;
                    if (ws.label === 'W1') { // South wall
                        ws.x1 = roomG.x; ws.y1 = roomG.y + roomG.height;
                        ws.x2 = roomG.x + roomG.width; ws.y2 = roomG.y + roomG.height;
                    } else if (ws.label === 'W2') { // West wall
                        ws.x1 = roomG.x; ws.y1 = roomG.y + roomG.height;
                        ws.x2 = roomG.x; ws.y2 = roomG.y;
                    } else if (ws.label === 'W3') { // North wall
                        ws.x1 = roomG.x; ws.y1 = roomG.y;
                        ws.x2 = roomG.x + roomG.width; ws.y2 = roomG.y;
                    } else if (ws.label === 'W4') { // East wall
                        ws.x1 = roomG.x + roomG.width; ws.y1 = roomG.y;
                        ws.x2 = roomG.x + roomG.width; ws.y2 = roomG.y + roomG.height;
                    }
                });

                // Update closets that belong to this room
                roomClosets.forEach(closet => {
                    const startPos = startClosetPositions.find(p => p.id === closet.id);
                    if (startPos) {
                        closet.geometry.x = startPos.x + actualDx;
                        closet.geometry.y = startPos.y + actualDy;
                    }
                });
            });

            roomGroup.on('dragend', function(e) {
                self.stage.draggable(true);
                // Reset group position (geometry already updated)
                this.x(0);
                this.y(0);

                // Recalculate exterior walls
                markExteriorWalls(doc);

                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });
        }

        this.layers.rooms.add(roomGroup);

        // Room label (inside)
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 16, width: g.width,
            text: room.label, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
            text: room.type, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
        }));

        // Room dimensions (outside) - L x W format
        const widthFt = Math.round(g.width / FOOT);
        const heightFt = Math.round(g.height / FOOT);
        const dimText = `${widthFt}' x ${heightFt}'`;

        // Width dimension (below room)
        this.layers.dims.add(new Konva.Text({
            x: g.x, y: g.y + g.height + 8, width: g.width,
            text: `${widthFt}'-0"`, fontSize: 9, fill: '#6b7280', align: 'center', listening: false
        }));

        // Height dimension (right of room, rotated)
        this.layers.dims.add(new Konva.Text({
            x: g.x + g.width + 12, y: g.y + g.height / 2 + 15,
            text: `${heightFt}'-0"`, fontSize: 9, fill: '#6b7280', rotation: -90, listening: false
        }));
    },

    renderWallSegment(ws, doc, showWallIds) {
        const room = doc.rooms.find(r => r.id === ws.roomId);
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const isExterior = ws.type === 'exterior';

        // Wall group
        const group = new Konva.Group({ id: ws.id });
        this.wallGroups[ws.id] = group;

        // Check if this wall is shared with another room
        const sharedInfo = ws.roomId ? findSharedWallInfo(ws, doc) : null;
        const isShared = sharedInfo && sharedInfo.isShared;

        // Determine wall width
        const wallWidth = isSelected ? 5 : (isExterior ? 4 : 2);

        if (isSelected) {
            // Selected state overrides all other colors
            const visibleLine = new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: WALL_COLOR_SELECTED,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            });
            group.add(visibleLine);
        } else if (isShared) {
            // Dual-stroke rendering for shared walls
            const dx = ws.x2 - ws.x1;
            const dy = ws.y2 - ws.y1;
            const length = Math.sqrt(dx * dx + dy * dy) || 1;

            // Perpendicular unit vector for offset
            const perpX = -dy / length;
            const perpY = dx / length;
            const offset = SHARED_WALL_GAP / 2;

            // Determine colors based on room order (consistent coloring)
            const colorA = sharedInfo.isFirstRoom ? WALL_COLOR_SHARED_A : WALL_COLOR_SHARED_B;
            const colorB = sharedInfo.isFirstRoom ? WALL_COLOR_SHARED_B : WALL_COLOR_SHARED_A;

            // First stroke (offset toward room interior)
            const line1 = new Konva.Line({
                points: [
                    ws.x1 + perpX * offset, ws.y1 + perpY * offset,
                    ws.x2 + perpX * offset, ws.y2 + perpY * offset
                ],
                stroke: colorA,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            });
            group.add(line1);

            // Second stroke (offset away from room interior)
            const line2 = new Konva.Line({
                points: [
                    ws.x1 - perpX * offset, ws.y1 - perpY * offset,
                    ws.x2 - perpX * offset, ws.y2 - perpY * offset
                ],
                stroke: colorB,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            });
            group.add(line2);
        } else {
            // Single stroke for exterior and non-shared interior walls
            const wallColor = isExterior ? WALL_COLOR_EXTERIOR : WALL_COLOR_INTERIOR;
            const visibleLine = new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: wallColor,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            });
            group.add(visibleLine);
        }

        // HIT REGION (invisible, wide stroke for mobile tapping)
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        hitLine.on('pointerdown', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);

        // Wall ID label
        if (showWallIds) {
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? WALL_COLOR_SELECTED : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        }

        this.layers.walls.add(group);
    },

    getLabelOffset(ws, room) {
        if (!room) return { x: 0, y: 0 };
        const g = room.geometry;
        const mid = getSegmentMidpoint(ws);
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: -(dx / dist) * 14, y: -(dy / dist) * 10 };
    },

    renderCloset(closet, doc) {
        const g = closet.geometry;
        const isSelected = this.isSelected('closet', closet.id);
        const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);
        const pg = parentRoom ? parentRoom.geometry : null;

        // Closet fill with light grey
        const rect = new Konva.Rect({
            x: g.x, y: g.y, width: g.width, height: g.height,
            fill: '#f3f4f6', stroke: isSelected ? '#3b82f6' : '#d1d5db', strokeWidth: isSelected ? 2 : 1
        });
        rect.on('tap click', () => App.onObjectTap('closet', closet.id));
        this.layers.openings.add(rect);

        // Diagonal hatch lines (architectural convention for closets)
        const hatchGroup = new Konva.Group({ clip: { x: g.x, y: g.y, width: g.width, height: g.height } });
        const spacing = 12;
        const hatchColor = '#d1d5db';
        for (let i = -g.height; i < g.width + g.height; i += spacing) {
            hatchGroup.add(new Konva.Line({
                points: [g.x + i, g.y, g.x + i + g.height, g.y + g.height],
                stroke: hatchColor, strokeWidth: 1, listening: false
            }));
        }
        this.layers.openings.add(hatchGroup);

        // Draw closet walls and make them clickable for placing doors
        const wallColor = isSelected ? WALL_COLOR_SELECTED : WALL_COLOR_INTERIOR;
        const wallWidth = 2;

        // Get closet's wall segments for hit detection
        const closetWalls = doc.wallSegments.filter(ws => ws.roomId === closet.id);

        // Render closet walls (only interior-facing ones that don't touch parent room edges)
        if (pg) {
            // South wall of closet (if not touching room's south edge)
            if (g.y + g.height < pg.y + pg.height) {
                const southWall = closetWalls.find(w => w.side === 'south');
                if (southWall) {
                    this.renderClosetWall(southWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y + g.height, g.x + g.width, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // North wall of closet (if not touching room's north edge)
            if (g.y > pg.y) {
                const northWall = closetWalls.find(w => w.side === 'north');
                if (northWall) {
                    this.renderClosetWall(northWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y, g.x + g.width, g.y],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // West wall of closet (if not touching room's west edge)
            if (g.x > pg.x) {
                const westWall = closetWalls.find(w => w.side === 'west');
                if (westWall) {
                    this.renderClosetWall(westWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y, g.x, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // East wall of closet (if not touching room's east edge)
            if (g.x + g.width < pg.x + pg.width) {
                const eastWall = closetWalls.find(w => w.side === 'east');
                if (eastWall) {
                    this.renderClosetWall(eastWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x + g.width, g.y, g.x + g.width, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
        }

        // Closet label with parent room indicator
        const parentLabel = parentRoom ? ` → ${parentRoom.label}` : '';
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
            text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#6b7280', align: 'center', listening: false
        }));
        // Show parent room indicator
        if (parentRoom) {
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                text: `(${parentRoom.label})`, fontSize: 8, fill: '#9ca3af', align: 'center', listening: false
            }));
        }

        // Show connection line to parent room when selected
        if (isSelected && parentRoom && pg) {
            const closetCenterX = g.x + g.width / 2;
            const closetCenterY = g.y + g.height / 2;
            const roomCenterX = pg.x + pg.width / 2;
            const roomCenterY = pg.y + pg.height / 2;

            this.layers.dims.add(new Konva.Line({
                points: [closetCenterX, closetCenterY, roomCenterX, roomCenterY],
                stroke: '#3b82f6',
                strokeWidth: 1,
                dash: [4, 4],
                listening: false
            }));
        }
    },

    // Render a closet wall with hit detection for placing doors
    renderClosetWall(ws, wallColor, wallWidth) {
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;

        // Visible wall line
        this.layers.walls.add(new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: isSelected ? WALL_COLOR_SELECTED : wallColor,
            strokeWidth: isSelected ? 4 : wallWidth,
            lineCap: 'round',
            listening: false
        }));

        // Hit region for wall selection and door placement
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);
    },

    renderDoor(door, doc) {
        const ws = doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, door.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isVertical = Math.abs(Math.sin(angle)) > 0.5;
        const isSelected = this.selection.type === 'door' && this.selection.id === door.id;

        const doorGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Door opening (gap in wall) - match room fill color
        const doorRect = new Konva.Rect({
            x: 0, y: -3,
            width: door.width,
            height: 6,
            fill: '#fafbfc',  // Match room fill color
            stroke: 'transparent'
        });
        doorGroup.add(doorRect);

        // Door jambs (thin lines at edges of opening)
        const jambColor = WALL_COLOR_EXTERIOR;
        doorGroup.add(new Konva.Line({
            points: [0, -3, 0, 3],
            stroke: jambColor, strokeWidth: 1
        }));
        doorGroup.add(new Konva.Line({
            points: [door.width, -3, door.width, 3],
            stroke: jambColor, strokeWidth: 1
        }));

        // Door geometry - hinge point and swing direction
        const swingOut = door.swing === 'out' ? -1 : 1;  // in = toward positive y, out = toward negative y
        const hingeLeft = door.swingDir === 'left';      // hinge on left or right side

        // Hinge position (at corner of door opening)
        const hingeX = hingeLeft ? 0 : door.width;
        const hingeY = swingOut * ws.thickness / 2;

        // Door leaf length (slightly less than full width for visual clarity)
        const leafLength = door.width * 0.9;

        // Door leaf end point at 90 degrees (perpendicular to wall, fully open)
        const leafEndX = hingeX;  // Straight perpendicular, no x movement
        const leafEndY = hingeY + swingOut * leafLength;

        // Swing arc (dashed/perforated) - from hinge, showing door swing path
        const swingArc = new Konva.Arc({
            x: hingeX,
            y: hingeY,
            innerRadius: leafLength - 1,
            outerRadius: leafLength,
            angle: 90,
            rotation: hingeLeft ? (swingOut > 0 ? 0 : -90) : (swingOut > 0 ? 90 : 180),
            stroke: '#9ca3af',
            strokeWidth: 1,
            dash: [4, 3]
        });
        doorGroup.add(swingArc);

        // Door leaf (solid line representing the actual door panel)
        const doorLeaf = new Konva.Line({
            points: [hingeX, hingeY, leafEndX, leafEndY],
            stroke: isSelected ? WALL_COLOR_SELECTED : WALL_COLOR_EXTERIOR,
            strokeWidth: 3,
            lineCap: 'round'
        });
        doorGroup.add(doorLeaf);

        // Large invisible hit area for easier selection (covers door opening + swing)
        const hitArea = new Konva.Rect({
            x: -5,
            y: Math.min(hingeY, leafEndY) - 5,
            width: door.width + 10,
            height: Math.abs(leafEndY - hingeY) + 15,
            fill: 'transparent',
            stroke: 'transparent'
        });
        doorGroup.add(hitArea);

        doorGroup.on('tap click', () => App.onObjectTap('door', door.id));
        this.layers.openings.add(doorGroup);

        // Label
        const doorLabel = new Konva.Text({
            x: pos.x + (isVertical ? 12 : 0), y: pos.y + (isVertical ? 0 : -14),
            text: door.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#6b7280', listening: false
        });
        this.layers.labels.add(doorLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, door.distanceFromStart + door.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateDoorVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, door.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);

                // Recalculate door geometry
                const newHingeX = hingeLeft ? 0 : door.width;
                const newLeafLength = door.width * 0.9;
                const newLeafEndX = newHingeX;  // 90 degrees - straight perpendicular
                const newLeafEndY = hingeY + swingOut * newLeafLength;

                // Update door group position and rect width
                doorGroup.x(newPos.x);
                doorGroup.y(newPos.y);
                doorRect.width(door.width);

                // Update swing arc
                swingArc.x(newHingeX);
                swingArc.innerRadius(newLeafLength - 1);
                swingArc.outerRadius(newLeafLength);

                // Update door leaf
                doorLeaf.points([newHingeX, hingeY, newLeafEndX, newLeafEndY]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire door along wall
            doorGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            doorGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const maxOffset = getSegmentLength(ws) - door.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                door.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + door.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            doorGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const oldEnd = door.distanceFromStart + door.width;
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth) {
                    door.width = oldEnd - newOffset;
                    door.distanceFromStart = newOffset;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEnd = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const newWidth = newEnd - door.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches

                if (newWidth >= minWidth && newEnd <= maxOffset) {
                    door.width = newWidth;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderWindow(win, doc) {
        const ws = doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, win.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'window' && this.selection.id === win.id;

        const winGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Window opening (gap in wall) - match room fill color
        const winThickness = 8;  // Thicker window frame
        const winRect = new Konva.Rect({
            x: 0, y: -winThickness / 2,
            width: win.width, height: winThickness,
            fill: '#fafbfc',
            stroke: 'transparent'
        });
        winGroup.add(winRect);

        // Window frame lines (top and bottom sill) - thicker
        const frameColor = isSelected ? '#3b82f6' : '#60a5fa';
        const topSill = new Konva.Line({
            points: [0, -winThickness / 2, win.width, -winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(topSill);

        const bottomSill = new Konva.Line({
            points: [0, winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(bottomSill);

        // Window jambs (ends)
        const leftJamb = new Konva.Line({
            points: [0, -winThickness / 2, 0, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(leftJamb);

        const rightJamb = new Konva.Line({
            points: [win.width, -winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(rightJamb);

        // Mullion (center divider)
        const mullion = new Konva.Line({
            points: [win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2],
            stroke: frameColor, strokeWidth: 1
        });
        winGroup.add(mullion);

        winGroup.on('tap click', () => App.onObjectTap('window', win.id));
        this.layers.openings.add(winGroup);

        const winLabel = new Konva.Text({
            x: pos.x + win.width / 2 - 15, y: pos.y - 14,
            text: win.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#60a5fa', listening: false
        });
        this.layers.labels.add(winLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;  // Mobile-friendly touch target
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, win.distanceFromStart + win.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateWindowVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, win.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);

                // Update window group position
                winGroup.x(newPos.x);
                winGroup.y(newPos.y);

                // Update rect width
                winRect.width(win.width);

                // Update frame lines
                topSill.points([0, -winThickness / 2, win.width, -winThickness / 2]);
                bottomSill.points([0, winThickness / 2, win.width, winThickness / 2]);
                rightJamb.points([win.width, -winThickness / 2, win.width, winThickness / 2]);
                mullion.points([win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire window along wall
            winGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            winGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const maxOffset = getSegmentLength(ws) - win.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                win.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + win.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            winGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const oldEnd = win.distanceFromStart + win.width;
                const minWidth = 1 * FOOT;

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth) {
                    win.width = oldEnd - newOffset;
                    win.distanceFromStart = newOffset;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEnd = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const newWidth = newEnd - win.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 1 * FOOT;

                if (newWidth >= minWidth && newEnd <= maxOffset) {
                    win.width = newWidth;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderCasedOpening(op, doc) {
        const ws = doc.wallSegments.find(s => s.id === op.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, op.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'cased' && this.selection.id === op.id;

        const opGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        // Dashed line "---------"
        opGroup.add(new Konva.Line({
            points: [0, 0, op.width, 0],
            stroke: isSelected ? '#06b6d4' : '#aaa', strokeWidth: 2, dash: [6, 3]
        }));

        opGroup.on('tap click', () => App.onObjectTap('cased', op.id));
        this.layers.openings.add(opGroup);

        this.layers.labels.add(new Konva.Text({
            x: pos.x + op.width / 2 - 10, y: pos.y - 12,
            text: op.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#aaa', listening: false
        }));
    },

    renderMEP(mep, doc) {
        const ws = doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, mep.distanceFromStart);
        const isSelected = this.selection.type === 'mep' && this.selection.id === mep.id;
        const color = isSelected ? '#3b82f6' : (mep.label.startsWith('GAS') ? '#f97316' : mep.label.startsWith('POE') ? '#ef4444' : '#22c55e');

        if (mep.label.startsWith('PIPE')) {
            const shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, stroke: color, strokeWidth: 2, fill: '#fff' });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('GAS')) {
            const shape = new Konva.Circle({ x: pos.x, y: pos.y, radius: 8, fill: color });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('POE')) {
            const shape = new Konva.RegularPolygon({ x: pos.x, y: pos.y, sides: 3, radius: 12, fill: color, rotation: 0 });
            shape.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('RAD')) {
            // Render radiator with fins
            const offset = this.getInteriorOffset(ws, doc);
            const radX = pos.x + offset.x * 0.5;
            const radY = pos.y + offset.y * 0.5 - mep.height / 2;
            const radGroup = new Konva.Group();

            // Main housing
            radGroup.add(new Konva.Rect({
                x: radX, y: radY, width: mep.width, height: mep.height,
                fill: '#f9fafb', stroke: color, strokeWidth: 2, cornerRadius: 3
            }));

            // Vertical fins (radiator style)
            const finCount = Math.max(3, Math.floor(mep.width / 12));
            const finSpacing = mep.width / (finCount + 1);
            const finPadding = 4;
            for (let i = 1; i <= finCount; i++) {
                radGroup.add(new Konva.Line({
                    points: [radX + i * finSpacing, radY + finPadding, radX + i * finSpacing, radY + mep.height - finPadding],
                    stroke: color, strokeWidth: 1.5, opacity: 0.7
                }));
            }

            // Top and bottom horizontal pipes
            radGroup.add(new Konva.Line({
                points: [radX + 4, radY + 6, radX + mep.width - 4, radY + 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));
            radGroup.add(new Konva.Line({
                points: [radX + 4, radY + mep.height - 6, radX + mep.width - 4, radY + mep.height - 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));

            radGroup.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(radGroup);
        } else if (mep.label.startsWith('PRSR')) {
            // Pipe Riser - concentric circles to show vertical pipe
            const offset = this.getInteriorOffset(ws, doc);
            const riserX = pos.x + offset.x * 0.3;
            const riserY = pos.y + offset.y * 0.3;
            const riserGroup = new Konva.Group();

            // Outer circle
            riserGroup.add(new Konva.Circle({
                x: riserX, y: riserY, radius: 12,
                fill: '#f3f4f6', stroke: color, strokeWidth: 2
            }));
            // Inner circle (pipe)
            riserGroup.add(new Konva.Circle({
                x: riserX, y: riserY, radius: 6,
                fill: '#e5e7eb', stroke: color, strokeWidth: 1
            }));

            riserGroup.on('tap click', () => App.onObjectTap('mep', mep.id));
            this.layers.mep.add(riserGroup);
        }

        this.layers.labels.add(new Konva.Text({
            x: pos.x + 14, y: pos.y - 5,
            text: mep.label, fontSize: 8, fill: color, listening: false
        }));
    },

    getPositionOnSegment(seg, distFromStart) {
        const len = getSegmentLength(seg);
        const t = Math.min(distFromStart / len, 1);
        return {
            x: seg.x1 + t * (seg.x2 - seg.x1),
            y: seg.y1 + t * (seg.y2 - seg.y1)
        };
    },

    // Convert a point (x,y) to an offset along a wall segment
    getOffsetOnSegment(seg, px, py) {
        const dx = seg.x2 - seg.x1;
        const dy = seg.y2 - seg.y1;
        const len = getSegmentLength(seg);
        if (len === 0) return 0;

        // Project point onto line segment
        const t = Math.max(0, Math.min(1, ((px - seg.x1) * dx + (py - seg.y1) * dy) / (len * len)));
        return t * len;
    },

    getInteriorOffset(ws, doc) {
        const room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) return { x: 0, y: 0 };
        const mid = getSegmentMidpoint(ws);
        const g = room.geometry;
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    renderDimension(dim) {
        const layer = this.layers.dims;
        const isVert = dim.vertical;
        layer.add(new Konva.Line({ points: [dim.x1, dim.y1, dim.x2, dim.y2], stroke: '#555', strokeWidth: 1 }));
        if (isVert) {
            layer.add(new Konva.Line({ points: [dim.x1 - 4, dim.y1, dim.x1 + 4, dim.y1], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2 - 4, dim.y2, dim.x2 + 4, dim.y2], stroke: '#555', strokeWidth: 1 }));
        } else {
            layer.add(new Konva.Line({ points: [dim.x1, dim.y1 - 4, dim.x1, dim.y1 + 4], stroke: '#555', strokeWidth: 1 }));
            layer.add(new Konva.Line({ points: [dim.x2, dim.y2 - 4, dim.x2, dim.y2 + 4], stroke: '#555', strokeWidth: 1 }));
        }
        const midX = (dim.x1 + dim.x2) / 2, midY = (dim.y1 + dim.y2) / 2;
        layer.add(new Konva.Text({
            x: isVert ? midX - 28 : midX - 18, y: isVert ? midY - 5 : midY - 12,
            text: dim.label, fontSize: 9, fill: '#777', listening: false
        }));
    },

    select(type, id) {
        this.selection = { type, id };
        this.multiSelection = []; // Clear multi-selection when single selecting
    },

    deselect() {
        this.selection = { type: null, id: null };
        this.multiSelection = [];
    },

    // Add to multi-selection
    addToSelection(type, id) {
        if (!this.isInMultiSelection(type, id)) {
            this.multiSelection.push({ type, id });
        }
    },

    // Remove from multi-selection
    removeFromSelection(type, id) {
        this.multiSelection = this.multiSelection.filter(s => !(s.type === type && s.id === id));
    },

    // Check if object is in multi-selection
    isInMultiSelection(type, id) {
        return this.multiSelection.some(s => s.type === type && s.id === id);
    },

    // Check if object is selected (single or multi)
    isSelected(type, id) {
        return (this.selection.type === type && this.selection.id === id) ||
               this.isInMultiSelection(type, id);
    },

    // Select all rooms
    selectAllRooms(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = doc.rooms.map(r => ({ type: 'room', id: r.id }));
    },

    // Select all objects
    selectAll(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = [
            ...doc.rooms.map(r => ({ type: 'room', id: r.id })),
            ...doc.closets.map(c => ({ type: 'closet', id: c.id }))
        ];
    },

    getImage() { return this.stage ? this.stage.toDataURL({ pixelRatio: 2 }) : null; }
};

// ========== QA VALIDATION ==========
function runQA(doc) {
    const results = [];

    // All rooms labeled
    results.push({ rule: 'All rooms labeled', pass: doc.rooms.every(r => r.label), detail: 'OK' });

    // All wall segments have W1=SOUTH
    const badWalls = doc.rooms.filter(r => {
        const segs = doc.wallSegments.filter(ws => ws.roomId === r.id);
        if (segs.length < 4) return true;
        const w1 = segs.find(ws => ws.label === 'W1');
        return !w1;
    });
    results.push({ rule: 'Wall IDs (W1 exists)', pass: badWalls.length === 0, detail: badWalls.length > 0 ? `${badWalls.length} rooms` : 'OK' });

    // Closets
    results.push({ rule: 'Closets (CL-01, CL-02)', pass: doc.closets.length >= 2, detail: `${doc.closets.length} closets` });

    // Doors attached to walls
    const unattachedDoors = doc.doors.filter(d => !d.parentWallSegmentId);
    results.push({ rule: 'Doors attached to walls', pass: unattachedDoors.length === 0, detail: unattachedDoors.length > 0 ? `${unattachedDoors.length} floating` : 'OK' });

    // Windows attached to walls
    const unattachedWindows = doc.windows.filter(w => !w.parentWallSegmentId);
    results.push({ rule: 'Windows attached to walls', pass: unattachedWindows.length === 0, detail: unattachedWindows.length > 0 ? `${unattachedWindows.length} floating` : 'OK' });

    // Windows must be on exterior walls only
    const windowsOnInterior = doc.windows.filter(w => {
        const ws = doc.wallSegments.find(seg => seg.id === w.parentWallSegmentId);
        return ws && ws.type !== 'exterior';
    });
    results.push({ rule: 'Windows on exterior walls', pass: windowsOnInterior.length === 0, detail: windowsOnInterior.length > 0 ? `${windowsOnInterior.length} on interior` : 'OK' });

    // MEP attached (except free-placed)
    const unattachedMEP = doc.mep.filter(m => !m.parentWallSegmentId && !m.freePlaced);
    results.push({ rule: 'MEP attached to walls', pass: unattachedMEP.length === 0, detail: unattachedMEP.length > 0 ? `${unattachedMEP.length} floating` : 'OK' });

    // POE anchored
    const poe = doc.mep.find(m => m.label.startsWith('POE'));
    const entryDoor = doc.doors.find(d => d.type === 'entry');
    results.push({ rule: 'POE anchored to entry', pass: poe && poe.anchorDoorId === entryDoor?.id, detail: poe ? 'OK' : 'Missing' });

    // Dimensions
    results.push({ rule: 'Dimensions present', pass: doc.dimensions.length > 0, detail: `${doc.dimensions.length}` });

    return results;
}

// ========== APP ==========
const App = {
    doc: null,
    currentTool: 'select',
    showGrid: true,
    showWallIds: true,
    showDims: true,
    undoStack: [],
    redoStack: [],
    maxHistory: 50,
    isDrawingRoom: false,
    roomDrawStart: null,
    roomPreview: null,
    isDrawingWall: false,
    wallDrawStart: null,
    wallPreview: null,
    clipboard: [],  // For copy/paste

    init() {
        if (!Render.init('stage')) { alert('Init failed'); return; }
        this.doc = generate2BR1BA();
        this.saveState(); // Save initial state
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateUndoRedoButtons();
        this.setupKeyboardShortcuts();
        this.setupRoomDrawing();
        this.setupWallDrawing();
        console.log('App ready - tap walls to select');
    },

    setupRoomDrawing() {
        const stage = Render.stage;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'room') return;

            // Disable stage panning while drawing
            stage.draggable(false);

            const pos = stage.getPointerPosition();
            this.isDrawingRoom = true;
            this.roomDrawStart = { x: pos.x, y: pos.y };

            // Create preview rectangle
            this.roomPreview = new Konva.Rect({
                x: pos.x,
                y: pos.y,
                width: 0,
                height: 0,
                fill: 'rgba(59, 130, 246, 0.1)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [5, 5]
            });
            Render.layers.openings.add(this.roomPreview);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.roomDrawStart;

            // Calculate dimensions
            const x = Math.min(start.x, pos.x);
            const y = Math.min(start.y, pos.y);
            const width = Math.abs(pos.x - start.x);
            const height = Math.abs(pos.y - start.y);

            this.roomPreview.x(x);
            this.roomPreview.y(y);
            this.roomPreview.width(width);
            this.roomPreview.height(height);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.roomDrawStart;

            // Calculate final dimensions
            const x = Math.min(start.x, pos.x);
            const y = Math.min(start.y, pos.y);
            const width = Math.abs(pos.x - start.x);
            const height = Math.abs(pos.y - start.y);

            // Remove preview
            this.roomPreview.destroy();
            this.roomPreview = null;
            this.isDrawingRoom = false;
            stage.draggable(true);

            // Minimum size check (at least 2' x 2')
            if (width < 2 * FOOT || height < 2 * FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Check if drawing is inside an existing room (create closet) or outside (create room)
            const parentRoom = this.doc.rooms.find(room => {
                const g = room.geometry;
                // Check if the drawn rectangle is mostly inside this room
                const overlapX = Math.max(0, Math.min(x + width, g.x + g.width) - Math.max(x, g.x));
                const overlapY = Math.max(0, Math.min(y + height, g.y + g.height) - Math.max(y, g.y));
                const overlapArea = overlapX * overlapY;
                const drawnArea = width * height;
                return overlapArea > drawnArea * 0.5; // More than 50% inside room
            });

            if (parentRoom) {
                // Create a closet inside the room (closet is a sub-room with parent link)
                const closet = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'closet'),
                    type: 'Closet',
                    roomType: 'Closet',  // Distinguishes from regular Room
                    parentRoomId: parentRoom.id,
                    parentRoomLabel: parentRoom.label,
                    isExterior: false,
                    geometry: { x, y, width, height }
                };
                // Create wall segments for the closet (like a room)
                createWallSegments(closet, this.doc);
                this.doc.closets.push(closet);
                Render.select('closet', closet.id);
            } else {
                // Create a new room
                if (width < 4 * FOOT || height < 4 * FOOT) {
                    // Room needs to be at least 4x4
                    Render.layers.openings.batchDraw();
                    return;
                }
                const room = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'room'),
                    type: 'Room',
                    isExterior: true,
                    geometry: { x, y, width, height }
                };
                createWallSegments(room, this.doc);
                this.doc.rooms.push(room);
                markExteriorWalls(this.doc);
            }

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            this.updateInspector();
            this.setTool('select');
        });
    },

    setupWallDrawing() {
        const stage = Render.stage;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'wall') return;

            stage.draggable(false);

            const pos = stage.getPointerPosition();
            // Snap start point to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            this.isDrawingWall = true;
            this.wallDrawStart = { x: snappedX, y: snappedY };

            // Create preview line
            this.wallPreview = new Konva.Line({
                points: [snappedX, snappedY, snappedX, snappedY],
                stroke: WALL_COLOR_EXTERIOR,
                strokeWidth: 4,
                lineCap: 'round',
                dash: [8, 4]
            });
            Render.layers.openings.add(this.wallPreview);

            // Add start point indicator
            this.wallStartPoint = new Konva.Circle({
                x: snappedX,
                y: snappedY,
                radius: 6,
                fill: '#3b82f6'
            });
            Render.layers.openings.add(this.wallStartPoint);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.wallDrawStart;

            // Snap end point to grid
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical (whichever is dominant)
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y; // Horizontal line
            } else {
                endX = start.x; // Vertical line
            }

            this.wallPreview.points([start.x, start.y, endX, endY]);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = stage.getPointerPosition();
            const start = this.wallDrawStart;

            // Snap end point
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y;
            } else {
                endX = start.x;
            }

            // Remove preview
            this.wallPreview.destroy();
            this.wallPreview = null;
            if (this.wallStartPoint) {
                this.wallStartPoint.destroy();
                this.wallStartPoint = null;
            }
            this.isDrawingWall = false;
            stage.draggable(true);

            // Minimum length check (at least 1 foot)
            const length = Math.sqrt(Math.pow(endX - start.x, 2) + Math.pow(endY - start.y, 2));
            if (length < FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Create standalone wall segment
            const isHorizontal = Math.abs(endY - start.y) < 2;
            const ws = {
                id: Doc.uid(),
                roomId: null,  // Standalone wall
                roomLabel: null,
                index: 0,
                label: 'W-' + (this.doc.wallSegments.filter(w => !w.roomId).length + 1),
                side: isHorizontal ? (start.y < 400 ? 'north' : 'south') : (start.x < 400 ? 'west' : 'east'),
                x1: start.x, y1: start.y,
                x2: endX, y2: endY,
                thickness: WALL_EXT,
                type: 'exterior',
                attachedObjects: []
            };
            this.doc.wallSegments.push(ws);

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            Render.select('wall', ws.id);
            this.updateInspector();
        });
    },

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Undo: Ctrl+Z or Cmd+Z
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
            }
            // Redo: Ctrl+Y or Cmd+Y or Ctrl+Shift+Z
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                this.redo();
            }
            // Select All: Ctrl+A or Cmd+A
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                this.selectAll();
            }
            // Copy: Ctrl+C or Cmd+C
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                this.copySelected();
            }
            // Paste: Ctrl+V or Cmd+V
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                this.paste();
            }
        });
    },

    saveState() {
        // Deep clone current document state
        const state = JSON.stringify(this.doc);
        this.undoStack.push(state);
        // Limit history size
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        // Clear redo stack when new action is performed
        this.redoStack = [];
        this.updateUndoRedoButtons();
    },

    undo() {
        if (this.undoStack.length <= 1) return; // Keep at least initial state
        // Move current state to redo stack
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        // Restore previous state
        const prevState = this.undoStack[this.undoStack.length - 1];
        this.doc = JSON.parse(prevState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    redo() {
        if (this.redoStack.length === 0) return;
        // Pop from redo and push to undo
        const nextState = this.redoStack.pop();
        this.undoStack.push(nextState);
        // Restore the state
        this.doc = JSON.parse(nextState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    updateUndoRedoButtons() {
        const undoBtn = $('#btnUndo');
        const redoBtn = $('#btnRedo');
        if (undoBtn) {
            undoBtn.disabled = this.undoStack.length <= 1;
            undoBtn.style.opacity = this.undoStack.length <= 1 ? '0.4' : '1';
        }
        if (redoBtn) {
            redoBtn.disabled = this.redoStack.length === 0;
            redoBtn.style.opacity = this.redoStack.length === 0 ? '0.4' : '1';
        }
    },

    newDoc() {
        this.doc = generate2BR1BA();
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    render() {
        Render.render(this.doc, { showWallIds: this.showWallIds, showDims: this.showDims });
    },

    onWallTap(wallSegmentId) {
        const ws = this.doc.wallSegments.find(s => s.id === wallSegmentId);
        if (!ws) return;

        if (this.currentTool === 'select') {
            Render.select('wall', wallSegmentId);
            this.render();
            this.updateInspector();
            this.highlightTreeItem('wall', wallSegmentId);
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(this.currentTool)) {
            this.placeOnWall(ws, this.currentTool);
        }
    },

    onObjectTap(type, id) {
        Render.select(type, id);
        this.render();
        this.updateInspector();
        this.highlightTreeItem(type, id);
    },

    onRoomTap(roomId) {
        if (this.currentTool === 'select') {
            Render.select('room', roomId);
            this.render();
            this.updateInspector();
        }
    },

    placeOnWall(ws, toolType) {
        const room = this.doc.rooms.find(r => r.id === ws.roomId);
        const segLen = getSegmentLength(ws);
        const defaultOffset = segLen * 0.3;

        // Windows can ONLY be placed on exterior walls
        if (toolType === 'window' && ws.type !== 'exterior') {
            alert(`Windows can only be placed on exterior walls.\n${room?.label} ${ws.label} is an interior wall.`);
            return;
        }

        let obj;
        switch (toolType) {
            case 'door':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'door'), type: 'interior',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 2.67 * FOOT, swing: 'in', swingDir: 'left'
                };
                this.doc.doors.push(obj);
                break;
            case 'window':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'window'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT, sillHeight: 36 * INCH
                };
                this.doc.windows.push(obj);
                break;
            case 'cased':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'cased'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT
                };
                this.doc.casedOpenings.push(obj);
                break;
            case 'pipe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'pipe'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
            case 'gas':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'gas'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
            case 'radiator':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'radiator'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT, height: 1 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'riser':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'riser'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 0.5 * FOOT, height: 0.5 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'poe':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'poe'), type: 'entry',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset
                };
                this.doc.mep.push(obj);
                break;
        }

        if (obj) {
            ws.attachedObjects.push({ type: toolType, id: obj.id, label: obj.label });
            Render.select(toolType === 'door' || toolType === 'window' || toolType === 'cased' ? toolType : 'mep', obj.id);
            this.saveState();
            this.render();
            this.updateTree();
            this.updateInspector();
            this.updateQABadge();
            this.setTool('select');
        }
    },

    setTool(tool) {
        this.currentTool = tool;
        $$('.tool-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.tool-btn[onclick*="'${tool}'"]`);
        if (btn) btn.classList.add('active');
        $('#btnSelect').classList.toggle('active', tool === 'select');

        // Show hint for placement tools
        const hint = $('#toolHint');
        if (tool === 'room') {
            hint.textContent = 'Drag to draw room (outside) or closet (inside room)';
            hint.classList.add('show');
        } else if (tool === 'wall') {
            hint.textContent = 'Click and drag to draw wall (snaps to grid)';
            hint.classList.add('show');
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(tool)) {
            const toolName = tool === 'riser' ? 'PIPE RISER' : tool.toUpperCase();
            hint.textContent = `Tap a wall to place ${toolName}`;
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }
    },

    updateInspector() {
        // Update delete button state based on selection
        const sel = Render.selection;
        const deleteBtn = $('#deleteBtn');
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];

        // Also allow deleting standalone walls (walls without roomId)
        let canDelete = sel.type && sel.id && deletableTypes.includes(sel.type);
        if (sel.type === 'wall' && sel.id) {
            const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
            if (wall && !wall.roomId) {
                canDelete = true;  // Standalone wall can be deleted
            }
        }

        if (deleteBtn) {
            deleteBtn.disabled = !canDelete;
            deleteBtn.style.opacity = canDelete ? '1' : '0.4';
        }
    },

    deleteSelected() {
        const sel = Render.selection;
        if (sel.type && sel.id) {
            this.deleteObject(sel.id, sel.type);
        }
    },

    deleteObject(objId, objType) {
        // Handle standalone wall deletion
        if (objType === 'wall') {
            const wall = this.doc.wallSegments.find(ws => ws.id === objId);
            if (wall && !wall.roomId) {
                // Only delete standalone walls (not part of a room)
                const index = this.doc.wallSegments.findIndex(ws => ws.id === objId);
                if (index !== -1) {
                    this.doc.wallSegments.splice(index, 1);
                    this.saveState();
                    Render.deselect();
                    this.render();
                    this.updateTree();
                    this.updateInspector();
                    this.updateQABadge();
                }
            }
            return;
        }

        // Only allow deleting actual objects, not rooms
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
        if (!deletableTypes.includes(objType)) {
            return;  // Silently ignore non-deletable types
        }

        let collection, index;
        if (objType === 'door') {
            collection = this.doc.doors;
        } else if (objType === 'window') {
            collection = this.doc.windows;
        } else if (objType === 'cased') {
            collection = this.doc.casedOpenings;
        } else if (objType === 'closet') {
            collection = this.doc.closets;
        } else if (objType === 'mep') {
            collection = this.doc.mep;
        }

        if (collection) {
            index = collection.findIndex(o => o.id === objId);
            if (index !== -1) {
                const obj = collection[index];
                // Remove from wall's attachedObjects
                if (obj.parentWallSegmentId) {
                    const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
                    if (ws) {
                        ws.attachedObjects = ws.attachedObjects.filter(a => a.id !== objId);
                    }
                }
                // Remove from collection
                collection.splice(index, 1);

                // Clear selection and save state
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
        }
    },

    updateObjectWidth(objId, objType, newWidthFeet) {
        const width = parseFloat(newWidthFeet) * FOOT;
        if (isNaN(width) || width < 1 * FOOT || width > 12 * FOOT) {
            alert('Width must be between 1 and 12 feet');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            obj.width = width;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateObjectOffset(objId, objType, newOffsetFeet) {
        const offset = parseFloat(newOffsetFeet) * FOOT;
        if (isNaN(offset) || offset < 0) {
            alert('Offset must be 0 or greater');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;
        else if (objType === 'mep') collection = this.doc.mep;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            // Validate offset doesn't exceed wall length
            const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
            if (ws) {
                const maxOffset = getSegmentLength(ws) - (obj.width || 0);
                if (offset > maxOffset) {
                    alert(`Offset too large. Max: ${(maxOffset / FOOT).toFixed(1)} ft`);
                    return;
                }
            }
            obj.distanceFromStart = offset;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateTree() {
        const tree = $('#objectTree');
        tree.innerHTML = '';

        const addGroup = (title, items, color, type) => {
            if (items.length === 0) return;
            const grp = document.createElement('div');
            grp.className = 'tree-group';
            grp.innerHTML = `<div class="tree-label">${title} (${items.length})</div>`;
            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'tree-item';
                el.dataset.type = type;
                el.dataset.id = item.id;
                const ws = this.doc.wallSegments.find(s => s.id === item.parentWallSegmentId);
                const wallInfo = ws ? ` → ${ws.label}` : '';
                el.innerHTML = `<div class="tree-dot" style="background:${color}"></div><span>${item.label}${item.type ? ' (' + item.type + ')' : ''}${wallInfo}</span>`;
                el.onclick = () => this.onObjectTap(type, item.id);
                grp.appendChild(el);
            });
            tree.appendChild(grp);
        };

        // Rooms with wall segments and child closets
        if (this.doc.rooms.length > 0) {
            const roomGrp = document.createElement('div');
            roomGrp.className = 'tree-group';
            roomGrp.innerHTML = `<div class="tree-label">ROOMS (${this.doc.rooms.length})</div>`;
            this.doc.rooms.forEach(room => {
                const roomEl = document.createElement('div');
                roomEl.className = 'tree-item';
                roomEl.dataset.type = 'room';
                roomEl.dataset.id = room.id;
                roomEl.innerHTML = `<div class="tree-dot" style="background:#f4d03f"></div><span>${room.label} - ${room.type}</span>`;
                roomEl.onclick = () => this.onObjectTap('room', room.id);
                roomGrp.appendChild(roomEl);

                // Wall segments under room
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    const wsEl = document.createElement('div');
                    wsEl.className = 'tree-item';
                    wsEl.style.paddingLeft = '20px';
                    wsEl.dataset.type = 'wall';
                    wsEl.dataset.id = ws.id;
                    wsEl.innerHTML = `<div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>${ws.label} (${ws.side}) [${ws.attachedObjects.length}]</span>`;
                    wsEl.onclick = () => this.onWallTap(ws.id);
                    roomGrp.appendChild(wsEl);
                });

                // Child closets under room
                const childClosets = this.doc.closets.filter(c => c.parentRoomId === room.id);
                childClosets.forEach(closet => {
                    const closetEl = document.createElement('div');
                    closetEl.className = 'tree-item';
                    closetEl.style.paddingLeft = '20px';
                    closetEl.dataset.type = 'closet';
                    closetEl.dataset.id = closet.id;
                    closetEl.innerHTML = `<div class="tree-dot" style="background:#9ca3af"></div><span>↳ ${closet.label} (Closet)</span>`;
                    closetEl.onclick = () => this.onObjectTap('closet', closet.id);
                    roomGrp.appendChild(closetEl);

                    // Closet's wall segments
                    const closetSegs = this.doc.wallSegments.filter(ws => ws.roomId === closet.id);
                    closetSegs.forEach(ws => {
                        const wsEl = document.createElement('div');
                        wsEl.className = 'tree-item';
                        wsEl.style.paddingLeft = '36px';
                        wsEl.dataset.type = 'wall';
                        wsEl.dataset.id = ws.id;
                        wsEl.innerHTML = `<div class="tree-dot" style="background:#aaa;width:5px;height:5px"></div><span>${ws.label} (${ws.side})</span>`;
                        wsEl.onclick = () => this.onWallTap(ws.id);
                        roomGrp.appendChild(wsEl);
                    });
                });
            });
            tree.appendChild(roomGrp);
        }

        // Orphan closets (no parent room)
        const orphanClosets = this.doc.closets.filter(c => !c.parentRoomId || !this.doc.rooms.find(r => r.id === c.parentRoomId));
        if (orphanClosets.length > 0) {
            addGroup('UNLINKED CLOSETS', orphanClosets, '#ef4444', 'closet');
        }

        addGroup('DOORS', this.doc.doors, '#3b82f6', 'door');
        addGroup('WINDOWS', this.doc.windows, '#87ceeb', 'window');
        addGroup('OPENINGS', this.doc.casedOpenings, '#aaa', 'cased');
        addGroup('MEP', this.doc.mep, '#22c55e', 'mep');
    },

    highlightTreeItem(type, id) {
        $$('.tree-item').forEach(el => el.classList.remove('selected'));
        const el = document.querySelector(`.tree-item[data-type="${type}"][data-id="${id}"]`);
        if (el) el.classList.add('selected');
    },

    toggle(what) {
        switch (what) {
            case 'grid': this.showGrid = !this.showGrid; $('#btnGrid').classList.toggle('active', this.showGrid); Render.layers.grid.visible(this.showGrid); break;
            case 'wallIds': this.showWallIds = !this.showWallIds; $('#btnWallIds').classList.toggle('active', this.showWallIds); this.render(); break;
            case 'dims': this.showDims = !this.showDims; $('#btnDims').classList.toggle('active', this.showDims); this.render(); break;
        }
        Render.stage.batchDraw();
    },

    toggleSidebar() { $('#sidebarLeft').classList.toggle('collapsed'); },

    toggleObjectPanel() {
        const tree = $('#objectTree');
        const toggle = $('#objectToggle');
        tree.classList.toggle('collapsed');
        toggle.textContent = tree.classList.contains('collapsed') ? '▶' : '▼';
    },

    resetView() {
        Render.stage.scale({ x: 1, y: 1 });
        Render.stage.position({ x: 0, y: 0 });
        Render.stage.batchDraw();
    },

    // Select all rooms and closets
    selectAll() {
        Render.selectAll(this.doc);
        this.render();
        this.updateInspector();
    },

    // Copy selected objects to clipboard
    copySelected() {
        this.clipboard = [];

        // Get all selected items (single or multi)
        const selected = Render.multiSelection.length > 0
            ? Render.multiSelection
            : (Render.selection.type ? [Render.selection] : []);

        if (selected.length === 0) {
            alert('Nothing selected to copy');
            return;
        }

        selected.forEach(sel => {
            if (sel.type === 'room') {
                const room = this.doc.rooms.find(r => r.id === sel.id);
                if (room) {
                    this.clipboard.push({
                        type: 'room',
                        data: JSON.parse(JSON.stringify(room))
                    });
                }
            } else if (sel.type === 'closet') {
                const closet = this.doc.closets.find(c => c.id === sel.id);
                if (closet) {
                    this.clipboard.push({
                        type: 'closet',
                        data: JSON.parse(JSON.stringify(closet))
                    });
                }
            }
        });

        const hint = $('#toolHint');
        hint.textContent = `Copied ${this.clipboard.length} item(s). Press Ctrl+V to paste.`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    // Paste from clipboard
    paste() {
        if (this.clipboard.length === 0) {
            alert('Nothing to paste');
            return;
        }

        const offset = 2 * FOOT; // Offset pasted items

        this.clipboard.forEach(item => {
            if (item.type === 'room') {
                const newRoom = JSON.parse(JSON.stringify(item.data));
                newRoom.id = Doc.uid();
                newRoom.label = Doc.label(this.doc, 'room');
                newRoom.geometry.x += offset;
                newRoom.geometry.y += offset;
                createWallSegments(newRoom, this.doc);
                this.doc.rooms.push(newRoom);
                markExteriorWalls(this.doc);
            } else if (item.type === 'closet') {
                const newCloset = JSON.parse(JSON.stringify(item.data));
                newCloset.id = Doc.uid();
                newCloset.label = Doc.label(this.doc, 'closet');
                newCloset.geometry.x += offset;
                newCloset.geometry.y += offset;
                createWallSegments(newCloset, this.doc);
                this.doc.closets.push(newCloset);
            }
        });

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        const hint = $('#toolHint');
        hint.textContent = `Pasted ${this.clipboard.length} item(s)`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    updateQABadge() {
        const results = runQA(this.doc);
        const fails = results.filter(r => !r.pass).length;
        const badge = $('#qaBadge');
        badge.textContent = fails === 0 ? 'QA: PASS' : `QA: ${fails} errors`;
        badge.className = 'qa-badge' + (fails > 0 ? ' error' : '');
    },

    showQA() {
        const results = runQA(this.doc);
        $('#qaContent').innerHTML = results.map(r => `
            <div class="qa-item">
                <span class="${r.pass ? 'qa-pass' : 'qa-fail'}">${r.pass ? '✓' : '✗'}</span>
                <span>${r.rule}</span>
                <span style="color:#888;margin-left:auto">${r.detail}</span>
            </div>
        `).join('');
        $('#qaModal').classList.add('show');
    },

    hideModal(which) { $(`#${which}Modal`).classList.remove('show'); },

    loadFBG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                this.doc = this.importFBG(data);
                this.undoStack = [];
                this.redoStack = [];
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateQABadge();
                this.updateInspector();
                this.updateUndoRedoButtons();
            } catch (err) { alert('Load error: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    },

    importFBG(data) {
        const doc = Doc.create();
        doc.address = data.address || '';
        const level = data.levels?.[data.currentLevelIndex || 0];
        if (!level) return doc;

        const objs = level.canvasObjects || [];
        let minX = Infinity, minY = Infinity;
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                minX = Math.min(minX, o.startX || 0, o.endX || 0);
                minY = Math.min(minY, o.startY || 0, o.endY || 0);
            }
        });
        const offX = isFinite(minX) ? 60 - minX : 0;
        const offY = isFinite(minY) ? 60 - minY : 0;

        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                if (isCloset) {
                    doc.closets.push({ id: Doc.uid(), label: Doc.label(doc, 'closet'), fbgName: o.name, geometry: { x, y, width: w, height: h } });
                } else {
                    const room = { id: Doc.uid(), label: Doc.label(doc, 'room'), type: rt.name || abbr, fbgName: o.name, isExterior: true, geometry: { x, y, width: w, height: h } };
                    createWallSegments(room, doc);
                    doc.rooms.push(room);
                }
            }
        });
        return doc;
    },

    exportPDF() {
        const qa = runQA(this.doc);
        const fails = qa.filter(r => !r.pass).length;
        if (fails > 0 && !confirm(`QA has ${fails} errors. Export anyway?`)) return;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'pt', 'letter');

        pdf.setFontSize(14);
        pdf.text('2BR/1BA Blueprint - Wall Segment Attachments', 40, 30);
        pdf.setFontSize(9);
        pdf.text(`Address: ${this.doc.address}`, 40, 45);
        pdf.text(`Date: ${new Date().toLocaleDateString()}`, 40, 57);
        pdf.text(`Rooms: ${this.doc.rooms.length} | Doors: ${this.doc.doors.length} | Windows: ${this.doc.windows.length}`, 40, 69);
        pdf.text(`QA: ${fails === 0 ? 'PASS' : fails + ' errors'}`, 300, 45);

        const img = Render.getImage();
        if (img) pdf.addImage(img, 'PNG', 40, 85, 700, 420);

        pdf.setFontSize(7);
        pdf.text('Wall IDs: W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south-most wall)', 40, 520);

        // Attachment summary
        let y = 535;
        pdf.setFontSize(8);
        pdf.text('Attachments:', 40, y);
        y += 10;
        this.doc.wallSegments.forEach(ws => {
            if (ws.attachedObjects.length > 0) {
                const room = this.doc.rooms.find(r => r.id === ws.roomId);
                const items = ws.attachedObjects.map(a => a.label).join(', ');
                pdf.text(`${room?.label} ${ws.label}: ${items}`, 50, y);
                y += 9;
                if (y > 580) { y = 535; pdf.addPage(); }
            }
        });

        pdf.save(`Blueprint_WallAttach_${new Date().toISOString().split('T')[0]}.pdf`);
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// Keyboard shortcut for delete (objects and standalone walls)
document.addEventListener('keydown', (e) => {
    const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
    if ((e.key === 'Delete' || e.key === 'Backspace') && Render.selection.type && Render.selection.id) {
        // Don't delete if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // Check if it's a deletable type or a standalone wall
        let canDelete = deletableTypes.includes(Render.selection.type);
        if (Render.selection.type === 'wall') {
            const wall = App.doc.wallSegments.find(ws => ws.id === Render.selection.id);
            canDelete = wall && !wall.roomId;  // Only standalone walls
        }

        if (!canDelete) return;
        e.preventDefault();
        App.deleteObject(Render.selection.id, Render.selection.type);
    }
});
</script>
</body>
</html>
