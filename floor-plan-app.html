<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Blueprint Builder - Wall Segment Selection</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-canvas: #ffffff;
            --bg-panel: rgba(245, 247, 250, 0.92);
            --bg-tool: rgba(255, 255, 255, 0.8);
            --bg-tool-hover: rgba(59, 130, 246, 0.1);
            --border: transparent;
            --text: #1f2937;
            --text-dim: #6b7280;
            --accent: #2563eb;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
            --wall-color: #2d3748;
            --grid-color: #bfdbfe;
            --grid-major: #93c5fd;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif; background: var(--bg-canvas); color: var(--text); height: 100vh; height: 100dvh; overflow: hidden; touch-action: none; }
        .app { display: flex; flex-direction: column; height: 100%; }

        .main { display: flex; flex: 1; overflow: hidden; position: relative; height: 100%; }

        .sidebar-left { width: 180px; background: rgba(245, 247, 250, 0.75); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border-right: none; display: flex; flex-direction: column; overflow: hidden; transition: width 0.2s ease; position: relative; z-index: 10; }
        .sidebar-left.collapsed { width: 52px; }
        .sidebar-left.collapsed .sidebar-scroll { padding: 4px; }
        .sidebar-left.collapsed .section-header { display: none; }
        .sidebar-left.collapsed .section-content { padding: 2px; }
        .sidebar-left.collapsed .tool-grid { grid-template-columns: 1fr; gap: 4px; }
        .sidebar-left.collapsed .tool-btn { min-height: 40px; padding: 6px; }
        .sidebar-left.collapsed .tool-btn span { display: none; }
        .sidebar-left.collapsed .tool-btn svg { margin-bottom: 0; }
        .sidebar-left.collapsed #objectSection { display: none; }
        .sidebar-left.collapsed .sidebar-toggle { writing-mode: vertical-rl; text-orientation: mixed; padding: 12px 8px; }
        .sidebar-toggle { padding: 10px; background: transparent; border: none; color: var(--accent); font-size: 16px; cursor: pointer; border-bottom: none; }
        .sidebar-scroll { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 8px; }
        .sidebar-scroll::-webkit-scrollbar { width: 4px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 2px; }
        .section { margin-bottom: 12px; }
        .section-header { padding: 6px 8px; font-size: 9px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .section-content { padding: 4px; }
        .section-content.collapsed { display: none; }

        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .tool-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px 4px; background: var(--bg-tool); border: none; border-radius: 10px; color: var(--text); font-size: 8px; font-weight: 500; cursor: pointer; min-height: 48px; transition: all 0.15s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .tool-btn:hover { background: var(--bg-tool-hover); transform: translateY(-1px); }
        .tool-btn:active, .tool-btn.active { background: var(--accent-blue); color: white; }
        .tool-btn svg { width: 20px; height: 20px; margin-bottom: 3px; }
        .tool-btn svg * { stroke: currentColor; fill: none; stroke-width: 1.5; }
        .tool-btn.filled svg * { fill: currentColor; stroke: none; }

        .tree-group { margin-bottom: 8px; }
        .tree-label { font-size: 9px; color: var(--accent); padding: 4px 8px; font-weight: 600; }
        .tree-item { display: flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 10px; cursor: pointer; border-radius: 6px; transition: background 0.1s; }
        .tree-item:hover { background: var(--bg-tool-hover); }
        .tree-item:active, .tree-item.selected { background: rgba(59,130,246,0.2); }
        .tree-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }

        .canvas-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
            /* Static blueprint grid background */
            background-color: #f0f7ff;
            background-image:
                linear-gradient(rgba(59, 130, 246, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.08) 1px, transparent 1px),
                linear-gradient(rgba(59, 130, 246, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(59, 130, 246, 0.15) 1px, transparent 1px);
            background-size: 12px 12px, 12px 12px, 48px 48px, 48px 48px;
            background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
            background-attachment: fixed;
        }
        #stage { width: 100%; height: 100%; }
        .north-arrow { position: absolute; top: 12px; right: 12px; width: 44px; height: 44px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--accent); border: 2px solid var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.3s ease; }
        .north-arrow svg { width: 28px; height: 28px; transition: transform 0.3s ease; }
        .north-arrow .arrow-n { fill: var(--accent-red); }
        .north-arrow .arrow-s { fill: #666; }
        .north-arrow:hover { transform: scale(1.05); }
        .scale-label { position: absolute; bottom: 12px; left: 12px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); padding: 6px 12px; border-radius: 6px; font-size: 10px; color: var(--text-dim); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .qa-badge { position: absolute; top: 12px; left: 12px; background: var(--accent-green); color: #fff; padding: 5px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .qa-badge.error { background: var(--accent-red); }
        .tool-hint { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 10px; font-size: 11px; color: var(--accent); display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .tool-hint.show { display: block; }

        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal.show { display: flex; }
        .modal-box { background: white; border: none; border-radius: 16px; max-width: 420px; width: 100%; max-height: 80vh; overflow: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
        .modal-head { padding: 16px 20px; border-bottom: 1px solid #f3f4f6; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 15px; font-weight: 600; color: var(--text); }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; }
        .modal-body { padding: 20px; font-size: 12px; }
        .qa-item { padding: 8px 0; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; gap: 10px; }
        .qa-pass { color: var(--accent-green); }
        .qa-fail { color: var(--accent-red); }

        @media (max-width: 768px) {
            /* Mobile: sidebar starts expanded, toggle works via .collapsed class */
            .sidebar-left { width: 160px; }
            .sidebar-left .tool-grid { grid-template-columns: 1fr 1fr; gap: 4px; }
            .sidebar-left .tool-btn { min-height: 44px; padding: 6px; }
            .sidebar-left .tool-btn span { font-size: 7px; }
            .sidebar-left #objectSection { display: none; }
            /* Mobile collapsed state */
            .sidebar-left.collapsed { width: 48px; }
            .sidebar-left.collapsed .sidebar-scroll { padding: 4px; }
            .sidebar-left.collapsed .section-header { display: none; }
            .sidebar-left.collapsed .section-content { padding: 2px; }
            .sidebar-left.collapsed .tool-grid { grid-template-columns: 1fr; }
            .sidebar-left.collapsed .tool-btn span { display: none; }
            .sidebar-left.collapsed .tool-btn svg { margin-bottom: 0; }
            .north-arrow { width: 36px; height: 36px; top: 8px; right: 8px; }
            .north-arrow svg { width: 22px; height: 22px; }
            .scale-label { font-size: 9px; padding: 4px 8px; bottom: 8px; left: 8px; }
            .qa-badge { font-size: 9px; padding: 4px 10px; top: 8px; left: 8px; }
            .tool-hint { font-size: 10px; padding: 8px 14px; bottom: 40px; }
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
<div class="app">
    <input type="file" id="fbgInput" accept=".fbg,.fgs,.json" onchange="App.loadFBG(event)">
    <div class="main">
        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-toggle" onclick="App.toggleSidebar()">☰</button>
            <div class="sidebar-scroll">
                <div class="section">
                    <div class="section-header">File</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.newDoc()" title="New document">
                                <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"/><polyline points="14,2 14,8 20,8" stroke="currentColor" fill="none" stroke-width="2"/><line x1="12" y1="18" x2="12" y2="12" stroke="currentColor" stroke-width="2"/><line x1="9" y1="15" x2="15" y2="15" stroke="currentColor" stroke-width="2"/></svg>
                                <span>New</span>
                            </button>
                            <button class="tool-btn" onclick="$('#fbgInput').click()" title="Load file">
                                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4" stroke="currentColor" fill="none" stroke-width="2"/><polyline points="17,8 12,3 7,8" stroke="currentColor" fill="none" stroke-width="2"/><line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2"/></svg>
                                <span>Load</span>
                            </button>
                            <button class="tool-btn" onclick="App.exportPDF()" title="Export PDF">
                                <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"/><polyline points="14,2 14,8 20,8" stroke="currentColor" fill="none" stroke-width="2"/><text x="8" y="17" font-size="6" fill="currentColor" stroke="none">PDF</text></svg>
                                <span>PDF</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Geometry (draw)</div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr;">
                            <button class="tool-btn" onclick="App.setTool('room')"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1" stroke-dasharray="3,2"/><line x1="12" y1="8" x2="12" y2="16" stroke-width="2"/><line x1="8" y1="12" x2="16" y2="12" stroke-width="2"/></svg><span>Room</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Openings (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('door')"><svg viewBox="0 0 24 24"><rect x="6" y="3" width="12" height="18" rx="1"/><circle cx="15" cy="12" r="1.5" fill="currentColor"/></svg><span>Door</span></button>
                            <button class="tool-btn" onclick="App.setTool('window')"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="1"/><line x1="12" y1="7" x2="12" y2="17"/></svg><span>Window</span></button>
                            <button class="tool-btn" onclick="App.setTool('cased')"><svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3,2"/></svg><span>Cased</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Display</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn active" id="btnDims" onclick="App.toggle('dims')" title="Toggle dimensions">
                                <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12" stroke="currentColor" stroke-width="2"/><line x1="3" y1="8" x2="3" y2="16" stroke="currentColor" stroke-width="2"/><line x1="21" y1="8" x2="21" y2="16" stroke="currentColor" stroke-width="2"/><text x="9" y="10" font-size="6" fill="currentColor" stroke="none">12'</text></svg>
                                <span>Dims</span>
                            </button>
                            <button class="tool-btn active" id="btnGrid" onclick="App.toggle('grid')" title="Toggle grid">
                                <svg viewBox="0 0 24 24"><line x1="3" y1="3" x2="3" y2="21" stroke="currentColor" stroke-width="1.5"/><line x1="9" y1="3" x2="9" y2="21" stroke="currentColor" stroke-width="1.5"/><line x1="15" y1="3" x2="15" y2="21" stroke="currentColor" stroke-width="1.5"/><line x1="21" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="1.5"/><line x1="3" y1="3" x2="21" y2="3" stroke="currentColor" stroke-width="1.5"/><line x1="3" y1="9" x2="21" y2="9" stroke="currentColor" stroke-width="1.5"/><line x1="3" y1="15" x2="21" y2="15" stroke="currentColor" stroke-width="1.5"/><line x1="3" y1="21" x2="21" y2="21" stroke="currentColor" stroke-width="1.5"/></svg>
                                <span>Grid</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">MEP (tap wall)</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('pipe')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg><span>Pipe</span></button>
                            <button class="tool-btn filled" onclick="App.setTool('gas')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg><span>Gas</span></button>
                            <button class="tool-btn" onclick="App.setTool('radiator')"><svg viewBox="0 0 24 24"><rect x="3" y="8" width="18" height="10" rx="1"/><line x1="6" y1="9" x2="6" y2="17"/><line x1="9" y1="9" x2="9" y2="17"/><line x1="12" y1="9" x2="12" y2="17"/><line x1="15" y1="9" x2="15" y2="17"/><line x1="18" y1="9" x2="18" y2="17"/></svg><span>Rad</span></button>
                            <button class="tool-btn" onclick="App.setTool('riser')"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="3"/></svg><span>Riser</span></button>
                            <button class="tool-btn" onclick="App.setTool('poe')"><svg viewBox="0 0 24 24"><polygon points="12,2 22,12 17,12 17,22 7,22 7,12 2,12" fill="currentColor"/></svg><span>POE</span></button>
                        </div>
                    </div>
                </div>
                <div class="section" id="objectSection">
                    <div class="section-header" onclick="App.toggleObjectPanel()">Objects <span id="objectToggle">▶</span></div>
                    <div class="section-content collapsed" id="objectTree"></div>
                </div>
                <div class="section" id="roomTypeSection" style="display: none;">
                    <div class="section-header">Room Type</div>
                    <div class="section-content">
                        <select id="roomTypeSelect" onchange="App.changeRoomType(this.value)" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg); color: var(--text); font-size: 12px;">
                            <option value="Room">Room</option>
                            <option value="Bedroom 1">Bedroom 1</option>
                            <option value="Bedroom 2">Bedroom 2</option>
                            <option value="Bedroom 3">Bedroom 3</option>
                            <option value="Bedroom 4">Bedroom 4</option>
                            <option value="Bathroom 1">Bathroom 1</option>
                            <option value="Bathroom 2">Bathroom 2</option>
                            <option value="Kitchen">Kitchen</option>
                            <option value="Living Room">Living Room</option>
                            <option value="Dining Room">Dining Room</option>
                            <option value="Hallway 1">Hallway 1</option>
                            <option value="Hallway 2">Hallway 2</option>
                            <option value="Hallway 3">Hallway 3</option>
                            <option value="Foyer">Foyer</option>
                            <option value="Office">Office</option>
                            <option value="Den">Den</option>
                            <option value="Laundry">Laundry</option>
                            <option value="Garage">Garage</option>
                            <option value="Basement">Basement</option>
                            <option value="Attic">Attic</option>
                            <option value="Storage">Storage</option>
                            <option value="Utility">Utility</option>
                            <option value="Porch">Porch</option>
                            <option value="Sunroom">Sunroom</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                </div>
                <div class="section" id="wallSection" style="display: none;">
                    <div class="section-header">Wall Settings</div>
                    <div class="section-content">
                        <div style="padding: 4px 8px; font-size: 11px; color: var(--text-dim); margin-bottom: 8px;">
                            Selected: <strong id="selectedWallLabel">W1</strong>
                        </div>
                        <div class="tool-grid" style="grid-template-columns: 1fr;">
                            <button class="tool-btn" onclick="App.setAsW1()" title="Set this wall as W1 (others renumber clockwise)">
                                <svg viewBox="0 0 24 24"><path d="M12 2L12 22M12 2L8 6M12 2L16 6" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><text x="12" y="18" text-anchor="middle" font-size="8" fill="currentColor" stroke="none">W1</text></svg>
                                <span>Set as W1</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Actions</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.selectAll()" title="Select All (Ctrl+A)">
                                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" fill="none" stroke-width="2"/><path d="M9 12l2 2 4-4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>All</span>
                            </button>
                            <button class="tool-btn" onclick="App.rotateSelected()" title="Rotate selected">
                                <svg viewBox="0 0 24 24"><path d="M23 4v6h-6" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>Rotate</span>
                            </button>
                            <button class="tool-btn" onclick="App.showQA()" title="QA Validation">
                                <svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>QA</span>
                            </button>
                            <button class="tool-btn" onclick="App.copySelected()" title="Copy (Ctrl+C)">
                                <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" stroke="currentColor" fill="none" stroke-width="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Copy</span>
                            </button>
                            <button class="tool-btn" onclick="App.paste()" title="Paste (Ctrl+V)">
                                <svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" stroke="currentColor" fill="none" stroke-width="2"/><rect x="8" y="2" width="8" height="4" rx="1" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Paste</span>
                            </button>
                            <button class="tool-btn" id="btnUndo" onclick="App.undo()" title="Undo (Ctrl+Z)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M3 10h10a5 5 0 015 5v2M3 10l5-5M3 10l5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>Undo</span>
                            </button>
                            <button class="tool-btn" id="btnRedo" onclick="App.redo()" title="Redo (Ctrl+Y)" style="opacity: 0.4;">
                                <svg viewBox="0 0 24 24"><path d="M21 10H11a5 5 0 00-5 5v2M21 10l-5-5M21 10l-5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                                <span>Redo</span>
                            </button>
                            <button class="tool-btn" id="deleteBtn" onclick="App.deleteSelected()" title="Delete selected" style="opacity: 0.4;" disabled>
                                <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14M10 11v6M14 11v6" stroke="currentColor" fill="none" stroke-width="2"/></svg>
                                <span>Delete</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-wrap">
            <div id="stage"></div>
            <div class="north-arrow" id="northArrow" onclick="App.rotateNorth()" title="Click to rotate north direction">
                <svg viewBox="0 0 24 24" id="compassArrow">
                    <polygon class="arrow-n" points="12,2 8,12 12,10 16,12"/>
                    <polygon class="arrow-s" points="12,22 8,12 12,14 16,12"/>
                    <text x="12" y="6" text-anchor="middle" font-size="4" font-weight="bold" fill="white">N</text>
                </svg>
            </div>
            <div class="scale-label">1/4" = 1'-0"</div>
            <div class="qa-badge" id="qaBadge">QA: --</div>
            <div class="tool-hint" id="toolHint">Tap a wall segment to place</div>
        </div>
    </div>
</div>

<div class="modal" id="qaModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">QA Validation</div>
            <button class="modal-close" onclick="App.hideModal('qa')">&times;</button>
        </div>
        <div class="modal-body" id="qaContent"></div>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ========== CONSTANTS ==========
const SCALE = 4;
const INCH = SCALE;
const FOOT = 12 * SCALE;
const WALL_EXT = 6 * INCH;
const WALL_INT = 4.5 * INCH;
const SNAP_DISTANCE = 24; // Mobile-friendly snap distance in pixels
const HIT_WIDTH = 28; // Hit region width for wall segments
const GRID_SNAP = FOOT; // Snap to 1-foot grid

// Dimension line colors
const DIM_COLOR_EXTERIOR = '#2563eb';  // Blue for exterior room dimensions
const DIM_COLOR_INTERIOR = '#f97316';  // Orange for interior room dimensions

// ========== SNAPPING FUNCTIONS ==========
function snapToGrid(value) {
    return Math.round(value / GRID_SNAP) * GRID_SNAP;
}

function findRoomSnapPoints(doc, excludeRoomId) {
    // Get all room edges for snapping (excluding current room)
    const snapPoints = { x: [], y: [] };
    doc.rooms.forEach(room => {
        if (room.id === excludeRoomId) return;
        const g = room.geometry;
        snapPoints.x.push(g.x, g.x + g.width);
        snapPoints.y.push(g.y, g.y + g.height);
    });
    return snapPoints;
}

function snapRoomPosition(x, y, width, height, snapPoints) {
    let snappedX = x;
    let snappedY = y;
    let bestDistX = SNAP_DISTANCE;
    let bestDistY = SNAP_DISTANCE;

    // Find closest X snap point (check both left and right edges)
    for (const sx of snapPoints.x) {
        // Left edge snap
        const leftDist = Math.abs(x - sx);
        if (leftDist < bestDistX) {
            bestDistX = leftDist;
            snappedX = sx;
        }
        // Right edge snap
        const rightDist = Math.abs(x + width - sx);
        if (rightDist < bestDistX) {
            bestDistX = rightDist;
            snappedX = sx - width;
        }
    }

    // Find closest Y snap point (check both top and bottom edges)
    for (const sy of snapPoints.y) {
        // Top edge snap
        const topDist = Math.abs(y - sy);
        if (topDist < bestDistY) {
            bestDistY = topDist;
            snappedY = sy;
        }
        // Bottom edge snap
        const bottomDist = Math.abs(y + height - sy);
        if (bottomDist < bestDistY) {
            bestDistY = bottomDist;
            snappedY = sy - height;
        }
    }

    // Snap to grid if no room edge snap found
    if (snappedX === x) snappedX = snapToGrid(x);
    if (snappedY === y) snappedY = snapToGrid(y);

    return { x: snappedX, y: snappedY };
}

// ========== DOCUMENT MODEL ==========
const Doc = {
    create() {
        return {
            id: this.uid(),
            version: '4.0',
            address: '2BR/1BA Blueprint',
            counters: { room: 0, wallSegment: 0, door: 0, window: 0, closet: 0, cased: 0, pipe: 0, gas: 0, riser: 0, radiator: 0, poe: 0 },
            rooms: [],
            wallSegments: [],  // All wall segments indexed here
            doors: [],
            windows: [],
            casedOpenings: [],
            closets: [],
            mep: [],
            dimensions: []
        };
    },
    uid() { return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); },
    label(doc, type) {
        doc.counters[type] = (doc.counters[type] || 0) + 1;
        const prefixes = { room: 'Rm', wallSegment: 'WS', door: 'D', window: 'WIN', closet: 'CL', cased: 'OP', pipe: 'PIPE', gas: 'GAS', riser: 'PRSR', radiator: 'RAD', poe: 'POE' };
        const n = doc.counters[type];
        return (prefixes[type] || type.toUpperCase()) + '-' + (n < 10 ? '0' : '') + n;
    }
};

// ========== WALL SEGMENT CREATION ==========
function createWallSegments(room, doc) {
    const g = room.geometry;
    // Create 4 segments for rectangular room: S, W, N, E
    // Segments defined by endpoints, ordered clockwise
    const segments = [
        { side: 'south', x1: g.x, y1: g.y + g.height, x2: g.x + g.width, y2: g.y + g.height },
        { side: 'west',  x1: g.x, y1: g.y + g.height, x2: g.x, y2: g.y },
        { side: 'north', x1: g.x, y1: g.y, x2: g.x + g.width, y2: g.y },
        { side: 'east',  x1: g.x + g.width, y1: g.y, x2: g.x + g.width, y2: g.y + g.height }
    ];

    // Determine which segment is SOUTH-most (highest Y average)
    let southIdx = 0;
    let maxY = -Infinity;
    segments.forEach((seg, i) => {
        const avgY = (seg.y1 + seg.y2) / 2;
        if (avgY > maxY) { maxY = avgY; southIdx = i; }
    });

    // Reorder so W1 is the SOUTH-most, then clockwise
    const ordered = [];
    for (let i = 0; i < 4; i++) {
        ordered.push(segments[(southIdx + i) % 4]);
    }

    // Create WallSegment objects
    const wallSegments = ordered.map((seg, idx) => {
        const ws = {
            id: Doc.uid(),
            roomId: room.id,
            roomLabel: room.label,
            index: idx + 1,
            label: 'W' + (idx + 1),
            side: seg.side,
            x1: seg.x1, y1: seg.y1, x2: seg.x2, y2: seg.y2,
            thickness: room.isExterior ? WALL_EXT : WALL_INT,
            type: 'interior',  // Default to interior, will be set properly by markExteriorWalls()
            attachedObjects: []
        };
        doc.wallSegments.push(ws);
        return ws;
    });

    room.wallSegmentIds = wallSegments.map(ws => ws.id);
    return wallSegments;
}

function getSegmentLength(seg) {
    return Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
}

function getSegmentMidpoint(seg) {
    return { x: (seg.x1 + seg.x2) / 2, y: (seg.y1 + seg.y2) / 2 };
}

function getSegmentAngle(seg) {
    return Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1);
}

function pointToSegmentDistance(px, py, seg) {
    const dx = seg.x2 - seg.x1;
    const dy = seg.y2 - seg.y1;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.sqrt((px - seg.x1) ** 2 + (py - seg.y1) ** 2);
    let t = ((px - seg.x1) * dx + (py - seg.y1) * dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = seg.x1 + t * dx;
    const nearY = seg.y1 + t * dy;
    return { distance: Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2), t, nearX, nearY };
}

function findNearestWallSegment(x, y, doc) {
    let nearest = null;
    let minDist = Infinity;
    let nearestT = 0;
    let nearestPoint = null;

    doc.wallSegments.forEach(seg => {
        const result = pointToSegmentDistance(x, y, seg);
        if (result.distance < minDist) {
            minDist = result.distance;
            nearest = seg;
            nearestT = result.t;
            nearestPoint = { x: result.nearX, y: result.nearY };
        }
    });

    return { segment: nearest, distance: minDist, t: nearestT, point: nearestPoint };
}

// ========== MARK EXTERIOR WALLS ==========
// Determines which walls are on the building perimeter (exterior) vs shared with other rooms (interior)
function markExteriorWalls(doc) {
    if (doc.rooms.length === 0) return;

    // Find building bounding box from all rooms
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    doc.rooms.forEach(room => {
        const g = room.geometry;
        minX = Math.min(minX, g.x);
        minY = Math.min(minY, g.y);
        maxX = Math.max(maxX, g.x + g.width);
        maxY = Math.max(maxY, g.y + g.height);
    });

    // Tolerance for edge detection (walls on perimeter)
    const tolerance = 2;

    // Mark each wall segment as exterior if it's on the building perimeter
    doc.wallSegments.forEach(ws => {
        const midX = (ws.x1 + ws.x2) / 2;
        const midY = (ws.y1 + ws.y2) / 2;
        const isVertical = Math.abs(ws.x1 - ws.x2) < tolerance;
        const isHorizontal = Math.abs(ws.y1 - ws.y2) < tolerance;

        let isExterior = false;

        if (isHorizontal) {
            // Check if on top or bottom edge
            if (Math.abs(midY - minY) < tolerance || Math.abs(midY - maxY) < tolerance) {
                isExterior = true;
            }
        }
        if (isVertical) {
            // Check if on left or right edge
            if (Math.abs(midX - minX) < tolerance || Math.abs(midX - maxX) < tolerance) {
                isExterior = true;
            }
        }

        ws.type = isExterior ? 'exterior' : 'interior';
        ws.thickness = isExterior ? WALL_EXT : WALL_INT;
    });
}

// ========== GENERATE 2BR/1BA ==========
function generate2BR1BA() {
    const doc = Doc.create();

    // Layout: Clean 2x3 grid with shared walls, no gaps
    // Total exterior: 26' x 20' (compact ranch-style)
    //
    //      0      12     16      26
    //      +------+------+-------+  0
    //      | Bed1 | Hall |Kitchen|
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 10
    //      |Living| Bath | Bed 2 |
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 20
    //
    const startX = 60, startY = 60;

    // Grid columns (x positions)
    const col1 = startX;                    // Left edge
    const col2 = startX + 12 * FOOT;        // 12'
    const col3 = col2 + 4 * FOOT;           // 16'
    const col4 = col3 + 10 * FOOT;          // 26' (right edge)

    // Grid rows (y positions)
    const row1 = startY;                    // Top edge
    const row2 = startY + 10 * FOOT;        // 10'
    const row3 = row2 + 10 * FOOT;          // 20' (bottom edge)

    // ========== ROW 1: Bed1 | Hall | Kitchen ==========
    // Bedroom 1: Top-left (12' x 10')
    const bed1 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 1', isExterior: true,
        geometry: { x: col1, y: row1, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed1, doc);
    doc.rooms.push(bed1);

    // Hallway 1: Top-center (4' x 10')
    const hall = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Hallway 1', isExterior: false,
        geometry: { x: col2, y: row1, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(hall, doc);
    doc.rooms.push(hall);

    // Kitchen: Top-right (10' x 10')
    const kitchen = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Kitchen', isExterior: true,
        geometry: { x: col3, y: row1, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(kitchen, doc);
    doc.rooms.push(kitchen);

    // ========== ROW 2: Living | Bath | Bed2 ==========
    // Living Room: Bottom-left (12' x 10')
    const living = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Living Room', isExterior: true,
        geometry: { x: col1, y: row2, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(living, doc);
    doc.rooms.push(living);

    // Bathroom: Bottom-center (4' x 10')
    const bath = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bathroom', isExterior: false,
        geometry: { x: col2, y: row2, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bath, doc);
    doc.rooms.push(bath);

    // Bedroom 2: Bottom-right (10' x 10')
    const bed2 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 2', isExterior: true,
        geometry: { x: col3, y: row2, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed2, doc);
    doc.rooms.push(bed2);

    // Mark which walls are actually on the building exterior vs interior (shared)
    markExteriorWalls(doc);

    // ========== DOORS ==========
    // New layout wall reference:
    // W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south)
    //
    // Circulation path: Entry(Living W1) → Living → Bath(W4/W2) → Hall(W3/W1) → Bed1(W2/W4) + Kitchen(W4/W2)
    //                   Bath → Bed2 (W4/W2)

    // D-01: Entry door on Living south wall (W1) - exterior entry
    const livingSouthWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W1');
    if (livingSouthWall) {
        const d1 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d1);
        livingSouthWall.attachedObjects.push({ type: 'door', id: d1.id, label: d1.label });

        // POE anchored to entry door
        const poe1 = {
            id: Doc.uid(), label: Doc.label(doc, 'poe'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            anchorDoorId: d1.id,
            distanceFromStart: 4.5 * FOOT
        };
        doc.mep.push(poe1);
        livingSouthWall.attachedObjects.push({ type: 'poe', id: poe1.id, label: poe1.label });
    }

    // D-02: Bed 1 to Hall - on Bed1's east wall (W4)
    const bed1EastWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W4');
    if (bed1EastWall) {
        const d2 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed1EastWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d2);
        bed1EastWall.attachedObjects.push({ type: 'door', id: d2.id, label: d2.label });
    }

    // D-03: Bath to Hall - on Bath's north wall (W3)
    const bathNorthWall = doc.wallSegments.find(ws => ws.roomId === bath.id && ws.label === 'W3');
    if (bathNorthWall) {
        const d3 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bathNorthWall.id,
            parentRoomId: bath.id,
            distanceFromStart: 0.5 * FOOT,
            width: 2.5 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d3);
        bathNorthWall.attachedObjects.push({ type: 'door', id: d3.id, label: d3.label });
    }

    // D-04: Bed 2 to Bath - on Bed2's west wall (W2)
    const bed2WestWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W2');
    if (bed2WestWall) {
        const d4 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed2WestWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d4);
        bed2WestWall.attachedObjects.push({ type: 'door', id: d4.id, label: d4.label });
    }

    // D-05: Kitchen to Hall - on Kitchen's west wall (W2)
    const kitchenWestWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W2');
    if (kitchenWestWall) {
        const d5 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: kitchenWestWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d5);
        kitchenWestWall.attachedObjects.push({ type: 'door', id: d5.id, label: d5.label });
    }

    // D-06: Living to Bath - on Living's east wall (W4)
    const livingEastWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W4');
    if (livingEastWall) {
        const d6 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: livingEastWall.id,
            parentRoomId: living.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'out', swingDir: 'right'
        };
        doc.doors.push(d6);
        livingEastWall.attachedObjects.push({ type: 'door', id: d6.id, label: d6.label });
    }

    // ========== WINDOWS ==========
    // WIN-01: Living west wall
    const livingWestWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W2');
    if (livingWestWall) {
        const w1 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 2 * FOOT,
            width: 5 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w1);
        livingWestWall.attachedObjects.push({ type: 'window', id: w1.id, label: w1.label });
    }

    // WIN-02: Bed 1 north wall
    const bed1NorthWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W3');
    if (bed1NorthWall) {
        const w2 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed1NorthWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 3 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w2);
        bed1NorthWall.attachedObjects.push({ type: 'window', id: w2.id, label: w2.label });
    }

    // WIN-03: Bed 2 south wall
    const bed2SouthWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W1');
    if (bed2SouthWall) {
        const w3 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed2SouthWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w3);
        bed2SouthWall.attachedObjects.push({ type: 'window', id: w3.id, label: w3.label });
    }

    // WIN-04: Kitchen east wall
    const kitchenEastWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W4');
    if (kitchenEastWall) {
        const w4 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: kitchenEastWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            sillHeight: 42 * INCH
        };
        doc.windows.push(w4);
        kitchenEastWall.attachedObjects.push({ type: 'window', id: w4.id, label: w4.label });
    }

    // ========== MEP ==========
    // Radiator in Living
    if (livingWestWall) {
        const rad1 = {
            id: Doc.uid(), label: Doc.label(doc, 'radiator'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 8 * FOOT,
            width: 3 * FOOT, height: 1 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rad1);
        livingWestWall.attachedObjects.push({ type: 'radiator', id: rad1.id, label: rad1.label });

        // Riser near radiator
        const rsr1 = {
            id: Doc.uid(), label: Doc.label(doc, 'riser'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 7.5 * FOOT,
            width: 0.5 * FOOT, height: 0.5 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rsr1);
        livingWestWall.attachedObjects.push({ type: 'riser', id: rsr1.id, label: rsr1.label });
    }

    // ========== DIMENSIONS ==========
    const totalW = col4 - col1;  // 26'
    const totalH = row3 - row1;  // 20'
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalW / FOOT)}'-0"`, x1: startX, y1: startY - 25, x2: startX + totalW, y2: startY - 25 });
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalH / FOOT)}'-0"`, x1: startX - 25, y1: startY, x2: startX - 25, y2: startY + totalH, vertical: true });

    return doc;
}

// ========== RENDERER ==========
const Render = {
    stage: null,
    layers: {},
    wallGroups: {},
    selection: { type: null, id: null },
    multiSelection: [],  // Array of {type, id} for multi-select

    init(containerId) {
        const c = document.getElementById(containerId);
        if (!c) return false;
        const r = c.getBoundingClientRect();
        this.stage = new Konva.Stage({ container: containerId, width: r.width, height: r.height, draggable: true });

        this.layers.rooms = new Konva.Layer();
        this.layers.walls = new Konva.Layer();
        this.layers.openings = new Konva.Layer();
        this.layers.mep = new Konva.Layer();
        this.layers.labels = new Konva.Layer();
        this.layers.dims = new Konva.Layer();
        this.layers.hit = new Konva.Layer(); // Hit regions layer

        this.stage.add(this.layers.rooms, this.layers.walls, this.layers.hit, this.layers.openings, this.layers.mep, this.layers.labels, this.layers.dims);

        this.stage.on('wheel', e => {
            e.evt.preventDefault();
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            const mousePointTo = { x: (pointer.x - this.stage.x()) / oldScale, y: (pointer.y - this.stage.y()) / oldScale };

            // Gentler zoom factor (1.03 instead of 1.1) with min/max limits
            const zoomFactor = 1.03;
            const minScale = 0.3;
            const maxScale = 3;
            let newScale = e.evt.deltaY > 0 ? oldScale / zoomFactor : oldScale * zoomFactor;
            newScale = Math.max(minScale, Math.min(maxScale, newScale));

            this.stage.scale({ x: newScale, y: newScale });
            this.stage.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
        });

        new ResizeObserver(() => {
            const rect = c.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                this.stage.width(rect.width);
                this.stage.height(rect.height);
            }
        }).observe(c);

        // Auto-fit on mobile
        if (window.innerWidth <= 768) {
            setTimeout(() => this.fitToContent(), 100);
        }

        return true;
    },

    // Fit the canvas to show all content with padding
    fitToContent(doc) {
        if (!doc) doc = App.doc;
        if (!doc || !doc.rooms || doc.rooms.length === 0) return;

        // Find bounding box of all rooms and closets
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        doc.rooms.forEach(room => {
            const g = room.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        doc.closets.forEach(closet => {
            const g = closet.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        if (minX === Infinity) return;

        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const padding = 60;

        const stageWidth = this.stage.width();
        const stageHeight = this.stage.height();

        // Calculate scale to fit content with padding
        const scaleX = (stageWidth - padding * 2) / contentWidth;
        const scaleY = (stageHeight - padding * 2) / contentHeight;
        const newScale = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x

        // Center the content
        const centerX = minX + contentWidth / 2;
        const centerY = minY + contentHeight / 2;
        const newX = stageWidth / 2 - centerX * newScale;
        const newY = stageHeight / 2 - centerY * newScale;

        this.stage.scale({ x: newScale, y: newScale });
        this.stage.position({ x: newX, y: newY });
        this.stage.batchDraw();
    },

    // Live update walls during drag
    updateWallsLive(doc) {
        this.layers.walls.destroyChildren();
        this.layers.hit.destroyChildren();

        doc.wallSegments.forEach(ws => {
            let room = doc.rooms.find(r => r.id === ws.roomId);
            if (!room) room = doc.closets.find(c => c.id === ws.roomId);
            const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
            const isExterior = ws.type === 'exterior';

            const wallColor = isSelected ? '#3b82f6' : '#2d3748';
            const wallWidth = isSelected ? 5 : (isExterior ? 4 : 2);
            const shadowOffset = 4;

            // Shadow line
            this.layers.walls.add(new Konva.Line({
                points: [ws.x1 + shadowOffset, ws.y1 + shadowOffset, ws.x2 + shadowOffset, ws.y2 + shadowOffset],
                stroke: 'rgba(0,0,0,0.5)',
                strokeWidth: wallWidth + 2,
                lineCap: 'round',
                listening: false
            }));

            // Main wall line
            this.layers.walls.add(new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: wallColor,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            }));

            // Hit region
            const hitLine = new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: 'transparent',
                strokeWidth: HIT_WIDTH,
                lineCap: 'round',
                hitStrokeWidth: HIT_WIDTH
            });
            hitLine.on('tap click', () => App.onWallTap(ws.id));
            hitLine.on('pointerdown', () => App.onWallTap(ws.id));
            this.layers.hit.add(hitLine);
        });

        this.layers.walls.batchDraw();
        this.layers.hit.batchDraw();
    },

    // Live update dimensions during drag (lightweight, doesn't recreate room groups)
    updateDimensionsLive(doc) {
        // Clear only dims and labels layers
        this.layers.dims.destroyChildren();
        this.layers.labels.destroyChildren();

        // Re-render room labels (dimensions now handled by renderInteriorDimensions)
        doc.rooms.forEach(room => {
            const g = room.geometry;
            const isSelected = this.selection.type === 'room' && this.selection.id === room.id;

            // Room label (inside) - show type as main label, ID underneath
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
                text: room.type, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
            }));
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 4, width: g.width,
                text: room.label, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
            }));
            // Note: Interior dimension LINES are rendered by renderInteriorDimensions()
            // Note: Exterior dimensions are handled by renderChainDimensions()
        });

        // Re-render closet labels
        doc.closets.forEach(closet => {
            const g = closet.geometry;
            const isSelected = this.selection.type === 'closet' && this.selection.id === closet.id;
            const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);

            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
                text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#6b7280', align: 'center', listening: false
            }));
            if (parentRoom) {
                this.layers.labels.add(new Konva.Text({
                    x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                    text: `(${parentRoom.label})`, fontSize: 8, fill: '#9ca3af', align: 'center', listening: false
                }));
            }
        });

        // Re-render wall labels
        doc.wallSegments.forEach(ws => {
            let room = doc.rooms.find(r => r.id === ws.roomId);
            if (!room) room = doc.closets.find(c => c.id === ws.roomId);
            if (!room) return;

            const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        });

        // Auto-generate chain dimensions if showDims is enabled
        if (App.showDims && doc.rooms.length > 0) {
            this.renderChainDimensions(doc);
            this.renderInteriorDimensions(doc);
        }

        this.layers.dims.batchDraw();
        this.layers.labels.batchDraw();
    },

    render(doc, opts = {}) {
        if (!this.stage) return;
        const { showWallIds = true, showDims = true } = opts;

        ['rooms', 'walls', 'hit', 'openings', 'mep', 'labels', 'dims'].forEach(l => this.layers[l].destroyChildren());
        this.wallGroups = {};

        // Room fills (non-listening)
        doc.rooms.forEach(r => this.renderRoomFill(r, doc));

        // Wall segments (with hit regions)
        doc.wallSegments.forEach(ws => this.renderWallSegment(ws, doc, showWallIds));

        // Closets
        doc.closets.forEach(c => this.renderCloset(c, doc));

        // Doors
        doc.doors.forEach(d => this.renderDoor(d, doc));

        // Windows
        doc.windows.forEach(w => this.renderWindow(w, doc));

        // Cased openings
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));

        // MEP
        doc.mep.forEach(m => this.renderMEP(m, doc));

        // Auto-generate chain dimensions based on current room layout
        if (showDims && doc.rooms.length > 0) {
            this.renderChainDimensions(doc);
            this.renderInteriorDimensions(doc);
        }

        Object.values(this.layers).forEach(l => l.batchDraw());
    },

    renderRoomFill(room, doc) {
        const g = room.geometry;
        const isSelected = this.isSelected('room', room.id);
        const self = this;

        // Find closets that belong to this room
        const roomClosets = doc.closets.filter(c => c.parentRoomId === room.id);

        // Create a group for the room (for dragging)
        const roomGroup = new Konva.Group({
            x: 0, y: 0,
            draggable: isSelected
        });

        // Room fill - light blue tint when selected, white when not
        const roomFill = isSelected ? '#dbeafe' : '#fafbfc';
        const roomBorder = isSelected ? '#2563eb' : '#e5e7eb';

        // Shadow properties - bright blue glow when selected, subtle shadow when not
        const shadowProps = isSelected ? {
            shadowColor: '#3b82f6',
            shadowBlur: 20,
            shadowOffset: { x: 0, y: 0 },
            shadowOpacity: 0.8
        } : {
            shadowColor: 'black',
            shadowBlur: 8,
            shadowOffset: { x: 4, y: 4 },
            shadowOpacity: 0.4
        };

        // Simple room rectangle - positioned at room coordinates
        roomGroup.x(g.x);
        roomGroup.y(g.y);

        if (roomClosets.length === 0) {
            // Simple case: no closets
            roomGroup.add(new Konva.Rect({
                x: 0, y: 0, width: g.width, height: g.height,
                fill: roomFill,
                stroke: roomBorder,
                strokeWidth: isSelected ? 3 : 1,
                ...shadowProps
            }));
        } else {
            // Room has closets - draw room fill excluding closet areas
            const roomShape = new Konva.Shape({
                sceneFunc: (context, shape) => {
                    context.beginPath();
                    context.rect(0, 0, g.width, g.height);
                    // Cut out closet areas relative to room
                    roomClosets.forEach(closet => {
                        const cg = closet.geometry;
                        const cx = cg.x - g.x;
                        const cy = cg.y - g.y;
                        context.moveTo(cx, cy);
                        context.lineTo(cx, cy + cg.height);
                        context.lineTo(cx + cg.width, cy + cg.height);
                        context.lineTo(cx + cg.width, cy);
                        context.closePath();
                    });
                    context.fillStrokeShape(shape);
                },
                fill: roomFill,
                stroke: roomBorder,
                strokeWidth: isSelected ? 3 : 1,
                ...shadowProps
            });
            roomGroup.add(roomShape);
        }

        // Add tap handler for room selection
        roomGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onRoomTap(room.id);
        });

        // Prevent stage panning when clicking on rooms
        roomGroup.on('mousedown touchstart', (e) => {
            e.cancelBubble = true;
        });

        // Simplified drag - just move the group, update geometry on dragend
        if (isSelected) {
            let origGX, origGY, startClosetPositions = [], snapPoints = null;

            roomGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                origGX = g.x;  // Store original geometry for closet offset calculation
                origGY = g.y;
                startClosetPositions = roomClosets.map(c => ({ id: c.id, x: c.geometry.x, y: c.geometry.y }));
                snapPoints = findRoomSnapPoints(doc, room.id);
            });

            roomGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                // this.x() and this.y() are the absolute position of the group
                const rawX = this.x();
                const rawY = this.y();
                const snapped = snapRoomPosition(rawX, rawY, g.width, g.height, snapPoints);

                // Set snapped position directly
                this.x(snapped.x);
                this.y(snapped.y);
            });

            roomGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                // Final position is just the group's current position
                const finalX = this.x();
                const finalY = this.y();

                // Update room geometry
                g.x = finalX;
                g.y = finalY;

                // Update wall segments
                const segs = doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    if (ws.label === 'W1') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                    else if (ws.label === 'W2') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x; ws.y2 = g.y; }
                    else if (ws.label === 'W3') { ws.x1 = g.x; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y; }
                    else if (ws.label === 'W4') { ws.x1 = g.x + g.width; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                });

                // Update closets
                const dx = finalX - origGX;
                const dy = finalY - origGY;
                roomClosets.forEach(closet => {
                    const sp = startClosetPositions.find(p => p.id === closet.id);
                    if (sp) {
                        closet.geometry.x = sp.x + dx;
                        closet.geometry.y = sp.y + dy;
                        const cg = closet.geometry;
                        doc.wallSegments.filter(ws => ws.roomId === closet.id).forEach(ws => {
                            if (ws.label === 'W1') { ws.x1 = cg.x; ws.y1 = cg.y + cg.height; ws.x2 = cg.x + cg.width; ws.y2 = cg.y + cg.height; }
                            else if (ws.label === 'W2') { ws.x1 = cg.x; ws.y1 = cg.y + cg.height; ws.x2 = cg.x; ws.y2 = cg.y; }
                            else if (ws.label === 'W3') { ws.x1 = cg.x; ws.y1 = cg.y; ws.x2 = cg.x + cg.width; ws.y2 = cg.y; }
                            else if (ws.label === 'W4') { ws.x1 = cg.x + cg.width; ws.y1 = cg.y; ws.x2 = cg.x + cg.width; ws.y2 = cg.y + cg.height; }
                        });
                    }
                });

                markExteriorWalls(doc);
                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });
        }

        this.layers.rooms.add(roomGroup);

        // Room label (inside) - show type as main label, ID underneath
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
            text: room.type, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 + 4, width: g.width,
            text: room.label, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
        }));
        // Note: Interior dimension LINES are rendered by renderInteriorDimensions()
        // Note: Exterior dimension lines are handled by renderChainDimensions()
    },

    renderWallSegment(ws, doc, showWallIds) {
        // Find room or closet (closets are rooms too)
        let room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) room = doc.closets.find(c => c.id === ws.roomId);
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const isExterior = ws.type === 'exterior';

        // Wall group
        const group = new Konva.Group({ id: ws.id });
        this.wallGroups[ws.id] = group;

        // Visible wall line - dark grey, exterior walls thicker
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = isSelected ? 5 : (isExterior ? 4 : 2);
        const shadowOffset = 4;

        // Shadow line behind wall (offset down-right) - more visible
        const shadowLine = new Konva.Line({
            points: [ws.x1 + shadowOffset, ws.y1 + shadowOffset, ws.x2 + shadowOffset, ws.y2 + shadowOffset],
            stroke: 'rgba(0,0,0,0.5)',
            strokeWidth: wallWidth + 2,
            lineCap: 'round',
            listening: false
        });
        group.add(shadowLine);

        // Main wall line
        const visibleLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: wallColor,
            strokeWidth: wallWidth,
            lineCap: 'round',
            listening: false
        });
        group.add(visibleLine);

        // HIT REGION (invisible, wide stroke for mobile tapping)
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        hitLine.on('pointerdown', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);

        // Wall ID label
        if (showWallIds) {
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        }

        this.layers.walls.add(group);
    },

    getLabelOffset(ws, room) {
        if (!room) return { x: 0, y: 0 };
        const g = room.geometry;
        const mid = getSegmentMidpoint(ws);
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: -(dx / dist) * 14, y: -(dy / dist) * 10 };
    },

    renderCloset(closet, doc) {
        const g = closet.geometry;
        const isSelected = this.isSelected('closet', closet.id);
        const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);
        const pg = parentRoom ? parentRoom.geometry : null;

        // Closet fill with light grey and shadow (closets are rooms too)
        // Blue glow when selected, dark shadow when not
        const closetShadowProps = isSelected ? {
            shadowColor: '#3b82f6',
            shadowBlur: 15,
            shadowOffset: { x: 0, y: 0 },
            shadowOpacity: 0.6
        } : {
            shadowColor: 'black',
            shadowBlur: 8,
            shadowOffset: { x: 4, y: 4 },
            shadowOpacity: 0.4
        };
        // Closet is a room - render in rooms layer so shadow shows properly
        const closetGroup = new Konva.Group({
            x: g.x, y: g.y,
            draggable: isSelected
        });
        const self = this;

        const rect = new Konva.Rect({
            x: 0, y: 0, width: g.width, height: g.height,
            fill: '#f3f4f6', stroke: isSelected ? '#3b82f6' : '#d1d5db', strokeWidth: isSelected ? 2 : 1,
            ...closetShadowProps
        });
        closetGroup.add(rect);

        // Diagonal hatch lines (architectural convention for closets)
        const hatchGroup = new Konva.Group({ clip: { x: 0, y: 0, width: g.width, height: g.height } });
        const spacing = 12;
        const hatchColor = '#d1d5db';
        for (let i = -g.height; i < g.width + g.height; i += spacing) {
            hatchGroup.add(new Konva.Line({
                points: [i, 0, i + g.height, g.height],
                stroke: hatchColor, strokeWidth: 1, listening: false
            }));
        }
        closetGroup.add(hatchGroup);

        closetGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onObjectTap('closet', closet.id);
        });
        // Prevent stage panning when clicking on closets
        closetGroup.on('mousedown touchstart', (e) => {
            e.cancelBubble = true;
        });

        // Add drag functionality for closets when selected
        if (isSelected) {
            let snapPoints = null;

            closetGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                snapPoints = findRoomSnapPoints(doc, closet.id);
            });

            closetGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                // this.x() and this.y() are the absolute position of the group
                const rawX = this.x();
                const rawY = this.y();
                const snapped = snapRoomPosition(rawX, rawY, g.width, g.height, snapPoints);
                // Set snapped position directly
                this.x(snapped.x);
                this.y(snapped.y);
            });

            closetGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                // Final position is just the group's current position
                const finalX = this.x();
                const finalY = this.y();

                // Update closet geometry
                g.x = finalX;
                g.y = finalY;

                // Update closet wall segments
                doc.wallSegments.filter(ws => ws.roomId === closet.id).forEach(ws => {
                    if (ws.label === 'W1') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                    else if (ws.label === 'W2') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x; ws.y2 = g.y; }
                    else if (ws.label === 'W3') { ws.x1 = g.x; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y; }
                    else if (ws.label === 'W4') { ws.x1 = g.x + g.width; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                });

                // Update parentRoomId if closet moved outside its parent
                const newParent = doc.rooms.find(room => {
                    const rg = room.geometry;
                    const overlapX = Math.max(0, Math.min(g.x + g.width, rg.x + rg.width) - Math.max(g.x, rg.x));
                    const overlapY = Math.max(0, Math.min(g.y + g.height, rg.y + rg.height) - Math.max(g.y, rg.y));
                    const overlapArea = overlapX * overlapY;
                    const closetArea = g.width * g.height;
                    return overlapArea > closetArea * 0.5;
                });
                if (newParent) {
                    closet.parentRoomId = newParent.id;
                    closet.parentRoomLabel = newParent.label;
                } else {
                    closet.parentRoomId = null;
                    closet.parentRoomLabel = null;
                }

                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });
        }

        this.layers.rooms.add(closetGroup);

        // Draw closet walls and make them clickable for placing doors
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = 2;

        // Get closet's wall segments for hit detection
        const closetWalls = doc.wallSegments.filter(ws => ws.roomId === closet.id);

        // Render closet walls (only interior-facing ones that don't touch parent room edges)
        if (pg) {
            // South wall of closet (if not touching room's south edge)
            if (g.y + g.height < pg.y + pg.height) {
                const southWall = closetWalls.find(w => w.side === 'south');
                if (southWall) {
                    this.renderClosetWall(southWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y + g.height, g.x + g.width, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // North wall of closet (if not touching room's north edge)
            if (g.y > pg.y) {
                const northWall = closetWalls.find(w => w.side === 'north');
                if (northWall) {
                    this.renderClosetWall(northWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y, g.x + g.width, g.y],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // West wall of closet (if not touching room's west edge)
            if (g.x > pg.x) {
                const westWall = closetWalls.find(w => w.side === 'west');
                if (westWall) {
                    this.renderClosetWall(westWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x, g.y, g.x, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
            // East wall of closet (if not touching room's east edge)
            if (g.x + g.width < pg.x + pg.width) {
                const eastWall = closetWalls.find(w => w.side === 'east');
                if (eastWall) {
                    this.renderClosetWall(eastWall, wallColor, wallWidth);
                } else {
                    this.layers.walls.add(new Konva.Line({
                        points: [g.x + g.width, g.y, g.x + g.width, g.y + g.height],
                        stroke: wallColor, strokeWidth: wallWidth, listening: false
                    }));
                }
            }
        }

        // Closet label with parent room indicator
        const parentLabel = parentRoom ? ` → ${parentRoom.label}` : '';
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
            text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#6b7280', align: 'center', listening: false
        }));
        // Show parent room indicator
        if (parentRoom) {
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                text: `(${parentRoom.label})`, fontSize: 8, fill: '#9ca3af', align: 'center', listening: false
            }));
        }

        // Show connection line to parent room when selected
        if (isSelected && parentRoom && pg) {
            const closetCenterX = g.x + g.width / 2;
            const closetCenterY = g.y + g.height / 2;
            const roomCenterX = pg.x + pg.width / 2;
            const roomCenterY = pg.y + pg.height / 2;

            this.layers.dims.add(new Konva.Line({
                points: [closetCenterX, closetCenterY, roomCenterX, roomCenterY],
                stroke: '#3b82f6',
                strokeWidth: 1,
                dash: [4, 4],
                listening: false
            }));
        }
    },

    // Render a closet wall with hit detection for placing doors
    renderClosetWall(ws, wallColor, wallWidth) {
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const shadowOffset = 4;
        const finalWidth = isSelected ? 4 : wallWidth;

        // Shadow line behind wall - more visible
        this.layers.walls.add(new Konva.Line({
            points: [ws.x1 + shadowOffset, ws.y1 + shadowOffset, ws.x2 + shadowOffset, ws.y2 + shadowOffset],
            stroke: 'rgba(0,0,0,0.5)',
            strokeWidth: finalWidth + 2,
            lineCap: 'round',
            listening: false
        }));

        // Visible wall line
        this.layers.walls.add(new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: isSelected ? '#3b82f6' : wallColor,
            strokeWidth: finalWidth,
            lineCap: 'round',
            listening: false
        }));

        // Hit region for wall selection and door placement
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', () => App.onWallTap(ws.id));
        this.layers.hit.add(hitLine);
    },

    renderDoor(door, doc) {
        const ws = doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, door.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isVertical = Math.abs(Math.sin(angle)) > 0.5;
        const isSelected = this.selection.type === 'door' && this.selection.id === door.id;

        const doorGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Door opening (gap in wall) - covers wall line and shadow
        const wallClearHeight = 16;  // Enough to cover wall + shadow
        const doorRect = new Konva.Rect({
            x: -2, y: -wallClearHeight / 2,
            width: door.width + 4,
            height: wallClearHeight,
            fill: '#f0f7ff',  // Match blueprint background
            stroke: 'transparent'
        });
        doorGroup.add(doorRect);

        // Door jambs (thin lines at edges of opening)
        const jambColor = '#2d3748';
        const jambHeight = 8;
        doorGroup.add(new Konva.Line({
            points: [0, -jambHeight/2, 0, jambHeight/2],
            stroke: jambColor, strokeWidth: 2
        }));
        doorGroup.add(new Konva.Line({
            points: [door.width, -jambHeight/2, door.width, jambHeight/2],
            stroke: jambColor, strokeWidth: 2
        }));

        // Door geometry - hinge point and swing direction
        const swingOut = door.swing === 'out' ? -1 : 1;  // in = toward positive y, out = toward negative y
        const hingeLeft = door.swingDir === 'left';      // hinge on left or right side

        // Hinge position (at corner of door opening)
        const hingeX = hingeLeft ? 0 : door.width;
        const hingeY = swingOut * ws.thickness / 2;

        // Door leaf length (slightly less than full width for visual clarity)
        const leafLength = door.width * 0.9;

        // Door leaf end point at 90 degrees (perpendicular to wall, fully open)
        const leafEndX = hingeX;  // Straight perpendicular, no x movement
        const leafEndY = hingeY + swingOut * leafLength;

        // Swing arc (dashed/perforated) - from hinge, showing door swing path
        const swingArc = new Konva.Arc({
            x: hingeX,
            y: hingeY,
            innerRadius: leafLength - 1,
            outerRadius: leafLength,
            angle: 90,
            rotation: hingeLeft ? (swingOut > 0 ? 0 : -90) : (swingOut > 0 ? 90 : 180),
            stroke: '#9ca3af',
            strokeWidth: 1,
            dash: [4, 3]
        });
        doorGroup.add(swingArc);

        // Door leaf (solid line representing the actual door panel)
        const doorLeaf = new Konva.Line({
            points: [hingeX, hingeY, leafEndX, leafEndY],
            stroke: isSelected ? '#3b82f6' : '#2d3748',
            strokeWidth: 3,
            lineCap: 'round'
        });
        doorGroup.add(doorLeaf);

        // Large invisible hit area for easier selection (covers door opening + swing)
        const hitArea = new Konva.Rect({
            x: -5,
            y: Math.min(hingeY, leafEndY) - 5,
            width: door.width + 10,
            height: Math.abs(leafEndY - hingeY) + 15,
            fill: 'transparent',
            stroke: 'transparent'
        });
        doorGroup.add(hitArea);

        doorGroup.on('tap click', () => App.onObjectTap('door', door.id));
        this.layers.openings.add(doorGroup);

        // Label
        const doorLabel = new Konva.Text({
            x: pos.x + (isVertical ? 12 : 0), y: pos.y + (isVertical ? 0 : -14),
            text: door.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#6b7280', listening: false
        });
        this.layers.labels.add(doorLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, door.distanceFromStart + door.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateDoorVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, door.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);

                // Recalculate door geometry
                const newHingeX = hingeLeft ? 0 : door.width;
                const newLeafLength = door.width * 0.9;
                const newLeafEndX = newHingeX;  // 90 degrees - straight perpendicular
                const newLeafEndY = hingeY + swingOut * newLeafLength;

                // Update door group position and rect width
                doorGroup.x(newPos.x);
                doorGroup.y(newPos.y);
                doorRect.width(door.width);

                // Update swing arc
                swingArc.x(newHingeX);
                swingArc.innerRadius(newLeafLength - 1);
                swingArc.outerRadius(newLeafLength);

                // Update door leaf
                doorLeaf.points([newHingeX, hingeY, newLeafEndX, newLeafEndY]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire door along wall
            doorGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            doorGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const maxOffset = getSegmentLength(ws) - door.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                door.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + door.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            doorGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const oldEnd = door.distanceFromStart + door.width;
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth) {
                    door.width = oldEnd - newOffset;
                    door.distanceFromStart = newOffset;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEnd = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const newWidth = newEnd - door.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches

                if (newWidth >= minWidth && newEnd <= maxOffset) {
                    door.width = newWidth;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderWindow(win, doc) {
        const ws = doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, win.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'window' && this.selection.id === win.id;

        const winGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Window opening (gap in wall) - covers wall line and shadow
        const winThickness = 8;  // Thicker window frame
        const wallClearHeight = 16;  // Enough to cover wall + shadow
        const winRect = new Konva.Rect({
            x: -2, y: -wallClearHeight / 2,
            width: win.width + 4, height: wallClearHeight,
            fill: '#f0f7ff',  // Match blueprint background
            stroke: 'transparent'
        });
        winGroup.add(winRect);

        // Window frame lines (top and bottom sill) - thicker
        const frameColor = isSelected ? '#3b82f6' : '#60a5fa';
        const topSill = new Konva.Line({
            points: [0, -winThickness / 2, win.width, -winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(topSill);

        const bottomSill = new Konva.Line({
            points: [0, winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(bottomSill);

        // Window jambs (ends)
        const leftJamb = new Konva.Line({
            points: [0, -winThickness / 2, 0, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(leftJamb);

        const rightJamb = new Konva.Line({
            points: [win.width, -winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(rightJamb);

        // Mullion (center divider)
        const mullion = new Konva.Line({
            points: [win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2],
            stroke: frameColor, strokeWidth: 1
        });
        winGroup.add(mullion);

        winGroup.on('tap click', () => App.onObjectTap('window', win.id));
        this.layers.openings.add(winGroup);

        const winLabel = new Konva.Text({
            x: pos.x + win.width / 2 - 15, y: pos.y - 14,
            text: win.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#60a5fa', listening: false
        });
        this.layers.labels.add(winLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;  // Mobile-friendly touch target
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, win.distanceFromStart + win.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateWindowVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, win.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);

                // Update window group position
                winGroup.x(newPos.x);
                winGroup.y(newPos.y);

                // Update rect width
                winRect.width(win.width);

                // Update frame lines
                topSill.points([0, -winThickness / 2, win.width, -winThickness / 2]);
                bottomSill.points([0, winThickness / 2, win.width, winThickness / 2]);
                rightJamb.points([win.width, -winThickness / 2, win.width, winThickness / 2]);
                mullion.points([win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire window along wall
            winGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            winGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const maxOffset = getSegmentLength(ws) - win.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                win.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + win.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            winGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newOffset = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const oldEnd = win.distanceFromStart + win.width;
                const minWidth = 1 * FOOT;

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth) {
                    win.width = oldEnd - newOffset;
                    win.distanceFromStart = newOffset;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const newEnd = self.getOffsetOnSegment(ws, pointer.x, pointer.y);
                const newWidth = newEnd - win.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 1 * FOOT;

                if (newWidth >= minWidth && newEnd <= maxOffset) {
                    win.width = newWidth;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderCasedOpening(op, doc) {
        const ws = doc.wallSegments.find(s => s.id === op.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, op.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'cased' && this.selection.id === op.id;

        const opGroup = new Konva.Group({ x: pos.x, y: pos.y, rotation: angle * 180 / Math.PI });

        // Clear wall behind opening
        const wallClearHeight = 16;
        opGroup.add(new Konva.Rect({
            x: -2, y: -wallClearHeight / 2,
            width: op.width + 4, height: wallClearHeight,
            fill: '#f0f7ff',  // Match blueprint background
            stroke: 'transparent'
        }));

        // Dashed line "---------"
        opGroup.add(new Konva.Line({
            points: [0, 0, op.width, 0],
            stroke: isSelected ? '#06b6d4' : '#aaa', strokeWidth: 2, dash: [6, 3]
        }));

        opGroup.on('tap click', () => App.onObjectTap('cased', op.id));
        this.layers.openings.add(opGroup);

        this.layers.labels.add(new Konva.Text({
            x: pos.x + op.width / 2 - 10, y: pos.y - 12,
            text: op.label, fontSize: 9, fill: isSelected ? '#06b6d4' : '#aaa', listening: false
        }));
    },

    renderMEP(mep, doc) {
        const ws = doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
        if (!ws) return;

        const isSelected = this.selection.type === 'mep' && this.selection.id === mep.id;
        const color = isSelected ? '#3b82f6' : (mep.label.startsWith('GAS') ? '#f97316' : mep.label.startsWith('POE') ? '#ef4444' : '#22c55e');

        // Use free x,y position if available, otherwise calculate from wall
        let posX, posY;
        if (mep.x !== undefined && mep.y !== undefined) {
            posX = mep.x;
            posY = mep.y;
        } else {
            // Legacy: calculate from wall position
            const wallPos = this.getPositionOnSegment(ws, mep.distanceFromStart || 0);
            posX = wallPos.x;
            posY = wallPos.y;
        }

        if (mep.label.startsWith('PIPE')) {
            const shape = new Konva.Circle({ x: posX, y: posY, radius: 8, stroke: color, strokeWidth: 2, fill: '#fff', draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('GAS')) {
            const shape = new Konva.Circle({ x: posX, y: posY, radius: 8, fill: color, draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('POE')) {
            const shape = new Konva.RegularPolygon({ x: posX, y: posY, sides: 3, radius: 12, fill: color, rotation: 0, draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('RAD')) {
            // Radiators use free positioning
            const centerX = posX;
            const centerY = posY;
            const self = this;
            const radGroup = new Konva.Group({
                x: centerX,
                y: centerY,
                rotation: mep.rotation || 0,
                draggable: isSelected
            });

            // Draw radiator centered at origin (0,0) so rotation works correctly
            const halfW = mep.width / 2;
            const halfH = mep.height / 2;

            // Main housing
            radGroup.add(new Konva.Rect({
                x: -halfW, y: -halfH, width: mep.width, height: mep.height,
                fill: '#f9fafb', stroke: color, strokeWidth: 2, cornerRadius: 3
            }));

            // Vertical fins (radiator style)
            const finCount = Math.max(3, Math.floor(mep.width / 12));
            const finSpacing = mep.width / (finCount + 1);
            const finPadding = 4;
            for (let i = 1; i <= finCount; i++) {
                radGroup.add(new Konva.Line({
                    points: [-halfW + i * finSpacing, -halfH + finPadding, -halfW + i * finSpacing, halfH - finPadding],
                    stroke: color, strokeWidth: 1.5, opacity: 0.7
                }));
            }

            // Top and bottom horizontal pipes
            radGroup.add(new Konva.Line({
                points: [-halfW + 4, -halfH + 6, halfW - 4, -halfH + 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));
            radGroup.add(new Konva.Line({
                points: [-halfW + 4, halfH - 6, halfW - 4, halfH - 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));

            radGroup.on('tap click', (e) => {
                e.cancelBubble = true;
                App.onObjectTap('mep', mep.id);
            });

            // Prevent stage panning when interacting with radiator
            radGroup.on('mousedown touchstart', (e) => {
                e.cancelBubble = true;
            });

            // Drag handling for radiator - free positioning
            if (isSelected) {
                radGroup.on('dragstart', function(e) {
                    e.cancelBubble = true;
                    self.stage.draggable(false);
                });

                radGroup.on('dragmove', function(e) {
                    e.cancelBubble = true;
                });

                radGroup.on('dragend', function(e) {
                    self.stage.draggable(true);
                    // Save free x,y position (wall registration stays the same)
                    mep.x = this.x();
                    mep.y = this.y();
                    App.saveState();
                    App.render();
                });
            }

            this.layers.mep.add(radGroup);
        } else if (mep.label.startsWith('PRSR')) {
            // Pipe Riser - uses free positioning
            const self = this;
            const riserGroup = new Konva.Group({
                x: posX,
                y: posY,
                draggable: isSelected
            });

            // Outer circle
            riserGroup.add(new Konva.Circle({
                x: 0, y: 0, radius: 12,
                fill: '#f3f4f6', stroke: color, strokeWidth: 2
            }));
            // Inner circle (pipe)
            riserGroup.add(new Konva.Circle({
                x: 0, y: 0, radius: 6,
                fill: '#e5e7eb', stroke: color, strokeWidth: 1
            }));

            riserGroup.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            riserGroup.on('mousedown touchstart', (e) => { e.cancelBubble = true; });

            if (isSelected) {
                riserGroup.on('dragstart', function(e) { e.cancelBubble = true; self.stage.draggable(false); });
                riserGroup.on('dragmove', function(e) { e.cancelBubble = true; });
                riserGroup.on('dragend', function(e) {
                    self.stage.draggable(true);
                    mep.x = this.x();
                    mep.y = this.y();
                    App.saveState();
                    App.render();
                });
            }
            this.layers.mep.add(riserGroup);
        }

        // Label uses the mep's x,y position
        this.layers.labels.add(new Konva.Text({
            x: posX + 14, y: posY - 5,
            text: mep.label, fontSize: 8, fill: color, listening: false
        }));
    },

    // Helper to add drag handlers for simple MEP shapes (PIPE, GAS, POE)
    addMEPDragHandlers(shape, mep, ws) {
        const self = this;
        shape.on('mousedown touchstart', (e) => { e.cancelBubble = true; });
        shape.on('dragstart', function(e) { e.cancelBubble = true; self.stage.draggable(false); });
        shape.on('dragmove', function(e) { e.cancelBubble = true; });
        shape.on('dragend', function(e) {
            self.stage.draggable(true);
            mep.x = this.x();
            mep.y = this.y();
            App.saveState();
            App.render();
        });
    },

    getPositionOnSegment(seg, distFromStart) {
        const len = getSegmentLength(seg);
        const t = Math.min(distFromStart / len, 1);
        return {
            x: seg.x1 + t * (seg.x2 - seg.x1),
            y: seg.y1 + t * (seg.y2 - seg.y1)
        };
    },

    // Convert a point (x,y) to an offset along a wall segment
    getOffsetOnSegment(seg, px, py) {
        const dx = seg.x2 - seg.x1;
        const dy = seg.y2 - seg.y1;
        const len = getSegmentLength(seg);
        if (len === 0) return 0;

        // Project point onto line segment
        const t = Math.max(0, Math.min(1, ((px - seg.x1) * dx + (py - seg.y1) * dy) / (len * len)));
        return t * len;
    },

    getInteriorOffset(ws, doc) {
        let room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) room = doc.closets.find(c => c.id === ws.roomId);
        if (!room) return { x: 0, y: 0 };
        const mid = getSegmentMidpoint(ws);
        const g = room.geometry;
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    renderDimension(dim) {
        const layer = this.layers.dims;
        const isVert = dim.vertical;
        // Overall building dimensions use exterior (blue) color
        const dimLineColor = DIM_COLOR_EXTERIOR;

        // Main dimension line
        layer.add(new Konva.Line({ points: [dim.x1, dim.y1, dim.x2, dim.y2], stroke: dimLineColor, strokeWidth: 1.5, listening: false }));

        // Extension lines (ticks)
        if (isVert) {
            layer.add(new Konva.Line({ points: [dim.x1 - 4, dim.y1, dim.x1 + 4, dim.y1], stroke: dimLineColor, strokeWidth: 1, listening: false }));
            layer.add(new Konva.Line({ points: [dim.x2 - 4, dim.y2, dim.x2 + 4, dim.y2], stroke: dimLineColor, strokeWidth: 1, listening: false }));
        } else {
            layer.add(new Konva.Line({ points: [dim.x1, dim.y1 - 4, dim.x1, dim.y1 + 4], stroke: dimLineColor, strokeWidth: 1, listening: false }));
            layer.add(new Konva.Line({ points: [dim.x2, dim.y2 - 4, dim.x2, dim.y2 + 4], stroke: dimLineColor, strokeWidth: 1, listening: false }));
        }

        const midX = (dim.x1 + dim.x2) / 2, midY = (dim.y1 + dim.y2) / 2;
        layer.add(new Konva.Text({
            x: isVert ? midX - 28 : midX - 18, y: isVert ? midY - 5 : midY - 12,
            text: dim.label, fontSize: 9, fill: dimLineColor, listening: false
        }));
    },

    // Render chain dimensions showing all room boundaries
    renderChainDimensions(doc) {
        const layer = this.layers.dims;
        const dimColor = DIM_COLOR_EXTERIOR;
        const dimOffset = 25;    // Distance for dimensions from edge
        const tickLen = 4;       // Tick mark length

        // Collect all unique X and Y coordinates from room boundaries
        const xCoords = new Set();
        const yCoords = new Set();
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        doc.rooms.forEach(room => {
            const g = room.geometry;
            xCoords.add(g.x);
            xCoords.add(g.x + g.width);
            yCoords.add(g.y);
            yCoords.add(g.y + g.height);
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        if (minX === Infinity) return; // No rooms

        // Sort coordinates
        const sortedX = Array.from(xCoords).sort((a, b) => a - b);
        const sortedY = Array.from(yCoords).sort((a, b) => a - b);

        // Format dimension text (feet and inches)
        const formatDim = (pixels) => {
            const totalInches = pixels / INCH;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        };

        // Helper to check if a point is inside any room
        const isInsideBuilding = (x, y) => {
            return doc.rooms.some(r => {
                const g = r.geometry;
                return x >= g.x && x <= g.x + g.width && y >= g.y && y <= g.y + g.height;
            });
        };

        // Trace the exterior outline and collect all edges
        // We'll trace clockwise starting from top-left corner
        const outline = [];

        // For each Y level, find the leftmost and rightmost X that's part of the building
        const leftEdgeByY = new Map();  // Y -> leftmost X
        const rightEdgeByY = new Map(); // Y -> rightmost X

        sortedY.forEach(y => {
            const midY = y + 0.5; // Check just below this Y line
            let leftX = Infinity, rightX = -Infinity;
            doc.rooms.forEach(r => {
                const g = r.geometry;
                if (g.y <= midY && g.y + g.height > midY) {
                    leftX = Math.min(leftX, g.x);
                    rightX = Math.max(rightX, g.x + g.width);
                }
            });
            if (leftX !== Infinity) {
                leftEdgeByY.set(y, leftX);
                rightEdgeByY.set(y, rightX);
            }
        });

        // For each X level, find the topmost and bottommost Y that's part of the building
        const topEdgeByX = new Map();    // X -> topmost Y
        const bottomEdgeByX = new Map(); // X -> bottommost Y

        sortedX.forEach(x => {
            const midX = x + 0.5; // Check just right of this X line
            let topY = Infinity, bottomY = -Infinity;
            doc.rooms.forEach(r => {
                const g = r.geometry;
                if (g.x <= midX && g.x + g.width > midX) {
                    topY = Math.min(topY, g.y);
                    bottomY = Math.max(bottomY, g.y + g.height);
                }
            });
            if (topY !== Infinity) {
                topEdgeByX.set(x, topY);
                bottomEdgeByX.set(x, bottomY);
            }
        });

        // Draw dimension for a horizontal edge
        const drawHorizDim = (x1, x2, y, side) => {
            const width = Math.abs(x2 - x1);
            if (width < FOOT / 4) return; // Skip very small segments

            const dimY = side === 'top' ? y - dimOffset : y + dimOffset;
            const midX = (x1 + x2) / 2;
            const labelY = side === 'top' ? dimY - 10 : dimY + 4;

            // Dimension line
            layer.add(new Konva.Line({
                points: [x1, dimY, x2, dimY],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Tick marks
            layer.add(new Konva.Line({
                points: [x1, dimY - tickLen, x1, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            layer.add(new Konva.Line({
                points: [x2, dimY - tickLen, x2, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Extension lines
            layer.add(new Konva.Line({
                points: [x1, y, x1, dimY],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            layer.add(new Konva.Line({
                points: [x2, y, x2, dimY],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            // Label
            if (width >= FOOT / 2) {
                layer.add(new Konva.Text({
                    x: midX - 12, y: labelY,
                    text: formatDim(width), fontSize: 8, fill: dimColor, listening: false
                }));
            }
        };

        // Draw dimension for a vertical edge
        const drawVertDim = (y1, y2, x, side) => {
            const height = Math.abs(y2 - y1);
            if (height < FOOT / 4) return; // Skip very small segments

            const dimX = side === 'left' ? x - dimOffset : x + dimOffset;
            const midY = (y1 + y2) / 2;
            const labelX = side === 'left' ? dimX - 26 : dimX + 4;

            // Dimension line
            layer.add(new Konva.Line({
                points: [dimX, y1, dimX, y2],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Tick marks
            layer.add(new Konva.Line({
                points: [dimX - tickLen, y1, dimX + tickLen, y1],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            layer.add(new Konva.Line({
                points: [dimX - tickLen, y2, dimX + tickLen, y2],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Extension lines
            layer.add(new Konva.Line({
                points: [x, y1, dimX, y1],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            layer.add(new Konva.Line({
                points: [x, y2, dimX, y2],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            // Label
            if (height >= FOOT / 2) {
                layer.add(new Konva.Text({
                    x: labelX, y: midY - 4,
                    text: formatDim(height), fontSize: 8, fill: dimColor, listening: false
                }));
            }
        };

        // === TOP EDGE: trace from left to right along the top ===
        let prevTopY = null;
        let prevX = null;
        sortedX.forEach((x, i) => {
            const topY = topEdgeByX.get(x);
            if (topY !== undefined) {
                if (prevTopY !== null && prevX !== null) {
                    // Horizontal segment
                    if (prevTopY === topY) {
                        drawHorizDim(prevX, x, topY, 'top');
                    } else {
                        // There's a step - draw horizontal to the step, then vertical step
                        drawHorizDim(prevX, x, Math.min(prevTopY, topY), 'top');
                        // Draw the vertical step dimension
                        const stepHeight = Math.abs(topY - prevTopY);
                        if (stepHeight >= FOOT / 4) {
                            drawVertDim(Math.min(prevTopY, topY), Math.max(prevTopY, topY), x, 'left');
                        }
                    }
                }
                prevTopY = topY;
                prevX = x;
            }
        });

        // === BOTTOM EDGE: trace from left to right along the bottom ===
        let prevBottomY = null;
        prevX = null;
        sortedX.forEach((x, i) => {
            const bottomY = bottomEdgeByX.get(x);
            if (bottomY !== undefined) {
                if (prevBottomY !== null && prevX !== null) {
                    // Horizontal segment
                    if (prevBottomY === bottomY) {
                        drawHorizDim(prevX, x, bottomY, 'bottom');
                    } else {
                        // There's a step
                        drawHorizDim(prevX, x, Math.max(prevBottomY, bottomY), 'bottom');
                        // Draw the vertical step dimension
                        const stepHeight = Math.abs(bottomY - prevBottomY);
                        if (stepHeight >= FOOT / 4) {
                            drawVertDim(Math.min(prevBottomY, bottomY), Math.max(prevBottomY, bottomY), x, 'right');
                        }
                    }
                }
                prevBottomY = bottomY;
                prevX = x;
            }
        });

        // === LEFT EDGE: trace from top to bottom along the left ===
        let prevLeftX = null;
        let prevY = null;
        sortedY.forEach((y, i) => {
            const leftX = leftEdgeByY.get(y);
            if (leftX !== undefined) {
                if (prevLeftX !== null && prevY !== null) {
                    // Vertical segment
                    if (prevLeftX === leftX) {
                        drawVertDim(prevY, y, leftX, 'left');
                    } else {
                        // There's a step
                        drawVertDim(prevY, y, Math.min(prevLeftX, leftX), 'left');
                        // Draw the horizontal step dimension
                        const stepWidth = Math.abs(leftX - prevLeftX);
                        if (stepWidth >= FOOT / 4) {
                            drawHorizDim(Math.min(prevLeftX, leftX), Math.max(prevLeftX, leftX), y, 'top');
                        }
                    }
                }
                prevLeftX = leftX;
                prevY = y;
            }
        });

        // === RIGHT EDGE: trace from top to bottom along the right ===
        let prevRightX = null;
        prevY = null;
        sortedY.forEach((y, i) => {
            const rightX = rightEdgeByY.get(y);
            if (rightX !== undefined) {
                if (prevRightX !== null && prevY !== null) {
                    // Vertical segment
                    if (prevRightX === rightX) {
                        drawVertDim(prevY, y, rightX, 'right');
                    } else {
                        // There's a step
                        drawVertDim(prevY, y, Math.max(prevRightX, rightX), 'right');
                        // Draw the horizontal step dimension
                        const stepWidth = Math.abs(rightX - prevRightX);
                        if (stepWidth >= FOOT / 4) {
                            drawHorizDim(Math.min(prevRightX, rightX), Math.max(prevRightX, rightX), y, 'bottom');
                        }
                    }
                }
                prevRightX = rightX;
                prevY = y;
            }
        });

        // === TOTAL DIMENSIONS (outer ring) ===
        const totalOffset = 50;
        const totalW = maxX - minX;
        const totalH = maxY - minY;

        // Total width top
        layer.add(new Konva.Line({
            points: [minX, minY - totalOffset, maxX, minY - totalOffset],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX, minY - totalOffset - tickLen, minX, minY - totalOffset + tickLen],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [maxX, minY - totalOffset - tickLen, maxX, minY - totalOffset + tickLen],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Text({
            x: (minX + maxX) / 2 - 18, y: minY - totalOffset - 14,
            text: formatDim(totalW), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
        }));

        // Total height left
        layer.add(new Konva.Line({
            points: [minX - totalOffset, minY, minX - totalOffset, maxY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX - totalOffset - tickLen, minY, minX - totalOffset + tickLen, minY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX - totalOffset - tickLen, maxY, minX - totalOffset + tickLen, maxY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Text({
            x: minX - totalOffset - 36, y: (minY + maxY) / 2 - 5,
            text: formatDim(totalH), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
        }));

    },

    // Render interior room dimensions (width and height inside each room)
    renderInteriorDimensions(doc) {
        const layer = this.layers.dims;
        const dimColor = DIM_COLOR_INTERIOR;
        const dimOffset = 35;    // Distance from wall for dimension line
        const tickLen = 5;       // Tick mark length

        // Format dimension text (feet and inches)
        const formatDim = (pixels) => {
            const totalInches = pixels / INCH;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        };

        doc.rooms.forEach(room => {
            const g = room.geometry;
            const w = g.width;
            const h = g.height;

            // Skip very small rooms
            if (w < FOOT * 3 || h < FOOT * 3) return;

            // === WIDTH dimension (horizontal, near bottom) ===
            const widthY = g.y + g.height - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [g.x + dimOffset, widthY, g.x + g.width - dimOffset, widthY],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Left tick
            layer.add(new Konva.Line({
                points: [g.x + dimOffset, widthY - tickLen, g.x + dimOffset, widthY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Right tick
            layer.add(new Konva.Line({
                points: [g.x + g.width - dimOffset, widthY - tickLen, g.x + g.width - dimOffset, widthY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Width label
            layer.add(new Konva.Text({
                x: g.x + g.width / 2 - 20, y: widthY - 14,
                text: formatDim(w), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
            }));

            // === HEIGHT dimension (vertical, near right) ===
            const heightX = g.x + g.width - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [heightX, g.y + dimOffset, heightX, g.y + g.height - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Top tick
            layer.add(new Konva.Line({
                points: [heightX - tickLen, g.y + dimOffset, heightX + tickLen, g.y + dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Bottom tick
            layer.add(new Konva.Line({
                points: [heightX - tickLen, g.y + g.height - dimOffset, heightX + tickLen, g.y + g.height - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Height label (rotated for vertical reading)
            layer.add(new Konva.Text({
                x: heightX - 10, y: g.y + g.height / 2 - 20,
                text: formatDim(h), fontSize: 10, fontStyle: 'bold', fill: dimColor, rotation: -90, listening: false
            }));
        });

        // Also do closets
        doc.closets.forEach(closet => {
            const g = closet.geometry;
            const w = g.width;
            const h = g.height;

            // Skip very small closets
            if (w < FOOT * 2 || h < FOOT * 2) return;

            // === WIDTH dimension (horizontal, near bottom) ===
            const widthY = g.y + g.height - 10;

            layer.add(new Konva.Line({
                points: [g.x + 8, widthY, g.x + g.width - 8, widthY],
                stroke: dimColor, strokeWidth: 0.75, listening: false, dash: [2, 2]
            }));
            layer.add(new Konva.Text({
                x: g.x + g.width / 2 - 14, y: widthY - 10,
                text: formatDim(w), fontSize: 7, fill: dimColor, listening: false
            }));

            // === HEIGHT dimension (vertical, near right) ===
            const heightX = g.x + g.width - 10;

            layer.add(new Konva.Line({
                points: [heightX, g.y + 8, heightX, g.y + g.height - 8],
                stroke: dimColor, strokeWidth: 0.75, listening: false, dash: [2, 2]
            }));
            layer.add(new Konva.Text({
                x: heightX - 6, y: g.y + g.height / 2 - 14,
                text: formatDim(h), fontSize: 7, fill: dimColor, rotation: -90, listening: false
            }));
        });
    },

    select(type, id) {
        this.selection = { type, id };
        this.multiSelection = []; // Clear multi-selection when single selecting
    },

    deselect() {
        this.selection = { type: null, id: null };
        this.multiSelection = [];
    },

    // Add to multi-selection
    addToSelection(type, id) {
        if (!this.isInMultiSelection(type, id)) {
            this.multiSelection.push({ type, id });
        }
    },

    // Remove from multi-selection
    removeFromSelection(type, id) {
        this.multiSelection = this.multiSelection.filter(s => !(s.type === type && s.id === id));
    },

    // Check if object is in multi-selection
    isInMultiSelection(type, id) {
        return this.multiSelection.some(s => s.type === type && s.id === id);
    },

    // Check if object is selected (single or multi)
    isSelected(type, id) {
        return (this.selection.type === type && this.selection.id === id) ||
               this.isInMultiSelection(type, id);
    },

    // Select all rooms
    selectAllRooms(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = doc.rooms.map(r => ({ type: 'room', id: r.id }));
    },

    // Select all objects
    selectAll(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = [
            ...doc.rooms.map(r => ({ type: 'room', id: r.id })),
            ...doc.closets.map(c => ({ type: 'closet', id: c.id }))
        ];
    },

    getImage() { return this.stage ? this.stage.toDataURL({ pixelRatio: 2 }) : null; }
};

// ========== QA VALIDATION ==========
function runQA(doc) {
    const results = [];

    // All rooms labeled
    results.push({ rule: 'All rooms labeled', pass: doc.rooms.every(r => r.label), detail: 'OK' });

    // All wall segments have W1=SOUTH
    const badWalls = doc.rooms.filter(r => {
        const segs = doc.wallSegments.filter(ws => ws.roomId === r.id);
        if (segs.length < 4) return true;
        const w1 = segs.find(ws => ws.label === 'W1');
        return !w1;
    });
    results.push({ rule: 'Wall IDs (W1 exists)', pass: badWalls.length === 0, detail: badWalls.length > 0 ? `${badWalls.length} rooms` : 'OK' });

    // Closets
    results.push({ rule: 'Closets (CL-01, CL-02)', pass: doc.closets.length >= 2, detail: `${doc.closets.length} closets` });

    // Doors attached to walls
    const unattachedDoors = doc.doors.filter(d => !d.parentWallSegmentId);
    results.push({ rule: 'Doors attached to walls', pass: unattachedDoors.length === 0, detail: unattachedDoors.length > 0 ? `${unattachedDoors.length} floating` : 'OK' });

    // Windows attached to walls
    const unattachedWindows = doc.windows.filter(w => !w.parentWallSegmentId);
    results.push({ rule: 'Windows attached to walls', pass: unattachedWindows.length === 0, detail: unattachedWindows.length > 0 ? `${unattachedWindows.length} floating` : 'OK' });

    // Windows must be on exterior walls only
    const windowsOnInterior = doc.windows.filter(w => {
        const ws = doc.wallSegments.find(seg => seg.id === w.parentWallSegmentId);
        return ws && ws.type !== 'exterior';
    });
    results.push({ rule: 'Windows on exterior walls', pass: windowsOnInterior.length === 0, detail: windowsOnInterior.length > 0 ? `${windowsOnInterior.length} on interior` : 'OK' });

    // MEP attached (except free-placed)
    const unattachedMEP = doc.mep.filter(m => !m.parentWallSegmentId && !m.freePlaced);
    results.push({ rule: 'MEP attached to walls', pass: unattachedMEP.length === 0, detail: unattachedMEP.length > 0 ? `${unattachedMEP.length} floating` : 'OK' });

    // POE anchored
    const poe = doc.mep.find(m => m.label.startsWith('POE'));
    const entryDoor = doc.doors.find(d => d.type === 'entry');
    results.push({ rule: 'POE anchored to entry', pass: poe && poe.anchorDoorId === entryDoor?.id, detail: poe ? 'OK' : 'Missing' });

    // Dimensions
    results.push({ rule: 'Dimensions present', pass: doc.dimensions.length > 0, detail: `${doc.dimensions.length}` });

    return results;
}

// ========== APP ==========
const App = {
    doc: null,
    currentTool: 'select',
    showGrid: true,
    showWallIds: true,
    showDims: true,
    undoStack: [],
    redoStack: [],
    maxHistory: 50,
    isDrawingRoom: false,
    roomDrawStart: null,
    roomPreview: null,
    isDrawingWall: false,
    wallDrawStart: null,
    wallPreview: null,
    clipboard: [],  // For copy/paste

    init() {
        if (!Render.init('stage')) { alert('Init failed'); return; }
        this.doc = generate2BR1BA();
        this.saveState(); // Save initial state
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateUndoRedoButtons();
        this.setupKeyboardShortcuts();
        this.setupRoomDrawing();
        this.setupWallDrawing();
        this.setupMarqueeSelection();
        console.log('App ready - tap walls to select');
    },

    // Convert screen position to world/canvas position (accounting for pan/zoom)
    getWorldPosition(stage) {
        const pointer = stage.getPointerPosition();
        if (!pointer) return null;
        const transform = stage.getAbsoluteTransform().copy().invert();
        return transform.point(pointer);
    },

    setupRoomDrawing() {
        const stage = Render.stage;
        const self = this;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'room') return;

            // Disable stage panning while drawing
            stage.draggable(false);

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            this.isDrawingRoom = true;
            this.roomDrawStart = { x: snappedX, y: snappedY };

            // Create preview rectangle
            this.roomPreview = new Konva.Rect({
                x: snappedX,
                y: snappedY,
                width: 0,
                height: 0,
                fill: 'rgba(59, 130, 246, 0.1)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [5, 5]
            });
            Render.layers.openings.add(this.roomPreview);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.roomDrawStart;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            // Calculate dimensions
            const x = Math.min(start.x, snappedX);
            const y = Math.min(start.y, snappedY);
            const width = Math.abs(snappedX - start.x);
            const height = Math.abs(snappedY - start.y);

            this.roomPreview.x(x);
            this.roomPreview.y(y);
            this.roomPreview.width(width);
            this.roomPreview.height(height);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.roomDrawStart;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            // Calculate final dimensions
            const x = Math.min(start.x, snappedX);
            const y = Math.min(start.y, snappedY);
            const width = Math.abs(snappedX - start.x);
            const height = Math.abs(snappedY - start.y);

            // Remove preview
            this.roomPreview.destroy();
            this.roomPreview = null;
            this.isDrawingRoom = false;
            stage.draggable(true);

            // Minimum size check (at least 2' x 2')
            if (width < 2 * FOOT || height < 2 * FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Check if drawing is inside an existing room (create closet) or outside (create room)
            const parentRoom = this.doc.rooms.find(room => {
                const g = room.geometry;
                // Check if the drawn rectangle is mostly inside this room
                const overlapX = Math.max(0, Math.min(x + width, g.x + g.width) - Math.max(x, g.x));
                const overlapY = Math.max(0, Math.min(y + height, g.y + g.height) - Math.max(y, g.y));
                const overlapArea = overlapX * overlapY;
                const drawnArea = width * height;
                return overlapArea > drawnArea * 0.5; // More than 50% inside room
            });

            if (parentRoom) {
                // Create a closet inside the room (closet is a sub-room with parent link)
                const closet = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'closet'),
                    type: 'Closet',
                    roomType: 'Closet',  // Distinguishes from regular Room
                    parentRoomId: parentRoom.id,
                    parentRoomLabel: parentRoom.label,
                    isExterior: false,
                    geometry: { x, y, width, height }
                };
                // Create wall segments for the closet (like a room)
                createWallSegments(closet, this.doc);
                this.doc.closets.push(closet);
                Render.select('closet', closet.id);
            } else {
                // Create a new room
                if (width < 4 * FOOT || height < 4 * FOOT) {
                    // Room needs to be at least 4x4
                    Render.layers.openings.batchDraw();
                    return;
                }
                const room = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'room'),
                    type: 'Room',
                    isExterior: true,
                    geometry: { x, y, width, height }
                };
                createWallSegments(room, this.doc);
                this.doc.rooms.push(room);
                markExteriorWalls(this.doc);
            }

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            this.updateInspector();
            this.setTool('select');
        });
    },

    setupWallDrawing() {
        const stage = Render.stage;
        const self = this;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'wall') return;

            stage.draggable(false);

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Snap start point to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            this.isDrawingWall = true;
            this.wallDrawStart = { x: snappedX, y: snappedY };

            // Create preview line
            this.wallPreview = new Konva.Line({
                points: [snappedX, snappedY, snappedX, snappedY],
                stroke: '#2d3748',
                strokeWidth: 4,
                lineCap: 'round',
                dash: [8, 4]
            });
            Render.layers.openings.add(this.wallPreview);

            // Add start point indicator
            this.wallStartPoint = new Konva.Circle({
                x: snappedX,
                y: snappedY,
                radius: 6,
                fill: '#3b82f6'
            });
            Render.layers.openings.add(this.wallStartPoint);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.wallDrawStart;

            // Snap end point to grid
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical (whichever is dominant)
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y; // Horizontal line
            } else {
                endX = start.x; // Vertical line
            }

            this.wallPreview.points([start.x, start.y, endX, endY]);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.wallDrawStart;

            // Snap end point
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y;
            } else {
                endX = start.x;
            }

            // Remove preview
            this.wallPreview.destroy();
            this.wallPreview = null;
            if (this.wallStartPoint) {
                this.wallStartPoint.destroy();
                this.wallStartPoint = null;
            }
            this.isDrawingWall = false;
            stage.draggable(true);

            // Minimum length check (at least 1 foot)
            const length = Math.sqrt(Math.pow(endX - start.x, 2) + Math.pow(endY - start.y, 2));
            if (length < FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Create standalone wall segment
            const isHorizontal = Math.abs(endY - start.y) < 2;
            const ws = {
                id: Doc.uid(),
                roomId: null,  // Standalone wall
                roomLabel: null,
                index: 0,
                label: 'W-' + (this.doc.wallSegments.filter(w => !w.roomId).length + 1),
                side: isHorizontal ? (start.y < 400 ? 'north' : 'south') : (start.x < 400 ? 'west' : 'east'),
                x1: start.x, y1: start.y,
                x2: endX, y2: endY,
                thickness: WALL_EXT,
                type: 'exterior',
                attachedObjects: []
            };
            this.doc.wallSegments.push(ws);

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            Render.select('wall', ws.id);
            this.updateInspector();
        });
    },

    // Marquee selection - Shift+drag to select multiple objects
    setupMarqueeSelection() {
        const self = this;
        let isSelecting = false;
        let selectionRect = null;
        let startPos = null;

        const container = document.getElementById('stage');
        if (!container) return;

        // Convert screen coords to world coords
        const screenToWorld = (clientX, clientY) => {
            const stage = Render.stage;
            const rect = container.getBoundingClientRect();
            const scaleX = stage.scaleX();
            const stageX = stage.x();
            const stageY = stage.y();
            return {
                x: (clientX - rect.left - stageX) / scaleX,
                y: (clientY - rect.top - stageY) / scaleX
            };
        };

        container.addEventListener('mousedown', (e) => {
            // Only activate with Shift key
            if (!e.shiftKey) return;
            if (this.currentTool === 'room' || this.currentTool === 'wall') return;

            e.preventDefault();
            e.stopPropagation();

            Render.stage.draggable(false);
            const pos = screenToWorld(e.clientX, e.clientY);
            isSelecting = true;
            startPos = pos;

            selectionRect = new Konva.Rect({
                x: pos.x, y: pos.y,
                width: 0, height: 0,
                fill: 'rgba(59, 130, 246, 0.2)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [6, 4]
            });
            Render.layers.openings.add(selectionRect);
            Render.layers.openings.batchDraw();
        }, true);

        document.addEventListener('mousemove', (e) => {
            if (!isSelecting || !selectionRect) return;
            const pos = screenToWorld(e.clientX, e.clientY);

            const x = Math.min(startPos.x, pos.x);
            const y = Math.min(startPos.y, pos.y);
            selectionRect.x(x);
            selectionRect.y(y);
            selectionRect.width(Math.abs(pos.x - startPos.x));
            selectionRect.height(Math.abs(pos.y - startPos.y));
            Render.layers.openings.batchDraw();
        });

        document.addEventListener('mouseup', (e) => {
            if (!isSelecting || !selectionRect) return;

            const pos = screenToWorld(e.clientX, e.clientY);
            const x1 = Math.min(startPos.x, pos.x);
            const y1 = Math.min(startPos.y, pos.y);
            const x2 = Math.max(startPos.x, pos.x);
            const y2 = Math.max(startPos.y, pos.y);

            selectionRect.destroy();
            selectionRect = null;
            isSelecting = false;
            startPos = null;
            Render.stage.draggable(true);
            Render.layers.openings.batchDraw();

            // Minimum drag size
            if (x2 - x1 < 20 && y2 - y1 < 20) return;

            // Find objects in selection
            const selected = [];

            this.doc.rooms.forEach(room => {
                const g = room.geometry;
                if (this.rectIntersects(x1, y1, x2, y2, g.x, g.y, g.x + g.width, g.y + g.height)) {
                    selected.push({ type: 'room', id: room.id });
                }
            });

            this.doc.closets.forEach(closet => {
                const g = closet.geometry;
                if (this.rectIntersects(x1, y1, x2, y2, g.x, g.y, g.x + g.width, g.y + g.height)) {
                    selected.push({ type: 'closet', id: closet.id });
                }
            });

            this.doc.doors.forEach(door => {
                const ws = this.doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, door.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'door', id: door.id });
                    }
                }
            });

            this.doc.windows.forEach(win => {
                const ws = this.doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, win.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'window', id: win.id });
                    }
                }
            });

            this.doc.mep.forEach(mep => {
                const ws = this.doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, mep.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'mep', id: mep.id });
                    }
                }
            });

            if (selected.length > 0) {
                Render.selection = { type: null, id: null };
                Render.multiSelection = selected;
                this.render();
                console.log('Selected ' + selected.length + ' objects');
            }
        });
    },

    // Helper: check if two rectangles intersect
    rectIntersects(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
        return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
    },

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Undo: Ctrl+Z or Cmd+Z
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
            }
            // Redo: Ctrl+Y or Cmd+Y or Ctrl+Shift+Z
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                this.redo();
            }
            // Select All: Ctrl+A or Cmd+A
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                this.selectAll();
            }
            // Copy: Ctrl+C or Cmd+C
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                this.copySelected();
            }
            // Paste: Ctrl+V or Cmd+V
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                this.paste();
            }
        });
    },

    saveState() {
        // Deep clone current document state
        const state = JSON.stringify(this.doc);
        this.undoStack.push(state);
        // Limit history size
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        // Clear redo stack when new action is performed
        this.redoStack = [];
        this.updateUndoRedoButtons();
    },

    undo() {
        if (this.undoStack.length <= 1) return; // Keep at least initial state
        // Move current state to redo stack
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        // Restore previous state
        const prevState = this.undoStack[this.undoStack.length - 1];
        this.doc = JSON.parse(prevState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    redo() {
        if (this.redoStack.length === 0) return;
        // Pop from redo and push to undo
        const nextState = this.redoStack.pop();
        this.undoStack.push(nextState);
        // Restore the state
        this.doc = JSON.parse(nextState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    updateUndoRedoButtons() {
        const undoBtn = $('#btnUndo');
        const redoBtn = $('#btnRedo');
        if (undoBtn) {
            undoBtn.disabled = this.undoStack.length <= 1;
            undoBtn.style.opacity = this.undoStack.length <= 1 ? '0.4' : '1';
        }
        if (redoBtn) {
            redoBtn.disabled = this.redoStack.length === 0;
            redoBtn.style.opacity = this.redoStack.length === 0 ? '0.4' : '1';
        }
    },

    newDoc() {
        // Create an empty document - allows drawing rooms from scratch
        this.doc = Doc.create();
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    loadDemo() {
        // Load the 2BR/1BA demo layout
        this.doc = generate2BR1BA();
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    render() {
        Render.render(this.doc, { showWallIds: this.showWallIds, showDims: this.showDims });
    },

    onWallTap(wallSegmentId) {
        const ws = this.doc.wallSegments.find(s => s.id === wallSegmentId);
        if (!ws) return;

        if (this.currentTool === 'select') {
            Render.select('wall', wallSegmentId);
            this.render();
            this.updateInspector();
            this.highlightTreeItem('wall', wallSegmentId);
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(this.currentTool)) {
            this.placeOnWall(ws, this.currentTool);
        }
    },

    onObjectTap(type, id) {
        Render.select(type, id);
        this.render();
        this.updateInspector();
        this.highlightTreeItem(type, id);
    },

    onRoomTap(roomId) {
        if (this.currentTool === 'select') {
            Render.select('room', roomId);
            this.render();
            this.updateInspector();
        }
    },

    placeOnWall(ws, toolType) {
        // Find parent room OR closet (closets are rooms too)
        let room = this.doc.rooms.find(r => r.id === ws.roomId);
        if (!room) {
            room = this.doc.closets.find(c => c.id === ws.roomId);
        }
        const segLen = getSegmentLength(ws);
        const defaultOffset = segLen * 0.3;

        // Windows can ONLY be placed on exterior walls
        if (toolType === 'window' && ws.type !== 'exterior') {
            alert(`Windows can only be placed on exterior walls.\n${room?.label} ${ws.label} is an interior wall.`);
            return;
        }

        let obj;
        switch (toolType) {
            case 'door':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'door'), type: 'interior',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 2.67 * FOOT, swing: 'in', swingDir: 'left'
                };
                this.doc.doors.push(obj);
                break;
            case 'window':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'window'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT, sillHeight: 36 * INCH
                };
                this.doc.windows.push(obj);
                break;
            case 'cased':
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'cased'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: defaultOffset, width: 4 * FOOT
                };
                this.doc.casedOpenings.push(obj);
                break;
            case 'pipe':
                // Calculate initial position with interior offset
                var pipePos = Render.getPositionOnSegment(ws, defaultOffset);
                var pipeOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'pipe'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: pipePos.x + pipeOffset.x * 0.5,
                    y: pipePos.y + pipeOffset.y * 0.5
                };
                this.doc.mep.push(obj);
                break;
            case 'gas':
                var gasPos = Render.getPositionOnSegment(ws, defaultOffset);
                var gasOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'gas'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: gasPos.x + gasOffset.x * 0.5,
                    y: gasPos.y + gasOffset.y * 0.5
                };
                this.doc.mep.push(obj);
                break;
            case 'radiator':
                var radPos = Render.getPositionOnSegment(ws, defaultOffset);
                var radOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'radiator'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: radPos.x + radOffset.x * 0.5,
                    y: radPos.y + radOffset.y * 0.5,
                    width: 4 * FOOT, height: 1 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'riser':
                var riserPos = Render.getPositionOnSegment(ws, defaultOffset);
                var riserOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'riser'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: riserPos.x + riserOffset.x * 0.5,
                    y: riserPos.y + riserOffset.y * 0.5,
                    width: 0.5 * FOOT, height: 0.5 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'poe':
                var poePos = Render.getPositionOnSegment(ws, defaultOffset);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'poe'), type: 'entry',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: poePos.x,
                    y: poePos.y
                };
                this.doc.mep.push(obj);
                break;
        }

        if (obj) {
            ws.attachedObjects.push({ type: toolType, id: obj.id, label: obj.label });
            Render.select(toolType === 'door' || toolType === 'window' || toolType === 'cased' ? toolType : 'mep', obj.id);
            this.saveState();
            this.render();
            this.updateTree();
            this.updateInspector();
            this.updateQABadge();
            this.setTool('select');
        }
    },

    setTool(tool) {
        this.currentTool = tool;
        $$('.tool-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.tool-btn[onclick*="'${tool}'"]`);
        if (btn) btn.classList.add('active');
        $('#btnSelect').classList.toggle('active', tool === 'select');

        // Show hint for placement tools
        const hint = $('#toolHint');
        if (tool === 'room') {
            hint.textContent = 'Drag to draw room (outside) or closet (inside room)';
            hint.classList.add('show');
        } else if (tool === 'wall') {
            hint.textContent = 'Click and drag to draw wall (snaps to grid)';
            hint.classList.add('show');
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'].includes(tool)) {
            const toolName = tool === 'riser' ? 'PIPE RISER' : tool.toUpperCase();
            hint.textContent = `Tap a wall to place ${toolName}`;
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }
    },

    updateInspector() {
        // Update delete button state based on selection
        const sel = Render.selection;
        const deleteBtn = $('#deleteBtn');
        const deletableTypes = ['room', 'door', 'window', 'cased', 'closet', 'mep'];

        // Also allow deleting standalone walls (walls without roomId)
        let canDelete = sel.type && sel.id && deletableTypes.includes(sel.type);
        if (sel.type === 'wall' && sel.id) {
            const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
            if (wall && !wall.roomId) {
                canDelete = true;  // Standalone wall can be deleted
            }
        }

        if (deleteBtn) {
            deleteBtn.disabled = !canDelete;
            deleteBtn.style.opacity = canDelete ? '1' : '0.4';
            deleteBtn.style.background = canDelete ? 'var(--accent-red)' : '';
            deleteBtn.style.color = canDelete ? 'white' : '';
        }

        // Show/hide room type section based on room selection
        const roomTypeSection = $('#roomTypeSection');
        const roomTypeSelect = $('#roomTypeSelect');
        if (roomTypeSection && roomTypeSelect) {
            if (sel.type === 'room' && sel.id) {
                const room = this.doc.rooms.find(r => r.id === sel.id);
                if (room) {
                    roomTypeSection.style.display = 'block';
                    roomTypeSelect.value = room.type;
                } else {
                    roomTypeSection.style.display = 'none';
                }
            } else {
                roomTypeSection.style.display = 'none';
            }
        }

        // Show/hide wall section based on wall selection
        const wallSection = $('#wallSection');
        const selectedWallLabel = $('#selectedWallLabel');
        if (wallSection) {
            if (sel.type === 'wall' && sel.id) {
                const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
                if (wall && wall.roomId) {
                    wallSection.style.display = 'block';
                    if (selectedWallLabel) {
                        selectedWallLabel.textContent = wall.label;
                    }
                } else {
                    wallSection.style.display = 'none';
                }
            } else {
                wallSection.style.display = 'none';
            }
        }
    },

    deleteSelected() {
        const sel = Render.selection;
        if (sel.type && sel.id) {
            this.deleteObject(sel.id, sel.type);
        }
    },

    // Rotate selected object by 90 degrees (rooms and radiators only)
    rotateSelected() {
        const sel = Render.selection;
        if (!sel.type || !sel.id) return;

        if (sel.type === 'room') {
            // Rooms: rotate 90 degrees (swap width/height)
            const room = this.doc.rooms.find(r => r.id === sel.id);
            if (room) {
                const g = room.geometry;
                const oldW = g.width;
                const oldH = g.height;
                // Swap dimensions
                g.width = oldH;
                g.height = oldW;
                // Recreate wall segments for new dimensions
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    if (ws.label === 'W1') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                    if (ws.label === 'W2') { ws.x1 = g.x + g.width; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y; }
                    if (ws.label === 'W3') { ws.x1 = g.x + g.width; ws.y1 = g.y; ws.x2 = g.x; ws.y2 = g.y; }
                    if (ws.label === 'W4') { ws.x1 = g.x; ws.y1 = g.y; ws.x2 = g.x; ws.y2 = g.y + g.height; }
                });
                this.saveState();
                this.render();
                this.updateTree();
            }
        } else if (sel.type === 'mep') {
            // Only radiators can rotate
            const mep = this.doc.mep.find(m => m.id === sel.id);
            if (mep && mep.label.startsWith('RAD')) {
                mep.rotation = ((mep.rotation || 0) + 90) % 360;
                this.saveState();
                this.render();
            }
        }
    },

    // Change room type
    changeRoomType(newType) {
        const sel = Render.selection;
        if (sel.type !== 'room' || !sel.id) return;

        const room = this.doc.rooms.find(r => r.id === sel.id);
        if (!room) return;

        room.type = newType;
        this.saveState();
        this.render();
        this.updateTree();
    },

    // Set selected wall as W1, renumber others clockwise
    setAsW1() {
        const sel = Render.selection;
        if (sel.type !== 'wall' || !sel.id) return;

        const selectedWall = this.doc.wallSegments.find(ws => ws.id === sel.id);
        if (!selectedWall || !selectedWall.roomId) return;

        // Get all walls for this room
        const roomWalls = this.doc.wallSegments.filter(ws => ws.roomId === selectedWall.roomId);
        if (roomWalls.length === 0) return;

        // Find the current index of the selected wall
        const currentIndex = selectedWall.index;

        // Renumber walls: selected becomes W1, then clockwise
        roomWalls.forEach(wall => {
            // Calculate new index: offset from selected wall's position
            let newIndex = wall.index - currentIndex + 1;
            if (newIndex <= 0) newIndex += roomWalls.length;

            wall.index = newIndex;
            wall.label = 'W' + newIndex;
        });

        // Sort walls by new index to ensure consistent order
        roomWalls.sort((a, b) => a.index - b.index);

        this.saveState();
        this.render();
        this.updateTree();
        this.updateInspector();
    },

    deleteObject(objId, objType) {
        // Handle standalone wall deletion
        if (objType === 'wall') {
            const wall = this.doc.wallSegments.find(ws => ws.id === objId);
            if (wall && !wall.roomId) {
                // Only delete standalone walls (not part of a room)
                const index = this.doc.wallSegments.findIndex(ws => ws.id === objId);
                if (index !== -1) {
                    this.doc.wallSegments.splice(index, 1);
                    this.saveState();
                    Render.deselect();
                    this.render();
                    this.updateTree();
                    this.updateInspector();
                    this.updateQABadge();
                }
            }
            return;
        }

        // Handle room deletion
        if (objType === 'room') {
            const roomIndex = this.doc.rooms.findIndex(r => r.id === objId);
            if (roomIndex !== -1) {
                // Get all wall segments for this room
                const roomWallIds = this.doc.wallSegments
                    .filter(ws => ws.roomId === objId)
                    .map(ws => ws.id);

                // Delete all attached objects (doors, windows, cased openings, MEP)
                this.doc.doors = this.doc.doors.filter(d => !roomWallIds.includes(d.parentWallSegmentId));
                this.doc.windows = this.doc.windows.filter(w => !roomWallIds.includes(w.parentWallSegmentId));
                this.doc.casedOpenings = this.doc.casedOpenings.filter(c => !roomWallIds.includes(c.parentWallSegmentId));
                this.doc.mep = this.doc.mep.filter(m => !roomWallIds.includes(m.parentWallSegmentId));

                // Delete closets that belong to this room
                this.doc.closets = this.doc.closets.filter(c => c.parentRoomId !== objId);

                // Delete wall segments
                this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== objId);

                // Delete the room
                this.doc.rooms.splice(roomIndex, 1);

                // Recalculate exterior walls
                markExteriorWalls(this.doc);

                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
            return;
        }

        // Only allow deleting actual objects
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
        if (!deletableTypes.includes(objType)) {
            return;  // Silently ignore non-deletable types
        }

        let collection, index;
        if (objType === 'door') {
            collection = this.doc.doors;
        } else if (objType === 'window') {
            collection = this.doc.windows;
        } else if (objType === 'cased') {
            collection = this.doc.casedOpenings;
        } else if (objType === 'closet') {
            collection = this.doc.closets;
        } else if (objType === 'mep') {
            collection = this.doc.mep;
        }

        if (collection) {
            index = collection.findIndex(o => o.id === objId);
            if (index !== -1) {
                const obj = collection[index];
                // Remove from wall's attachedObjects
                if (obj.parentWallSegmentId) {
                    const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
                    if (ws) {
                        ws.attachedObjects = ws.attachedObjects.filter(a => a.id !== objId);
                    }
                }
                // Remove from collection
                collection.splice(index, 1);

                // If deleting a closet, also delete its wall segments
                if (objType === 'closet') {
                    this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== objId);
                }

                // Clear selection and save state
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
        }
    },

    updateObjectWidth(objId, objType, newWidthFeet) {
        const width = parseFloat(newWidthFeet) * FOOT;
        if (isNaN(width) || width < 1 * FOOT || width > 12 * FOOT) {
            alert('Width must be between 1 and 12 feet');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            obj.width = width;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateObjectOffset(objId, objType, newOffsetFeet) {
        const offset = parseFloat(newOffsetFeet) * FOOT;
        if (isNaN(offset) || offset < 0) {
            alert('Offset must be 0 or greater');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;
        else if (objType === 'mep') collection = this.doc.mep;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            // Validate offset doesn't exceed wall length
            const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
            if (ws) {
                const maxOffset = getSegmentLength(ws) - (obj.width || 0);
                if (offset > maxOffset) {
                    alert(`Offset too large. Max: ${(maxOffset / FOOT).toFixed(1)} ft`);
                    return;
                }
            }
            obj.distanceFromStart = offset;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateTree() {
        const tree = $('#objectTree');
        tree.innerHTML = '';

        const addGroup = (title, items, color, type) => {
            if (items.length === 0) return;
            const grp = document.createElement('div');
            grp.className = 'tree-group';
            grp.innerHTML = `<div class="tree-label">${title} (${items.length})</div>`;
            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'tree-item';
                el.dataset.type = type;
                el.dataset.id = item.id;
                const ws = this.doc.wallSegments.find(s => s.id === item.parentWallSegmentId);
                const wallInfo = ws ? ` → ${ws.label}` : '';
                el.innerHTML = `<div class="tree-dot" style="background:${color}"></div><span>${item.label}${item.type ? ' (' + item.type + ')' : ''}${wallInfo}</span>`;
                el.onclick = () => this.onObjectTap(type, item.id);
                grp.appendChild(el);
            });
            tree.appendChild(grp);
        };

        // Rooms with wall segments and child closets
        if (this.doc.rooms.length > 0) {
            const roomGrp = document.createElement('div');
            roomGrp.className = 'tree-group';
            roomGrp.innerHTML = `<div class="tree-label">ROOMS (${this.doc.rooms.length})</div>`;
            this.doc.rooms.forEach(room => {
                const roomEl = document.createElement('div');
                roomEl.className = 'tree-item';
                roomEl.dataset.type = 'room';
                roomEl.dataset.id = room.id;
                roomEl.innerHTML = `<div class="tree-dot" style="background:#f4d03f"></div><span>${room.type} (${room.label})</span>`;
                roomEl.onclick = () => this.onObjectTap('room', room.id);
                roomGrp.appendChild(roomEl);

                // Wall segments under room
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    const wsEl = document.createElement('div');
                    wsEl.className = 'tree-item';
                    wsEl.style.paddingLeft = '20px';
                    wsEl.dataset.type = 'wall';
                    wsEl.dataset.id = ws.id;
                    wsEl.innerHTML = `<div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>${ws.label} (${ws.side}) [${ws.attachedObjects.length}]</span>`;
                    wsEl.onclick = () => this.onWallTap(ws.id);
                    roomGrp.appendChild(wsEl);
                });

                // Child closets under room
                const childClosets = this.doc.closets.filter(c => c.parentRoomId === room.id);
                childClosets.forEach(closet => {
                    const closetEl = document.createElement('div');
                    closetEl.className = 'tree-item';
                    closetEl.style.paddingLeft = '20px';
                    closetEl.dataset.type = 'closet';
                    closetEl.dataset.id = closet.id;
                    closetEl.innerHTML = `<div class="tree-dot" style="background:#9ca3af"></div><span>↳ ${closet.label} (Closet)</span>`;
                    closetEl.onclick = () => this.onObjectTap('closet', closet.id);
                    roomGrp.appendChild(closetEl);

                    // Closet's wall segments
                    const closetSegs = this.doc.wallSegments.filter(ws => ws.roomId === closet.id);
                    closetSegs.forEach(ws => {
                        const wsEl = document.createElement('div');
                        wsEl.className = 'tree-item';
                        wsEl.style.paddingLeft = '36px';
                        wsEl.dataset.type = 'wall';
                        wsEl.dataset.id = ws.id;
                        wsEl.innerHTML = `<div class="tree-dot" style="background:#aaa;width:5px;height:5px"></div><span>${ws.label} (${ws.side})</span>`;
                        wsEl.onclick = () => this.onWallTap(ws.id);
                        roomGrp.appendChild(wsEl);
                    });
                });
            });
            tree.appendChild(roomGrp);
        }

        // Orphan closets (no parent room)
        const orphanClosets = this.doc.closets.filter(c => !c.parentRoomId || !this.doc.rooms.find(r => r.id === c.parentRoomId));
        if (orphanClosets.length > 0) {
            addGroup('UNLINKED CLOSETS', orphanClosets, '#ef4444', 'closet');
        }

        addGroup('DOORS', this.doc.doors, '#3b82f6', 'door');
        addGroup('WINDOWS', this.doc.windows, '#87ceeb', 'window');
        addGroup('OPENINGS', this.doc.casedOpenings, '#aaa', 'cased');
        addGroup('MEP', this.doc.mep, '#22c55e', 'mep');
    },

    highlightTreeItem(type, id) {
        $$('.tree-item').forEach(el => el.classList.remove('selected'));
        const el = document.querySelector(`.tree-item[data-type="${type}"][data-id="${id}"]`);
        if (el) el.classList.add('selected');
    },

    toggle(what) {
        switch (what) {
            case 'grid':
                this.showGrid = !this.showGrid;
                const btnGrid = $('#btnGrid');
                if (btnGrid) btnGrid.classList.toggle('active', this.showGrid);
                // Toggle CSS grid background on canvas-wrap
                const canvasWrap = document.querySelector('.canvas-wrap');
                if (canvasWrap) {
                    canvasWrap.style.backgroundImage = this.showGrid ? '' : 'none';
                }
                break;
            case 'wallIds':
                this.showWallIds = !this.showWallIds;
                const btnWallIds = $('#btnWallIds');
                if (btnWallIds) btnWallIds.classList.toggle('active', this.showWallIds);
                this.render();
                break;
            case 'dims':
                this.showDims = !this.showDims;
                const btnDims = $('#btnDims');
                if (btnDims) btnDims.classList.toggle('active', this.showDims);
                this.render();
                break;
        }
        Render.stage.batchDraw();
    },

    toggleSidebar() { $('#sidebarLeft').classList.toggle('collapsed'); },

    northRotation: 0,
    rotateNorth() {
        this.northRotation = (this.northRotation + 45) % 360;
        const arrow = $('#compassArrow');
        if (arrow) {
            arrow.style.transform = `rotate(${this.northRotation}deg)`;
        }
    },

    toggleObjectPanel() {
        const tree = $('#objectTree');
        const toggle = $('#objectToggle');
        tree.classList.toggle('collapsed');
        toggle.textContent = tree.classList.contains('collapsed') ? '▶' : '▼';
    },

    resetView() {
        Render.stage.scale({ x: 1, y: 1 });
        Render.stage.position({ x: 0, y: 0 });
        Render.stage.batchDraw();
    },

    // Select all rooms and closets
    selectAll() {
        Render.selectAll(this.doc);
        this.render();
        this.updateInspector();
    },

    // Copy selected objects to clipboard
    copySelected() {
        this.clipboard = [];

        // Get all selected items (single or multi)
        const selected = Render.multiSelection.length > 0
            ? Render.multiSelection
            : (Render.selection.type ? [Render.selection] : []);

        if (selected.length === 0) {
            alert('Nothing selected to copy');
            return;
        }

        selected.forEach(sel => {
            if (sel.type === 'room') {
                const room = this.doc.rooms.find(r => r.id === sel.id);
                if (room) {
                    this.clipboard.push({
                        type: 'room',
                        data: JSON.parse(JSON.stringify(room))
                    });
                }
            } else if (sel.type === 'closet') {
                const closet = this.doc.closets.find(c => c.id === sel.id);
                if (closet) {
                    this.clipboard.push({
                        type: 'closet',
                        data: JSON.parse(JSON.stringify(closet))
                    });
                }
            }
        });

        const hint = $('#toolHint');
        hint.textContent = `Copied ${this.clipboard.length} item(s). Press Ctrl+V to paste.`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    // Paste from clipboard
    paste() {
        if (this.clipboard.length === 0) {
            alert('Nothing to paste');
            return;
        }

        const offset = 2 * FOOT; // Offset pasted items

        this.clipboard.forEach(item => {
            if (item.type === 'room') {
                const newRoom = JSON.parse(JSON.stringify(item.data));
                newRoom.id = Doc.uid();
                newRoom.label = Doc.label(this.doc, 'room');
                newRoom.geometry.x += offset;
                newRoom.geometry.y += offset;
                createWallSegments(newRoom, this.doc);
                this.doc.rooms.push(newRoom);
                markExteriorWalls(this.doc);
            } else if (item.type === 'closet') {
                const newCloset = JSON.parse(JSON.stringify(item.data));
                newCloset.id = Doc.uid();
                newCloset.label = Doc.label(this.doc, 'closet');
                newCloset.geometry.x += offset;
                newCloset.geometry.y += offset;
                createWallSegments(newCloset, this.doc);
                this.doc.closets.push(newCloset);
            }
        });

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        const hint = $('#toolHint');
        hint.textContent = `Pasted ${this.clipboard.length} item(s)`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    updateQABadge() {
        const results = runQA(this.doc);
        const fails = results.filter(r => !r.pass).length;
        const badge = $('#qaBadge');
        badge.textContent = fails === 0 ? 'QA: PASS' : `QA: ${fails} errors`;
        badge.className = 'qa-badge' + (fails > 0 ? ' error' : '');
    },

    showQA() {
        const results = runQA(this.doc);
        $('#qaContent').innerHTML = results.map(r => `
            <div class="qa-item">
                <span class="${r.pass ? 'qa-pass' : 'qa-fail'}">${r.pass ? '✓' : '✗'}</span>
                <span>${r.rule}</span>
                <span style="color:#888;margin-left:auto">${r.detail}</span>
            </div>
        `).join('');
        $('#qaModal').classList.add('show');
    },

    hideModal(which) { $(`#${which}Modal`).classList.remove('show'); },

    loadFBG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);
                this.doc = this.importFBG(data);
                this.undoStack = [];
                this.redoStack = [];
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateQABadge();
                this.updateInspector();
                this.updateUndoRedoButtons();
            } catch (err) { alert('Load error: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    },

    importFBG(data) {
        const doc = Doc.create();
        doc.address = data.address || '';
        const level = data.levels?.[data.currentLevelIndex || 0];
        if (!level) return doc;

        const objs = level.canvasObjects || [];
        let minX = Infinity, minY = Infinity;
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                minX = Math.min(minX, o.startX || 0, o.endX || 0);
                minY = Math.min(minY, o.startY || 0, o.endY || 0);
            }
        });
        const offX = isFinite(minX) ? 60 - minX : 0;
        const offY = isFinite(minY) ? 60 - minY : 0;

        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                if (isCloset) {
                    const closet = { id: Doc.uid(), label: Doc.label(doc, 'closet'), fbgName: o.name, type: 'Closet', roomType: 'Closet', isExterior: false, geometry: { x, y, width: w, height: h } };
                    createWallSegments(closet, doc);
                    doc.closets.push(closet);
                } else {
                    const room = { id: Doc.uid(), label: Doc.label(doc, 'room'), type: rt.name || abbr, fbgName: o.name, isExterior: true, geometry: { x, y, width: w, height: h } };
                    createWallSegments(room, doc);
                    doc.rooms.push(room);
                }
            }
        });
        return doc;
    },

    exportPDF() {
        const qa = runQA(this.doc);
        const fails = qa.filter(r => !r.pass).length;
        if (fails > 0 && !confirm(`QA has ${fails} errors. Export anyway?`)) return;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'pt', 'letter');

        pdf.setFontSize(14);
        pdf.text('2BR/1BA Blueprint - Wall Segment Attachments', 40, 30);
        pdf.setFontSize(9);
        pdf.text(`Address: ${this.doc.address}`, 40, 45);
        pdf.text(`Date: ${new Date().toLocaleDateString()}`, 40, 57);
        pdf.text(`Rooms: ${this.doc.rooms.length} | Doors: ${this.doc.doors.length} | Windows: ${this.doc.windows.length}`, 40, 69);
        pdf.text(`QA: ${fails === 0 ? 'PASS' : fails + ' errors'}`, 300, 45);

        const img = Render.getImage();
        if (img) pdf.addImage(img, 'PNG', 40, 85, 700, 420);

        pdf.setFontSize(7);
        pdf.text('Wall IDs: W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south-most wall)', 40, 520);

        // Attachment summary
        let y = 535;
        pdf.setFontSize(8);
        pdf.text('Attachments:', 40, y);
        y += 10;
        this.doc.wallSegments.forEach(ws => {
            if (ws.attachedObjects.length > 0) {
                let room = this.doc.rooms.find(r => r.id === ws.roomId);
                if (!room) room = this.doc.closets.find(c => c.id === ws.roomId);
                const items = ws.attachedObjects.map(a => a.label).join(', ');
                pdf.text(`${room?.label} ${ws.label}: ${items}`, 50, y);
                y += 9;
                if (y > 580) { y = 535; pdf.addPage(); }
            }
        });

        pdf.save(`Blueprint_WallAttach_${new Date().toISOString().split('T')[0]}.pdf`);
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// Keyboard shortcut for delete (objects and standalone walls)
document.addEventListener('keydown', (e) => {
    const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep'];
    if ((e.key === 'Delete' || e.key === 'Backspace') && Render.selection.type && Render.selection.id) {
        // Don't delete if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // Check if it's a deletable type or a standalone wall
        let canDelete = deletableTypes.includes(Render.selection.type);
        if (Render.selection.type === 'wall') {
            const wall = App.doc.wallSegments.find(ws => ws.id === Render.selection.id);
            canDelete = wall && !wall.roomId;  // Only standalone walls
        }

        if (!canDelete) return;
        e.preventDefault();
        App.deleteObject(Render.selection.id, Render.selection.type);
    }
});
</script>
</body>
</html>
