<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Blueprint Builder - Wall Segment Selection</title>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-canvas: #ffffff;
            --bg-panel: rgba(245, 247, 250, 0.92);
            --bg-tool: rgba(255, 255, 255, 0.8);
            --bg-tool-hover: rgba(59, 130, 246, 0.1);
            --border: transparent;
            --text: #1f2937;
            --text-dim: #6b7280;
            --accent: #2563eb;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-orange: #f97316;
            --accent-cyan: #06b6d4;
            --wall-color: #2d3748;
            --grid-color: #bfdbfe;
            --grid-major: #93c5fd;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', sans-serif; background: var(--bg-canvas); color: var(--text); height: 100vh; height: 100dvh; overflow: hidden; touch-action: none; }
        .app { display: flex; flex-direction: column; height: 100%; }

        .main { display: flex; flex: 1; overflow: hidden; position: relative; height: 100%; }

        .sidebar-left { width: 180px; background: rgba(245, 247, 250, 0.75); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border-right: none; display: flex; flex-direction: column; overflow: hidden; transition: width 0.2s ease; position: relative; z-index: 10; box-shadow: 4px 0 12px rgba(0, 0, 0, 0.15); }
        .sidebar-left.collapsed { width: 52px; overflow: hidden; }
        .sidebar-left.collapsed .sidebar-scroll { padding: 4px; overflow-x: hidden; }
        .sidebar-left.collapsed .section { overflow: hidden; }
        .sidebar-left.collapsed .section-header { display: none; }
        .sidebar-left.collapsed .section-content { padding: 2px; overflow: hidden; }
        .sidebar-left.collapsed .tool-grid { grid-template-columns: 1fr !important; gap: 4px; }
        .sidebar-left.collapsed .tool-btn { min-height: 40px; padding: 6px; width: 40px; max-width: 40px; }
        .sidebar-left.collapsed .tool-btn span { display: none !important; }
        .sidebar-left.collapsed .tool-btn svg { margin-bottom: 0; }
        .sidebar-left.collapsed #objectSection { display: none !important; }
        .sidebar-left.collapsed .sidebar-toggle { writing-mode: vertical-rl; text-orientation: mixed; padding: 12px 8px; }
        .sidebar-left.collapsed .helper-text { display: none !important; }
        .sidebar-left.collapsed .tool-select { display: none !important; }
        .sidebar-left.collapsed #roomTypeSection { display: none !important; }
        .sidebar-left.collapsed #wallSection { display: none !important; }
        .sidebar-left.collapsed #sampleListContainer { display: none !important; }
        .sidebar-left.collapsed .section-content > div:not(.tool-grid) { display: none !important; }
        .helper-text { padding: 4px 8px; font-size: 9px; color: var(--text-dim); margin-top: 4px; }
        .tool-select { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg-tool); color: var(--text); font-size: 11px; cursor: pointer; }
        .door-type-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 12px 8px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; cursor: pointer; transition: all 0.15s ease; min-height: 80px; }
        .door-type-btn:hover { background: #eff6ff; border-color: #3b82f6; transform: translateY(-2px); }
        .door-type-btn:active { background: #dbeafe; transform: translateY(0); }
        .door-type-btn svg { width: 40px; height: 40px; margin-bottom: 6px; color: #334155; }
        .door-type-btn span { font-size: 10px; font-weight: 600; color: #475569; }
        .sidebar-toggle { padding: 10px; background: transparent; border: none; color: var(--accent); font-size: 16px; cursor: pointer; border-bottom: none; }
        .sidebar-scroll { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 8px; scrollbar-width: none; -ms-overflow-style: none; }
        .sidebar-scroll::-webkit-scrollbar { display: none; }
        .section { margin-bottom: 12px; }
        .section-header { padding: 6px 8px; font-size: 9px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .section-content { padding: 4px; }
        .section-content.collapsed { display: none; }

        .tool-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .tool-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px 4px; background: var(--bg-tool); border: none; border-radius: 10px; color: var(--text); font-size: 8px; font-weight: 500; cursor: pointer; min-height: 48px; transition: all 0.15s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .tool-btn:hover { background: var(--bg-tool-hover); transform: translateY(-1px); }
        .tool-btn:active, .tool-btn.active { background: var(--accent-blue); color: white; }
        .tool-btn svg { width: 20px; height: 20px; margin-bottom: 3px; }
        .tool-btn svg * { stroke: currentColor; fill: none; stroke-width: 1.5; }
        .tool-btn.filled svg * { fill: currentColor; stroke: none; }

        .tree-group { margin-bottom: 8px; }
        .tree-label { font-size: 9px; color: var(--accent); padding: 4px 8px; font-weight: 600; }
        .tree-item { display: flex; align-items: center; gap: 6px; padding: 6px 10px; font-size: 10px; cursor: pointer; border-radius: 6px; transition: background 0.1s; }
        .tree-item:hover { background: var(--bg-tool-hover); }
        .tree-item:active, .tree-item.selected { background: rgba(59,130,246,0.2); }
        .tree-dot { width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0; }

        .canvas-wrap {
            flex: 1;
            position: relative;
            overflow: hidden;
            /* Blueprint blue background - grid is rendered on Konva layer */
            background-color: #f0f7ff;
        }
        #stage { width: 100%; height: 100%; }
        .north-arrow { position: absolute; top: 12px; right: 12px; width: 44px; height: 44px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--accent); border: 2px solid var(--accent); box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; transition: transform 0.3s ease; }
        .north-arrow svg { width: 28px; height: 28px; transition: transform 0.3s ease; }
        .north-arrow .arrow-n { fill: var(--accent-red); }
        .north-arrow .arrow-s { fill: #666; }
        .north-arrow:hover { transform: scale(1.05); }
        .scale-label { position: absolute; bottom: 12px; left: 12px; background: rgba(255,255,255,0.9); backdrop-filter: blur(8px); padding: 6px 12px; border-radius: 6px; font-size: 10px; color: var(--text-dim); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .badge-container { position: absolute; top: 12px; left: 12px; display: flex; gap: 8px; align-items: center; z-index: 50; }
        .qa-badge { background: var(--accent-green); color: #fff; padding: 5px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; white-space: nowrap; }
        .qa-badge.error { background: var(--accent-red); }
        .qa-badge.warning { background: var(--accent-orange); }
        .floor-badge { background: var(--accent-blue); color: #fff; padding: 5px 12px; border-radius: 20px; font-size: 10px; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; display: flex; align-items: center; gap: 4px; white-space: nowrap; position: relative; }
        .floor-badge:hover { background: #2563eb; }
        .floor-badge svg { width: 10px; height: 10px; }
        .floor-dropdown { position: absolute; top: 28px; left: 0; background: white; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.2); min-width: 140px; display: none; z-index: 200; overflow: hidden; }
        .floor-dropdown.show { display: block; }
        .floor-dropdown-item { padding: 10px 14px; font-size: 11px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; color: #333; }
        .floor-dropdown-scroll { max-height: 240px; overflow-y: auto; }
        .floor-dropdown-add { padding: 10px 14px; font-size: 11px; cursor: pointer; color: var(--accent-blue); font-weight: 600; display: flex; align-items: center; gap: 6px; border-top: 1px solid #e5e7eb; background: #f9fafb; }
        .floor-dropdown-add:hover { background: #eff6ff; }
        .floor-dropdown-nav { display: flex; justify-content: space-between; padding: 6px 10px; background: #f5f5f5; border-top: 1px solid #e5e7eb; }
        .floor-dropdown-nav button { background: none; border: none; color: var(--accent-blue); font-size: 10px; cursor: pointer; padding: 4px 8px; border-radius: 4px; }
        .floor-dropdown-nav button:hover { background: #e5e7eb; }
        .floor-dropdown-nav button:disabled { color: #ccc; cursor: not-allowed; }
        .floor-dropdown-item:last-child { border-bottom: none; }
        .floor-dropdown-item:hover { background: #f5f5f5; }
        .floor-dropdown-item.active { background: #eff6ff; color: var(--accent-blue); font-weight: 600; }
        .floor-dropdown-item .check { color: var(--accent-green); font-weight: bold; }
        .tool-hint { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 10px; font-size: 11px; color: var(--accent); display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .tool-hint.show { display: block; }

        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); display: none; align-items: center; justify-content: center; z-index: 1000; padding: 20px; touch-action: auto; }
        .modal.show { display: flex; }
        .modal-box { background: white; border: none; border-radius: 16px; max-width: 420px; width: 100%; max-height: 80vh; overflow: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.2); touch-action: auto; }
        .modal-head { padding: 16px 20px; border-bottom: 1px solid #f3f4f6; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 15px; font-weight: 600; color: var(--text); }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; padding: 8px; }
        .modal-body { padding: 20px; font-size: 12px; touch-action: auto; }
        .modal-body input { touch-action: auto; }
        .qa-item { padding: 8px 0; border-bottom: 1px solid #f3f4f6; display: flex; align-items: center; gap: 10px; }
        .qa-pass { color: var(--accent-green); }
        .qa-fail { color: var(--accent-red); }
        .qa-warn { color: var(--accent-orange); }

        @media (max-width: 768px) {
            /* Mobile: sidebar starts expanded, toggle works via .collapsed class */
            .sidebar-left { width: 160px; }
            .sidebar-left .tool-grid { grid-template-columns: 1fr 1fr; gap: 4px; }
            .sidebar-left .tool-btn { min-height: 44px; padding: 6px; }
            .sidebar-left .tool-btn span { font-size: 7px; }
            .sidebar-left #objectSection { display: none; }
            /* Mobile collapsed state */
            .sidebar-left.collapsed { width: 48px; overflow: hidden; }
            .sidebar-left.collapsed .sidebar-scroll { padding: 4px; overflow-x: hidden; }
            .sidebar-left.collapsed .section { overflow: hidden; }
            .sidebar-left.collapsed .section-header { display: none !important; }
            .sidebar-left.collapsed .section-content { padding: 2px; overflow: hidden; }
            .sidebar-left.collapsed .tool-grid { grid-template-columns: 1fr !important; }
            .sidebar-left.collapsed .tool-btn { width: 36px; max-width: 36px; }
            .sidebar-left.collapsed .tool-btn span { display: none !important; }
            .sidebar-left.collapsed .helper-text { display: none !important; }
            .sidebar-left.collapsed .tool-select { display: none !important; }
            .sidebar-left.collapsed #roomTypeSection { display: none !important; }
            .sidebar-left.collapsed #wallSection { display: none !important; }
            .sidebar-left.collapsed #objectSection { display: none !important; }
            .sidebar-left.collapsed .tool-btn svg { margin-bottom: 0; }
            .sidebar-left.collapsed .section-content > div:not(.tool-grid) { display: none !important; }
            .north-arrow { width: 36px; height: 36px; top: 8px; right: 8px; }
            .north-arrow svg { width: 22px; height: 22px; }
            .scale-label { font-size: 9px; padding: 4px 8px; bottom: 8px; left: 8px; }
            .badge-container { top: 8px; left: 8px; gap: 6px; }
            .qa-badge { font-size: 9px; padding: 4px 10px; }
            .floor-badge { font-size: 9px; padding: 4px 10px; }
            .floor-dropdown { top: 26px; }
            .tool-hint { font-size: 10px; padding: 8px 14px; bottom: 40px; }
        }
        input[type="file"] { display: none; }
    </style>

<script>
// Embedded project data - loaded automatically on startup
window.EMBEDDED_PROJECT_DATA = {"version":"1.0","savedAt":"2026-01-24T09:26:23.469Z","currentFloor":"floor1","floorList":["floor1"],"floorLabels":{"floor1":"Floor 1"},"floors":{"floor1":{"id":"id_1j3olrftvmks38y4y","version":"4.0","address":"2BR/1BA Blueprint","sampleSheetNumber":"55555","counters":{"room":1,"wallSegment":0,"door":1,"window":0,"closet":0,"cased":0,"pipe":0,"gas":0,"riser":0,"radiator":0,"poe":0,"dustwipe":0},"rooms":[{"id":"id_7uasr9sl2mks3d0to","label":"Rm-01","type":"Bedroom 1","isExterior":true,"geometry":{"x":144,"y":240,"width":192,"height":240},"vertices":[{"x":144,"y":240},{"x":336,"y":240},{"x":336,"y":480},{"x":144,"y":480}],"wallSegmentIds":["id_mp8oyyvzpmks3dlc2","id_15mpiekmcmks3dlc2","id_4bjbhuuupmks3dlc2","id_oc38cnz2dmks3dlc2"]}],"wallSegments":[{"id":"id_mp8oyyvzpmks3dlc2","roomId":"id_7uasr9sl2mks3d0to","roomLabel":"Rm-01","index":1,"label":"W1","side":"south","x1":336,"y1":480,"x2":144,"y2":480,"thickness":24,"type":"exterior","attachedObjects":[]},{"id":"id_15mpiekmcmks3dlc2","roomId":"id_7uasr9sl2mks3d0to","roomLabel":"Rm-01","index":2,"label":"W2","side":"east","x1":144,"y1":480,"x2":144,"y2":240,"thickness":24,"type":"exterior","attachedObjects":[]},{"id":"id_4bjbhuuupmks3dlc2","roomId":"id_7uasr9sl2mks3d0to","roomLabel":"Rm-01","index":3,"label":"W3","side":"south","x1":144,"y1":240,"x2":336,"y2":240,"thickness":24,"type":"exterior","attachedObjects":[]},{"id":"id_oc38cnz2dmks3dlc2","roomId":"id_7uasr9sl2mks3d0to","roomLabel":"Rm-01","index":4,"label":"W4","side":"east","x1":336,"y1":240,"x2":336,"y2":480,"thickness":24,"type":"exterior","attachedObjects":[]}],"doors":[],"windows":[],"casedOpenings":[],"closets":[],"mep":[],"dustWipes":[],"dimensions":[]}}};
</script>
</head>
<body>
<div class="app">
    <input type="file" id="fbgInput" accept=".fbg,.fgs,.json,.html" onchange="App.loadFBG(event)">
    <div class="main">
        <div class="sidebar-left" id="sidebarLeft">
            <button class="sidebar-toggle" onclick="App.toggleSidebar()">☰</button>
            <div class="sidebar-scroll">
                <div class="section">
                    <div class="section-header">File</div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr 1fr;">
                            <button class="tool-btn" onclick="App.newDoc()" title="New document">
                                <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"></path><polyline points="14,2 14,8 20,8" stroke="currentColor" fill="none" stroke-width="2"></polyline><line x1="12" y1="18" x2="12" y2="12" stroke="currentColor" stroke-width="2"></line><line x1="9" y1="15" x2="15" y2="15" stroke="currentColor" stroke-width="2"></line></svg>
                                <span>New</span>
                            </button>
                            <button class="tool-btn" onclick="App.saveProject()" title="Save project (choose format)">
                                <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z" stroke="currentColor" fill="none" stroke-width="2"></path><polyline points="17,21 17,13 7,13 7,21" stroke="currentColor" fill="none" stroke-width="2"></polyline><polyline points="7,3 7,8 15,8" stroke="currentColor" fill="none" stroke-width="2"></polyline></svg>
                                <span>Save</span>
                            </button>
                            <button class="tool-btn" onclick="$('#fbgInput').click()" title="Load file">
                                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4" stroke="currentColor" fill="none" stroke-width="2"></path><polyline points="17,8 12,3 7,8" stroke="currentColor" fill="none" stroke-width="2"></polyline><line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2"></line></svg>
                                <span>Load</span>
                            </button>
                            <button class="tool-btn" onclick="App.exportPDF()" title="Export PDF">
                                <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"></path><polyline points="14,2 14,8 20,8" stroke="currentColor" fill="none" stroke-width="2"></polyline><text x="8" y="17" font-size="6" fill="currentColor" stroke="none">PDF</text></svg>
                                <span>PDF</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Tools</div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr 1fr;">
                            <button class="tool-btn active" id="btnSelect" onclick="App.setTool('select')" title="Select and move objects"><svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" stroke="currentColor" fill="none" stroke-width="2" stroke-linejoin="round"></path></svg><span>Select</span></button>
                            <button class="tool-btn" onclick="App.setTool('room')" title="Draw a new room"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1" stroke-dasharray="3,2"></rect><line x1="12" y1="8" x2="12" y2="16" stroke-width="2"></line><line x1="8" y1="12" x2="16" y2="12" stroke-width="2"></line></svg><span>Room</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Openings</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.showDoorTypeSelector()" title="Select door type to place"><svg viewBox="0 0 24 24"><rect x="6" y="3" width="12" height="18" rx="1"></rect><circle cx="15" cy="12" r="1.5" fill="currentColor"></circle></svg><span>Door</span></button>
                            <button class="tool-btn" onclick="App.setTool('window')" title="Tap a wall to place window"><svg viewBox="0 0 24 24"><rect x="3" y="7" width="18" height="10" rx="1"></rect><line x1="12" y1="7" x2="12" y2="17"></line></svg><span>Window</span></button>
                            <button class="tool-btn" onclick="App.setTool('cased')" title="Cased opening (no door)"><svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke-dasharray="3,2"></line></svg><span>Cased</span></button>
                            <button class="tool-btn" onclick="App.setTool('wallbreak')" title="Break wall (create gap)"><svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="9" y2="12" stroke-width="3"></line><line x1="15" y1="12" x2="21" y2="12" stroke-width="3"></line><path d="M10 8l2 4-2 4M14 8l-2 4 2 4" stroke-width="1.5"></path></svg><span>Break</span></button>
                            <button class="tool-btn" onclick="App.setTool('partition')" title="Draw interior wall to divide room"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="1"></rect><line x1="12" y1="3" x2="12" y2="21" stroke-dasharray="3,2"></line></svg><span>Divide</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Display</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn active" id="btnDims" onclick="App.toggle('dims')" title="Toggle dimensions">
                                <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12" stroke="currentColor" stroke-width="2"></line><line x1="3" y1="8" x2="3" y2="16" stroke="currentColor" stroke-width="2"></line><line x1="21" y1="8" x2="21" y2="16" stroke="currentColor" stroke-width="2"></line><text x="9" y="10" font-size="6" fill="currentColor" stroke="none">12'</text></svg>
                                <span>Dims</span>
                            </button>
                            <button class="tool-btn active" id="btnGrid" onclick="App.toggle('grid')" title="Toggle grid">
                                <svg viewBox="0 0 24 24"><line x1="3" y1="3" x2="3" y2="21" stroke="currentColor" stroke-width="1.5"></line><line x1="9" y1="3" x2="9" y2="21" stroke="currentColor" stroke-width="1.5"></line><line x1="15" y1="3" x2="15" y2="21" stroke="currentColor" stroke-width="1.5"></line><line x1="21" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="1.5"></line><line x1="3" y1="3" x2="21" y2="3" stroke="currentColor" stroke-width="1.5"></line><line x1="3" y1="9" x2="21" y2="9" stroke="currentColor" stroke-width="1.5"></line><line x1="3" y1="15" x2="21" y2="15" stroke="currentColor" stroke-width="1.5"></line><line x1="3" y1="21" x2="21" y2="21" stroke="currentColor" stroke-width="1.5"></line></svg>
                                <span>Grid</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">MEP</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('pipe')" title="Tap wall to place pipe"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"></circle></svg><span>Pipe</span></button>
                            <button class="tool-btn filled" onclick="App.setTool('gas')" title="Tap wall to place gas line"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"></circle></svg><span>Gas</span></button>
                            <button class="tool-btn" onclick="App.setTool('radiator')" title="Tap wall to place radiator"><svg viewBox="0 0 24 24"><rect x="3" y="8" width="18" height="10" rx="1"></rect><line x1="6" y1="9" x2="6" y2="17"></line><line x1="9" y1="9" x2="9" y2="17"></line><line x1="12" y1="9" x2="12" y2="17"></line><line x1="15" y1="9" x2="15" y2="17"></line></svg><span>Rad</span></button>
                            <button class="tool-btn" onclick="App.setTool('riser')" title="Tap wall to place riser"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="3"></circle></svg><span>Riser</span></button>
                            <button class="tool-btn" onclick="App.setTool('poe')" title="Tap door to place Point of Entry"><svg viewBox="0 0 24 24"><polygon points="12,2 22,12 17,12 17,22 7,22 7,12 2,12" fill="currentColor"></polygon></svg><span>POE</span></button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Dust Wipes</div>
                    <div class="section-content">
                        <div class="helper-text" style="margin-bottom: 4px;">
                            Sheet: <strong id="sampleSheetDisplay">55555</strong>
                            <button onclick="App.changeSampleSheet()" style="margin-left: 8px; padding: 2px 6px; font-size: 9px; cursor: pointer;">Change</button>
                        </div>
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.setTool('dustwipe')" style="font-weight: bold;" title="Tap floor, wall, window, or door to place dust wipe sample">
                                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke="currentColor" stroke-width="2" fill="none"></circle><circle cx="12" cy="12" r="3" fill="currentColor"></circle></svg>
                                <span>Sample</span>
                            </button>
                        </div>
                        <div id="sampleListContainer" class="helper-text" style="margin-top: 8px; display: none; padding: 0;">
                            <div style="padding: 2px 8px; font-size: 9px; color: var(--text-dim);">Placed Samples:</div>
                            <select id="sampleList" class="tool-select" onchange="App.selectSampleFromList(this.value)"><option value="">-- Select sample --</option></select>
                        </div>
                    </div>
                </div>
                <div class="section" id="objectSection">
                    <div class="section-header" onclick="App.toggleObjectPanel()">Objects <span id="objectToggle">▶</span></div>
                    <div class="section-content collapsed" id="objectTree"><div class="tree-group"><div class="tree-label">ROOMS (1)</div><div class="tree-item" data-type="room" data-id="id_7uasr9sl2mks3d0to"><div class="tree-dot" style="background:#f4d03f"></div><span>Bedroom 1 (Rm-01)</span></div><div class="tree-item" data-type="wall" data-id="id_mp8oyyvzpmks3dlc2" style="padding-left: 20px;"><div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>W1 (south) [0]</span></div><div class="tree-item" data-type="wall" data-id="id_15mpiekmcmks3dlc2" style="padding-left: 20px;"><div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>W2 (east) [0]</span></div><div class="tree-item" data-type="wall" data-id="id_4bjbhuuupmks3dlc2" style="padding-left: 20px;"><div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>W3 (south) [0]</span></div><div class="tree-item" data-type="wall" data-id="id_oc38cnz2dmks3dlc2" style="padding-left: 20px;"><div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>W4 (east) [0]</span></div></div></div>
                </div>
                <div class="section" id="roomTypeSection" style="display: none;">
                    <div class="section-header">Room Settings</div>
                    <div class="section-content">
                        <select id="roomTypeSelect" class="tool-select" onchange="App.changeRoomType(this.value)" title="Select room type" style="margin-bottom: 8px;">
                            <option value="Room">Room</option>
                            <option value="Closet">Closet</option>
                            <option value="Bedroom 1">Bedroom 1</option>
                            <option value="Bedroom 2">Bedroom 2</option>
                            <option value="Bedroom 3">Bedroom 3</option>
                            <option value="Bedroom 4">Bedroom 4</option>
                            <option value="Bathroom 1">Bathroom 1</option>
                            <option value="Bathroom 2">Bathroom 2</option>
                            <option value="Kitchen">Kitchen</option>
                            <option value="Living Room">Living Room</option>
                            <option value="Dining Room">Dining Room</option>
                            <option value="Hallway 1">Hallway 1</option>
                            <option value="Hallway 2">Hallway 2</option>
                            <option value="Hallway 3">Hallway 3</option>
                            <option value="Foyer">Foyer</option>
                            <option value="Office">Office</option>
                            <option value="Den">Den</option>
                            <option value="Laundry">Laundry</option>
                            <option value="Garage">Garage</option>
                            <option value="Basement">Basement</option>
                            <option value="Attic">Attic</option>
                            <option value="Storage">Storage</option>
                            <option value="Utility">Utility</option>
                            <option value="Porch">Porch</option>
                            <option value="Sunroom">Sunroom</option>
                            <option value="Other">Other</option>
                        </select>
                        <div style="margin: 8px 0;">
                            <button class="tool-btn" id="addJointBtn" onclick="App.toggleAddJointMode()" title="Click wall to add a draggable joint" style="width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 8px; min-height: 36px;">
                                <svg viewBox="0 0 24 24" style="width: 16px; height: 16px;"><circle cx="12" cy="12" r="4" fill="currentColor"></circle><path d="M4 12h4M16 12h4M12 4v4M12 16v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"></path></svg>
                                <span id="addJointLabel">Add Joint</span>
                            </button>
                        </div>
                        <select id="wallStartSelect" class="tool-select" onchange="App.setWallAsW1(this.value)" title="Set selected wall as W1 - others renumber clockwise">
                            <option value="">Set as W1...</option>
                        </select>
                    </div>
                </div>
                <div class="section" id="wallSection" style="display: none;">
                    <div class="section-header"><span id="selectedWallLabel">W1</span></div>
                    <div class="section-content">
                        <div class="tool-grid" style="grid-template-columns: 1fr;">
                            <button class="tool-btn" onclick="App.setAsW1()" title="Set this wall as W1 (others renumber clockwise)">
                                <svg viewBox="0 0 24 24"><path d="M12 2L12 22M12 2L8 6M12 2L16 6" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><text x="12" y="18" text-anchor="middle" font-size="8" fill="currentColor" stroke="none">W1</text></svg>
                                <span>Set as W1</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="section">
                    <div class="section-header">Actions</div>
                    <div class="section-content">
                        <div class="tool-grid">
                            <button class="tool-btn" onclick="App.selectAll()" title="Select All (Ctrl+A)">
                                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" fill="none" stroke-width="2"></rect><path d="M9 12l2 2 4-4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>All</span>
                            </button>
                            <button class="tool-btn" onclick="App.rotateSelected()" title="Rotate selected">
                                <svg viewBox="0 0 24 24"><path d="M23 4v6h-6" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M20.49 15a9 9 0 11-2.12-9.36L23 10" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Rotate</span>
                            </button>
                            <button class="tool-btn" onclick="App.flipHorizontal()" title="Flip horizontal (mirror left/right)">
                                <svg viewBox="0 0 24 24"><path d="M12 3v18" stroke="currentColor" stroke-width="2" stroke-dasharray="2,2"></path><path d="M16 7l4 5-4 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M8 7l-4 5 4 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Flip H</span>
                            </button>
                            <button class="tool-btn" onclick="App.flipVertical()" title="Flip vertical (mirror up/down)">
                                <svg viewBox="0 0 24 24"><path d="M3 12h18" stroke="currentColor" stroke-width="2" stroke-dasharray="2,2"></path><path d="M7 8l5-4 5 4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M7 16l5 4 5-4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Flip V</span>
                            </button>
                            <button class="tool-btn" onclick="App.showQA()" title="QA Validation">
                                <svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" fill="none" stroke-width="2"></path></svg>
                                <span>QA</span>
                            </button>
                            <button class="tool-btn" onclick="App.copySelected()" title="Copy (Ctrl+C)">
                                <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" stroke="currentColor" fill="none" stroke-width="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1" stroke="currentColor" fill="none" stroke-width="2"></path></svg>
                                <span>Copy</span>
                            </button>
                            <button class="tool-btn" onclick="App.paste()" title="Paste (Ctrl+V)">
                                <svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2" stroke="currentColor" fill="none" stroke-width="2"></path><rect x="8" y="2" width="8" height="4" rx="1" stroke="currentColor" fill="none" stroke-width="2"></rect></svg>
                                <span>Paste</span>
                            </button>
                            <button class="tool-btn" id="btnUndo" onclick="App.undo()" title="Undo (Ctrl+Z)" style="opacity: 1;">
                                <svg viewBox="0 0 24 24"><path d="M3 10h10a5 5 0 015 5v2M3 10l5-5M3 10l5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Undo</span>
                            </button>
                            <button class="tool-btn" id="btnRedo" onclick="App.redo()" title="Redo (Ctrl+Y)" style="opacity: 0.4;" disabled="">
                                <svg viewBox="0 0 24 24"><path d="M21 10H11a5 5 0 00-5 5v2M21 10l-5-5M21 10l-5 5" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Redo</span>
                            </button>
                            <button class="tool-btn" id="deleteBtn" onclick="App.deleteSelected()" title="Delete selected" style="opacity: 0.4;" disabled="">
                                <svg viewBox="0 0 24 24"><path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14M10 11v6M14 11v6" stroke="currentColor" fill="none" stroke-width="2"></path></svg>
                                <span>Delete</span>
                            </button>
                            <button class="tool-btn" id="straightenBtn" onclick="App.straightenWall()" title="Straighten selected wall" style="opacity: 0.4;" disabled="">
                                <svg viewBox="0 0 24 24"><line x1="4" y1="12" x2="20" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"></line><path d="M8 8l-4 4 4 4M16 8l4 4-4 4" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>Straighten</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-wrap">
            <div id="stage"><div class="konvajs-content" role="presentation" style="position: relative; user-select: none; width: 587px; height: 833px;"><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas><canvas width="587" height="833" style="padding: 0px; margin: 0px; border: 0px; background: transparent; position: absolute; top: 0px; left: 0px; width: 587px; height: 833px; display: block;"></canvas></div></div>
            <div class="north-arrow" id="northArrow" onclick="App.rotateNorth()" title="Click to rotate north direction">
                <svg viewBox="0 0 24 24" id="compassArrow">
                    <polygon class="arrow-n" points="12,2 8,12 12,10 16,12"></polygon>
                    <polygon class="arrow-s" points="12,22 8,12 12,14 16,12"></polygon>
                    <text x="12" y="6" text-anchor="middle" font-size="4" font-weight="bold" fill="white">N</text>
                </svg>
            </div>
            <div class="scale-label">1/4" = 1'-0"</div>
            <div class="badge-container">
                <div class="qa-badge error" id="qaBadge">QA: 3 errors</div>
                <div class="floor-badge" id="floorBadge" onclick="App.toggleFloorDropdown(event)">
                    <span id="floorLabel">Location | Floor 1</span>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"></path></svg>
                    <div class="floor-dropdown" id="floorDropdown" onclick="event.stopPropagation()">
                        <div class="floor-dropdown-scroll" id="floorDropdownList">
                            <!-- Dynamic floor list rendered by App.renderFloorList() -->
                        </div>
                        <div class="floor-dropdown-nav" id="floorDropdownNav" style="display: none;">
                            <button onclick="App.floorListPrev()" id="floorPrevBtn" disabled="">← Previous</button>
                            <button onclick="App.floorListNext()" id="floorNextBtn">Next →</button>
                        </div>
                        <div class="floor-dropdown-add" onclick="App.addNewFloor()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M12 5v14M5 12h14"></path></svg>
                            Add Floor
                        </div>
                    </div>
                </div>
            </div>
            <div class="tool-hint" id="toolHint">Sample sheet 55555 confirmed</div>
        </div>
    </div>
</div>

<div class="modal" id="qaModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">QA Validation</div>
            <button class="modal-close" onclick="App.hideModal('qa')">×</button>
        </div>
        <div class="modal-body" id="qaContent"></div>
    </div>
</div>

<div class="modal" id="sampleSheetModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">Sample Sheet Label</div>
            <button class="modal-close" onclick="App.skipSampleSheet()">×</button>
        </div>
        <div class="modal-body">
            <p style="margin-bottom: 12px; color: #666;">Enter the 5-digit sample sheet label (first part of sample numbers).</p>
            <div style="margin-bottom: 12px;">
                <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px;">Sample Sheet Label:</label>
                <input type="tel" id="sampleSheetInput1" maxlength="5" inputmode="numeric" pattern="[0-9]*" placeholder="e.g., 12345" autocomplete="off" style="width: 100%; padding: 14px; font-size: 20px; border: 2px solid #ddd; border-radius: 6px; text-align: center; letter-spacing: 4px; -webkit-appearance: none;">
            </div>
            <div style="margin-bottom: 16px;">
                <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px;">Confirm Label:</label>
                <input type="tel" id="sampleSheetInput2" maxlength="5" inputmode="numeric" pattern="[0-9]*" placeholder="Enter again to confirm" autocomplete="off" style="width: 100%; padding: 14px; font-size: 20px; border: 2px solid #ddd; border-radius: 6px; text-align: center; letter-spacing: 4px; -webkit-appearance: none;">
            </div>
            <div id="sampleSheetError" style="color: #ef4444; font-size: 11px; margin-bottom: 12px; display: none;"></div>
            <button onclick="App.confirmSampleSheet()" style="width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 10px;">Confirm</button>
            <button onclick="App.skipSampleSheet()" style="width: 100%; padding: 10px; background: #f3f4f6; color: #666; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; cursor: pointer;">Skip for now</button>
        </div>
    </div>
</div>

<div class="modal" id="sampleNumberModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">Sample Number</div>
            <button class="modal-close" onclick="App.cancelSampleNumber()">×</button>
        </div>
        <div class="modal-body">
            <p style="margin-bottom: 8px; color: #666;">Enter the 3-digit sample number:</p>
            <p style="margin-bottom: 12px; font-size: 14px; font-weight: 600; color: #3b82f6;" id="sampleNumberPreview">12345-___</p>
            <div style="margin-bottom: 16px;">
                <input type="tel" id="sampleNumberInput" maxlength="3" inputmode="numeric" pattern="[0-9]*" placeholder="001" autocomplete="off" style="width: 100%; padding: 16px; font-size: 24px; border: 2px solid #3b82f6; border-radius: 6px; text-align: center; letter-spacing: 6px; -webkit-appearance: none;">
            </div>
            <div id="sampleNumberError" style="color: #ef4444; font-size: 11px; margin-bottom: 12px; display: none;"></div>
            <button onclick="App.confirmSampleNumber()" style="width: 100%; padding: 14px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">Place Sample</button>
        </div>
    </div>
</div>

<div class="modal" id="windowSampleModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">Window Sample Location</div>
            <button class="modal-close" onclick="App.hideModal('windowSample')">×</button>
        </div>
        <div class="modal-body">
            <p style="margin-bottom: 16px; color: #666;">Where is this dust wipe sample being taken?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="App.placeWindowSample('trough')" style="padding: 14px; background: #f0f7ff; border: 2px solid #3b82f6; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Window Trough</button>
                <button onclick="App.placeWindowSample('stool')" style="padding: 14px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Window Stool (Interior Sill)</button>
                <button onclick="App.placeWindowSample('well')" style="padding: 14px; background: #fefce8; border: 2px solid #eab308; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Window Well</button>
                <button onclick="App.hideModal('windowSample')" style="padding: 10px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 8px; font-size: 12px; cursor: pointer; color: #666;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="floorSampleModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">Floor/Surface Sample</div>
            <button class="modal-close" onclick="App.hideModal('floorSample')">×</button>
        </div>
        <div class="modal-body">
            <p style="margin-bottom: 16px; color: #666;">What type of surface is this sample from?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="App.placeFloorSample('floor')" style="padding: 14px; background: #f0f7ff; border: 2px solid #3b82f6; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Floor</button>
                <button onclick="App.placeFloorSample('entryway')" style="padding: 14px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Entryway Floor</button>
                <button onclick="App.placeFloorSample('other')" style="padding: 14px; background: #f3e8ff; border: 2px solid #a855f7; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Other Surface</button>
                <button onclick="App.hideModal('floorSample')" style="padding: 10px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 8px; font-size: 12px; cursor: pointer; color: #666;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="doorSampleModal">
    <div class="modal-box">
        <div class="modal-head">
            <div class="modal-title">Door Sample</div>
            <button class="modal-close" onclick="App.hideModal('doorSample')">×</button>
        </div>
        <div class="modal-body">
            <p style="margin-bottom: 16px; color: #666;">What type of door surface is this sample from?</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="App.placeDoorSample('door frame')" style="padding: 14px; background: #f0f7ff; border: 2px solid #3b82f6; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Door Frame</button>
                <button onclick="App.placeDoorSample('door threshold')" style="padding: 14px; background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Door Threshold</button>
                <button onclick="App.placeDoorSample('door')" style="padding: 14px; background: #f0fdf4; border: 2px solid #22c55e; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: 500;">Door Surface</button>
                <button onclick="App.hideModal('doorSample')" style="padding: 10px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 8px; font-size: 12px; cursor: pointer; color: #666;">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="doorTypeModal">
    <div class="modal-box" style="max-width: 360px;">
        <div class="modal-head">
            <div class="modal-title">Select Door Type</div>
            <button class="modal-close" onclick="App.hideModal('doorType')">×</button>
        </div>
        <div class="modal-body" style="padding: 12px;">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                <button class="door-type-btn" onclick="App.selectDoorType('regular')">
                    <svg viewBox="0 0 48 48"><rect x="12" y="4" width="24" height="40" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect><circle cx="30" cy="24" r="2" fill="currentColor"></circle><path d="M12 24 Q12 8, 36 24" fill="none" stroke="#999" stroke-width="1" stroke-dasharray="3,2"></path></svg>
                    <span>Regular</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('double')">
                    <svg viewBox="0 0 48 48"><path d="M4 8 Q4 40, 22 40" fill="none" stroke="#999" stroke-width="1" stroke-dasharray="3,2"></path><line x1="4" y1="8" x2="4" y2="40" stroke="currentColor" stroke-width="3" stroke-linecap="round"></line><path d="M44 8 Q44 40, 26 40" fill="none" stroke="#999" stroke-width="1" stroke-dasharray="3,2"></path><line x1="44" y1="8" x2="44" y2="40" stroke="currentColor" stroke-width="3" stroke-linecap="round"></line></svg>
                    <span>Double</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('sliding')">
                    <svg viewBox="0 0 48 48"><line x1="4" y1="24" x2="44" y2="24" stroke="#999" stroke-width="2" stroke-dasharray="4,3"></line><rect x="12" y="18" width="24" height="12" rx="2" fill="currentColor" stroke="currentColor" stroke-width="1"></rect></svg>
                    <span>Sliding</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('bifold')">
                    <svg viewBox="0 0 48 48"><line x1="4" y1="12" x2="24" y2="36" stroke="currentColor" stroke-width="3" stroke-linecap="round"></line><line x1="24" y1="36" x2="44" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"></line><circle cx="24" cy="36" r="3" fill="#999"></circle></svg>
                    <span>Bifold</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('bifold-double')">
                    <svg viewBox="0 0 48 48"><line x1="2" y1="12" x2="12" y2="32" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line><line x1="12" y1="32" x2="24" y2="12" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line><line x1="24" y1="12" x2="36" y2="32" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line><line x1="36" y1="32" x2="46" y2="12" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"></line><circle cx="12" cy="32" r="2.5" fill="#999"></circle><circle cx="36" cy="32" r="2.5" fill="#999"></circle></svg>
                    <span>Bifold 2x</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('pocket')">
                    <svg viewBox="0 0 48 48"><rect x="4" y="8" width="18" height="32" rx="1" fill="none" stroke="currentColor" stroke-width="2"></rect><rect x="22" y="4" width="22" height="40" fill="none" stroke="#ccc" stroke-width="2" stroke-dasharray="4,2"></rect><path d="M14 24 L8 24" stroke="#666" stroke-width="2"></path><path d="M10 20 L6 24 L10 28" stroke="#666" stroke-width="1.5" fill="none"></path></svg>
                    <span>Pocket</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('overhead')">
                    <svg viewBox="0 0 48 48"><rect x="6" y="28" width="36" height="12" rx="2" fill="currentColor" stroke="currentColor" stroke-width="1"></rect><line x1="4" y1="20" x2="44" y2="20" stroke="#999" stroke-width="2.5" stroke-dasharray="5,4"></line></svg>
                    <span>Overhead</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('elevator')">
                    <svg viewBox="0 0 48 48"><rect x="6" y="4" width="36" height="40" rx="2" fill="none" stroke="currentColor" stroke-width="2"></rect><line x1="24" y1="4" x2="24" y2="44" stroke="currentColor" stroke-width="2"></line><path d="M14 20 L18 14 L22 20" stroke="currentColor" stroke-width="2" fill="none"></path><path d="M26 28 L30 34 L34 28" stroke="currentColor" stroke-width="2" fill="none"></path></svg>
                    <span>Elevator</span>
                </button>
                <button class="door-type-btn" onclick="App.selectDoorType('revolving')">
                    <svg viewBox="0 0 48 48"><circle cx="24" cy="24" r="18" fill="none" stroke="currentColor" stroke-width="2"></circle><line x1="24" y1="6" x2="24" y2="42" stroke="currentColor" stroke-width="2"></line><line x1="6" y1="24" x2="42" y2="24" stroke="currentColor" stroke-width="2"></line><circle cx="24" cy="24" r="4" fill="currentColor"></circle></svg>
                    <span>Revolving</span>
                </button>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="saveFormatModal">
    <div class="modal-box" style="max-width: 320px;">
        <div class="modal-head">
            <div class="modal-title">Save Project As</div>
            <button class="modal-close" onclick="App.hideModal('saveFormat')">×</button>
        </div>
        <div class="modal-body" style="padding: 16px;">
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="door-type-btn" onclick="App.saveAs('fbg')" style="flex-direction: row; justify-content: flex-start; gap: 12px; min-height: 50px;">
                    <svg viewBox="0 0 24 24" style="width: 24px; height: 24px;"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"></path><text x="8" y="17" font-size="5" fill="currentColor" stroke="none">.fbg</text></svg>
                    <div style="text-align: left;"><strong>Floor Plan (.fbg)</strong><br><span style="font-size: 9px; color: #666;">Recommended - Full project file</span></div>
                </button>
                <button class="door-type-btn" onclick="App.saveAs('json')" style="flex-direction: row; justify-content: flex-start; gap: 12px; min-height: 50px;">
                    <svg viewBox="0 0 24 24" style="width: 24px; height: 24px;"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"></path><text x="6" y="17" font-size="5" fill="currentColor" stroke="none">.json</text></svg>
                    <div style="text-align: left;"><strong>JSON (.json)</strong><br><span style="font-size: 9px; color: #666;">Standard data format</span></div>
                </button>
                <button class="door-type-btn" onclick="App.saveAs('html')" style="flex-direction: row; justify-content: flex-start; gap: 12px; min-height: 50px;">
                    <svg viewBox="0 0 24 24" style="width: 24px; height: 24px;"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z" stroke="currentColor" fill="none" stroke-width="2"></path><text x="6" y="17" font-size="5" fill="currentColor" stroke="none">.html</text></svg>
                    <div style="text-align: left;"><strong>Standalone HTML (.html)</strong><br><span style="font-size: 9px; color: #666;">View in any browser (no app needed)</span></div>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const $$ = s => document.querySelectorAll(s);

// ========== CONSTANTS ==========
const SCALE = 4;
const INCH = SCALE;
const FOOT = 12 * SCALE;
const WALL_EXT = 6 * INCH;
const WALL_INT = 4.5 * INCH;
const SNAP_DISTANCE = 24; // Mobile-friendly snap distance in pixels
const HIT_WIDTH = 28; // Hit region width for wall segments
const GRID_SNAP = FOOT; // Snap to 1-foot grid

// Dimension line colors
const DIM_COLOR_EXTERIOR = '#2563eb';  // Blue for exterior room dimensions
const DIM_COLOR_INTERIOR = '#f97316';  // Orange for interior room dimensions

// ========== SNAPPING FUNCTIONS ==========
function snapToGrid(value) {
    return Math.round(value / GRID_SNAP) * GRID_SNAP;
}

function findRoomSnapPoints(doc, excludeRoomId) {
    // Get all room edges for snapping (excluding current room)
    const snapPoints = { x: [], y: [] };
    doc.rooms.forEach(room => {
        if (room.id === excludeRoomId) return;
        const g = room.geometry;
        snapPoints.x.push(g.x, g.x + g.width);
        snapPoints.y.push(g.y, g.y + g.height);
    });
    return snapPoints;
}

function snapRoomPosition(x, y, width, height, snapPoints) {
    let snappedX = x;
    let snappedY = y;
    let bestDistX = SNAP_DISTANCE;
    let bestDistY = SNAP_DISTANCE;

    // Find closest X snap point (check both left and right edges)
    for (const sx of snapPoints.x) {
        // Left edge snap
        const leftDist = Math.abs(x - sx);
        if (leftDist < bestDistX) {
            bestDistX = leftDist;
            snappedX = sx;
        }
        // Right edge snap
        const rightDist = Math.abs(x + width - sx);
        if (rightDist < bestDistX) {
            bestDistX = rightDist;
            snappedX = sx - width;
        }
    }

    // Find closest Y snap point (check both top and bottom edges)
    for (const sy of snapPoints.y) {
        // Top edge snap
        const topDist = Math.abs(y - sy);
        if (topDist < bestDistY) {
            bestDistY = topDist;
            snappedY = sy;
        }
        // Bottom edge snap
        const bottomDist = Math.abs(y + height - sy);
        if (bottomDist < bestDistY) {
            bestDistY = bottomDist;
            snappedY = sy - height;
        }
    }

    // Snap to grid if no room edge snap found
    if (snappedX === x) snappedX = snapToGrid(x);
    if (snappedY === y) snappedY = snapToGrid(y);

    return { x: snappedX, y: snappedY };
}

// ========== DOCUMENT MODEL ==========
const Doc = {
    create() {
        return {
            id: this.uid(),
            version: '4.0',
            address: '2BR/1BA Blueprint',
            sampleSheetNumber: null,  // 8-digit sample sheet for dust wipes
            counters: { room: 0, wallSegment: 0, door: 0, window: 0, closet: 0, cased: 0, pipe: 0, gas: 0, riser: 0, radiator: 0, poe: 0, dustwipe: 0 },
            rooms: [],
            wallSegments: [],  // All wall segments indexed here
            doors: [],
            windows: [],
            casedOpenings: [],
            closets: [],
            mep: [],
            dustWipes: [],  // Dust wipe sample markers
            dimensions: []
        };
    },
    uid() { return 'id_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36); },
    label(doc, type) {
        doc.counters[type] = (doc.counters[type] || 0) + 1;
        const prefixes = { room: 'Rm', wallSegment: 'WS', door: 'D', window: 'WIN', closet: 'CL', cased: 'OP', pipe: 'PIPE', gas: 'GAS', riser: 'PRSR', radiator: 'RAD', poe: 'POE' };
        const n = doc.counters[type];
        return (prefixes[type] || type.toUpperCase()) + '-' + (n < 10 ? '0' : '') + n;
    },
    // Get next dust wipe sample number (returns just the 2-digit suffix)
    nextDustWipeNumber(doc) {
        doc.counters.dustwipe = (doc.counters.dustwipe || 0) + 1;
        const n = doc.counters.dustwipe;
        return n < 10 ? '0' + n : '' + n;
    },
    // Get full dust wipe label (sheet number + sample number)
    dustWipeLabel(doc) {
        const suffix = this.nextDustWipeNumber(doc);
        if (doc.sampleSheetNumber) {
            return doc.sampleSheetNumber + '-' + suffix;
        }
        return 'X-' + suffix;
    }
};

// ========== WALL SEGMENT CREATION ==========
function createWallSegments(room, doc) {
    const g = room.geometry;

    // Ensure room has vertices array (convert from geometry if needed)
    if (!room.vertices) {
        room.vertices = verticesFromGeometry(g);
    }

    // Use getWallEdgesFromVertices for vertex-based wall derivation
    const edges = getWallEdgesFromVertices(room);

    // Create WallSegment objects from edges
    const wallSegments = edges.map((edge, idx) => {
        const ws = {
            id: Doc.uid(),
            roomId: room.id,
            roomLabel: room.label,
            index: idx + 1,
            label: edge.label,
            side: edge.side,
            x1: edge.start.x, y1: edge.start.y,
            x2: edge.end.x, y2: edge.end.y,
            thickness: room.isExterior ? WALL_EXT : WALL_INT,
            type: 'interior',  // Default to interior, will be set properly by markExteriorWalls()
            attachedObjects: []
        };
        doc.wallSegments.push(ws);
        return ws;
    });

    room.wallSegmentIds = wallSegments.map(ws => ws.id);
    return wallSegments;
}

// Regenerate wall segments for a room (after vertex editing)
function regenerateWallSegments(room, doc) {
    // Collect all attached objects with their WORLD POSITIONS before destroying walls
    const attachmentsWithPositions = [];

    // Find all objects attached to this room's walls
    const allCollections = [
        { arr: doc.doors, type: 'door' },
        { arr: doc.windows, type: 'window' },
        { arr: doc.casedOpenings, type: 'cased' },
        { arr: doc.mep, type: 'mep' }
    ];

    allCollections.forEach(({ arr, type }) => {
        if (!arr) return;
        arr.forEach(obj => {
            // Check if this object is attached to this room
            if (obj.parentRoomId === room.id && obj.parentWallSegmentId) {
                const ws = doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
                if (ws) {
                    // Calculate world position
                    const segLen = getSegmentLength(ws);
                    const distFromStart = obj.distanceFromStart || 0;
                    const t = segLen > 0 ? Math.min(1, Math.max(0, distFromStart / segLen)) : 0.5;
                    const worldX = ws.x1 + (ws.x2 - ws.x1) * t;
                    const worldY = ws.y1 + (ws.y2 - ws.y1) * t;
                    attachmentsWithPositions.push({
                        id: obj.id,
                        type: type,
                        label: obj.label,
                        worldX,
                        worldY
                    });
                }
            }
        });
    });

    // Remove old wall segments for this room
    doc.wallSegments = doc.wallSegments.filter(ws => ws.roomId !== room.id);

    // Update geometry from vertices
    const g = getGeometryFromVertices(room.vertices);
    if (g) room.geometry = g;

    // Create new wall segments from vertices
    const edges = getWallEdgesFromVertices(room);
    const wallSegments = edges.map((edge, idx) => {
        const ws = {
            id: Doc.uid(),
            roomId: room.id,
            roomLabel: room.label,
            index: idx + 1,
            label: edge.label,
            side: edge.side,
            x1: edge.start.x, y1: edge.start.y,
            x2: edge.end.x, y2: edge.end.y,
            thickness: room.isExterior ? WALL_EXT : WALL_INT,
            type: 'interior',
            attachedObjects: []
        };
        doc.wallSegments.push(ws);
        return ws;
    });

    room.wallSegmentIds = wallSegments.map(ws => ws.id);

    // Reassign each attachment to the nearest new wall segment
    attachmentsWithPositions.forEach(att => {
        let bestWs = null;
        let bestDist = Infinity;
        let bestT = 0;

        wallSegments.forEach(ws => {
            const result = pointToSegmentDistance(att.worldX, att.worldY, ws);
            if (result.distance < bestDist) {
                bestDist = result.distance;
                bestWs = ws;
                bestT = result.t;
            }
        });

        if (bestWs) {
            const segLen = getSegmentLength(bestWs);
            const newDistanceFromStart = bestT * segLen;

            // Add to wall segment's attached objects
            bestWs.attachedObjects.push({ id: att.id, type: att.type, label: att.label });

            // Update the actual object
            allCollections.forEach(({ arr }) => {
                if (!arr) return;
                const obj = arr.find(o => o.id === att.id);
                if (obj) {
                    obj.parentWallSegmentId = bestWs.id;
                    obj.distanceFromStart = newDistanceFromStart;
                }
            });
        }
    });

    return wallSegments;
}

function getSegmentLength(seg) {
    return Math.sqrt(Math.pow(seg.x2 - seg.x1, 2) + Math.pow(seg.y2 - seg.y1, 2));
}

function getSegmentMidpoint(seg) {
    return { x: (seg.x1 + seg.x2) / 2, y: (seg.y1 + seg.y2) / 2 };
}

function getSegmentAngle(seg) {
    return Math.atan2(seg.y2 - seg.y1, seg.x2 - seg.x1);
}

function pointToSegmentDistance(px, py, seg) {
    const dx = seg.x2 - seg.x1;
    const dy = seg.y2 - seg.y1;
    const len2 = dx * dx + dy * dy;
    if (len2 === 0) return Math.sqrt((px - seg.x1) ** 2 + (py - seg.y1) ** 2);
    let t = ((px - seg.x1) * dx + (py - seg.y1) * dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const nearX = seg.x1 + t * dx;
    const nearY = seg.y1 + t * dy;
    return { distance: Math.sqrt((px - nearX) ** 2 + (py - nearY) ** 2), t, nearX, nearY };
}

// ========== POLYGON GEOMETRY HELPERS ==========
// Get bounding box geometry from vertices (for backward compatibility)
function getGeometryFromVertices(vertices) {
    if (!vertices || vertices.length < 3) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    vertices.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x);
        maxY = Math.max(maxY, v.y);
    });
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

// Create vertices from rectangle geometry
function verticesFromGeometry(g) {
    if (!g) return null;
    return [
        { x: g.x, y: g.y },
        { x: g.x + g.width, y: g.y },
        { x: g.x + g.width, y: g.y + g.height },
        { x: g.x, y: g.y + g.height }
    ];
}

// Get wall edges from room vertices (replaces wallSegments for rendering)
// Labels based on direction: W1=south, W2=west, W3=north, W4=east
function getWallEdgesFromVertices(room) {
    const verts = room.vertices;
    if (!verts || verts.length < 3) return [];
    const n = verts.length;
    const edges = [];

    // Direction to label mapping
    const directionLabels = {
        'south': 'W1',
        'west': 'W2',
        'north': 'W3',
        'east': 'W4'
    };

    // Build edges in vertex order
    for (let i = 0; i < n; i++) {
        const nextIdx = (i + 1) % n;
        const start = verts[i];
        const end = verts[nextIdx];

        // Determine side based on edge orientation (which way the wall faces outward)
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        let side = 'south';
        if (Math.abs(dx) > Math.abs(dy)) {
            // Horizontal wall - faces perpendicular to travel direction
            side = dx > 0 ? 'north' : 'south';  // going right = faces north, going left = faces south
        } else {
            // Vertical wall - faces perpendicular to travel direction
            side = dy > 0 ? 'east' : 'west';    // going down = faces east, going up = faces west
        }

        // Label based on direction, not sequence
        const label = directionLabels[side] || 'W1';

        edges.push({
            edgeIndex: i,
            label: label,
            roomId: room.id,
            roomLabel: room.label,
            start: { ...start },
            end: { ...end },
            side: side,
            isExterior: room.isExterior
        });
    }
    return edges;
}

// Get position on edge from normalized t value (0-1)
function getPositionOnEdge(edge, t) {
    return {
        x: edge.start.x + t * (edge.end.x - edge.start.x),
        y: edge.start.y + t * (edge.end.y - edge.start.y)
    };
}

// Get edge length
function getEdgeLength(edge) {
    return Math.sqrt(
        Math.pow(edge.end.x - edge.start.x, 2) +
        Math.pow(edge.end.y - edge.start.y, 2)
    );
}

// Convert world position to t value on edge
function getTOnEdge(edge, worldX, worldY) {
    const len = getEdgeLength(edge);
    if (len === 0) return 0;
    const dx = edge.end.x - edge.start.x;
    const dy = edge.end.y - edge.start.y;
    return Math.max(0, Math.min(1,
        ((worldX - edge.start.x) * dx + (worldY - edge.start.y) * dy) / (len * len)
    ));
}

// Check if two line segments intersect (for self-intersection detection)
function segmentsIntersect(a1, a2, b1, b2) {
    const d = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (Math.abs(d) < 0.0001) return false;
    const ua = ((b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x)) / d;
    const ub = ((a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x)) / d;
    return ua > 0.001 && ua < 0.999 && ub > 0.001 && ub < 0.999;
}

// Check if polygon self-intersects
function polygonSelfIntersects(vertices) {
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 2; j < n; j++) {
            if (i === 0 && j === n - 1) continue; // Adjacent edges at wrap
            if (segmentsIntersect(
                vertices[i], vertices[(i + 1) % n],
                vertices[j], vertices[(j + 1) % n]
            )) return true;
        }
    }
    return false;
}

// Get polygon centroid
function getPolygonCentroid(vertices) {
    if (!vertices || vertices.length === 0) return { x: 0, y: 0 };
    let sumX = 0, sumY = 0;
    vertices.forEach(v => { sumX += v.x; sumY += v.y; });
    return { x: sumX / vertices.length, y: sumY / vertices.length };
}

// Get flattened points array for Konva.Line
function getVerticesAsPoints(vertices) {
    const points = [];
    vertices.forEach(v => { points.push(v.x, v.y); });
    return points;
}

// Create H-shaped room vertices
// H shape: two vertical bars connected by horizontal crossbar
//
//   1--2       5--6
//   |  |       |  |
//   |  3-------4  |
//   |             |
//   |  10------9  |
//   |  |       |  |
//   12-11      8--7
//
function createHShapeVertices(x, y, width, height, legWidth, crossbarHeight) {
    // legWidth = width of vertical legs (default 1/4 of total width)
    // crossbarHeight = height of crossbar (default 1/3 of total height)
    const lw = legWidth || width * 0.25;
    const cbh = crossbarHeight || height * 0.33;
    const cbTop = y + (height - cbh) / 2;
    const cbBottom = cbTop + cbh;

    return [
        { x: x, y: y },                          // 1 - top-left
        { x: x + lw, y: y },                     // 2
        { x: x + lw, y: cbTop },                 // 3 - left leg inner top
        { x: x + width - lw, y: cbTop },         // 4 - right leg inner top
        { x: x + width - lw, y: y },             // 5
        { x: x + width, y: y },                  // 6 - top-right
        { x: x + width, y: y + height },         // 7 - bottom-right
        { x: x + width - lw, y: y + height },    // 8
        { x: x + width - lw, y: cbBottom },      // 9 - right leg inner bottom
        { x: x + lw, y: cbBottom },              // 10 - left leg inner bottom
        { x: x + lw, y: y + height },            // 11
        { x: x, y: y + height }                  // 12 - bottom-left
    ];
}

function findNearestWallSegment(x, y, doc) {
    let nearest = null;
    let minDist = Infinity;
    let nearestT = 0;
    let nearestPoint = null;

    doc.wallSegments.forEach(seg => {
        const result = pointToSegmentDistance(x, y, seg);
        if (result.distance < minDist) {
            minDist = result.distance;
            nearest = seg;
            nearestT = result.t;
            nearestPoint = { x: result.nearX, y: result.nearY };
        }
    });

    return { segment: nearest, distance: minDist, t: nearestT, point: nearestPoint };
}

// ========== MARK EXTERIOR WALLS ==========
// Determines which walls are on the building perimeter (exterior) vs shared with other rooms (interior)
function markExteriorWalls(doc) {
    if (doc.rooms.length === 0) return;

    // Find building bounding box from all rooms
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    doc.rooms.forEach(room => {
        const g = room.geometry;
        minX = Math.min(minX, g.x);
        minY = Math.min(minY, g.y);
        maxX = Math.max(maxX, g.x + g.width);
        maxY = Math.max(maxY, g.y + g.height);
    });

    // Tolerance for edge detection (walls on perimeter)
    const tolerance = 2;

    // Mark each wall segment as exterior if it's on the building perimeter
    doc.wallSegments.forEach(ws => {
        const midX = (ws.x1 + ws.x2) / 2;
        const midY = (ws.y1 + ws.y2) / 2;
        const isVertical = Math.abs(ws.x1 - ws.x2) < tolerance;
        const isHorizontal = Math.abs(ws.y1 - ws.y2) < tolerance;

        let isExterior = false;

        if (isHorizontal) {
            // Check if on top or bottom edge
            if (Math.abs(midY - minY) < tolerance || Math.abs(midY - maxY) < tolerance) {
                isExterior = true;
            }
        }
        if (isVertical) {
            // Check if on left or right edge
            if (Math.abs(midX - minX) < tolerance || Math.abs(midX - maxX) < tolerance) {
                isExterior = true;
            }
        }

        ws.type = isExterior ? 'exterior' : 'interior';
        ws.thickness = isExterior ? WALL_EXT : WALL_INT;
    });
}

// ========== GENERATE 2BR/1BA ==========
function generate2BR1BA() {
    const doc = Doc.create();

    // Layout: Clean 2x3 grid with shared walls, no gaps
    // Total exterior: 26' x 20' (compact ranch-style)
    //
    //      0      12     16      26
    //      +------+------+-------+  0
    //      | Bed1 | Hall |Kitchen|
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 10
    //      |Living| Bath | Bed 2 |
    //      | 12x10| 4x10 | 10x10 |
    //      +------+------+-------+ 20
    //
    const startX = 60, startY = 60;

    // Grid columns (x positions)
    const col1 = startX;                    // Left edge
    const col2 = startX + 12 * FOOT;        // 12'
    const col3 = col2 + 4 * FOOT;           // 16'
    const col4 = col3 + 10 * FOOT;          // 26' (right edge)

    // Grid rows (y positions)
    const row1 = startY;                    // Top edge
    const row2 = startY + 10 * FOOT;        // 10'
    const row3 = row2 + 10 * FOOT;          // 20' (bottom edge)

    // ========== ROW 1: Bed1 | Hall | Kitchen ==========
    // Bedroom 1: Top-left (12' x 10')
    const bed1 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 1', isExterior: true,
        geometry: { x: col1, y: row1, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed1, doc);
    doc.rooms.push(bed1);

    // Hallway 1: Top-center (4' x 10')
    const hall = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Hallway 1', isExterior: false,
        geometry: { x: col2, y: row1, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(hall, doc);
    doc.rooms.push(hall);

    // Kitchen: Top-right (10' x 10')
    const kitchen = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Kitchen', isExterior: true,
        geometry: { x: col3, y: row1, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(kitchen, doc);
    doc.rooms.push(kitchen);

    // ========== ROW 2: Living | Bath | Bed2 ==========
    // Living Room: Bottom-left (12' x 10')
    const living = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Living Room', isExterior: true,
        geometry: { x: col1, y: row2, width: 12 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(living, doc);
    doc.rooms.push(living);

    // Bathroom: Bottom-center (4' x 10')
    const bath = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bathroom', isExterior: false,
        geometry: { x: col2, y: row2, width: 4 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bath, doc);
    doc.rooms.push(bath);

    // Bedroom 2: Bottom-right (10' x 10')
    const bed2 = {
        id: Doc.uid(), label: Doc.label(doc, 'room'), type: 'Bedroom 2', isExterior: true,
        geometry: { x: col3, y: row2, width: 10 * FOOT, height: 10 * FOOT }
    };
    createWallSegments(bed2, doc);
    doc.rooms.push(bed2);

    // ========== H-SHAPED ROOM (Demo) ==========
    // Add an H-shaped room to demonstrate polygon rooms
    const hRoomX = col4 + 3 * FOOT;  // 3' gap from main building
    const hRoomY = row1;
    const hWidth = 10 * FOOT;
    const hHeight = 16 * FOOT;
    const hVerts = createHShapeVertices(hRoomX, hRoomY, hWidth, hHeight, 3 * FOOT, 4 * FOOT);
    const hRoom = {
        id: Doc.uid(),
        label: Doc.label(doc, 'room'),
        type: 'Office',
        isExterior: true,
        vertices: hVerts,
        geometry: getGeometryFromVertices(hVerts)
    };
    createWallSegments(hRoom, doc);
    doc.rooms.push(hRoom);

    // Mark which walls are actually on the building exterior vs interior (shared)
    markExteriorWalls(doc);

    // ========== DOORS ==========
    // New layout wall reference:
    // W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south)
    //
    // Circulation path: Entry(Living W1) → Living → Bath(W4/W2) → Hall(W3/W1) → Bed1(W2/W4) + Kitchen(W4/W2)
    //                   Bath → Bed2 (W4/W2)

    // D-01: Entry door on Living south wall (W1) - exterior entry
    const livingSouthWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W1');
    if (livingSouthWall) {
        const d1 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d1);
        livingSouthWall.attachedObjects.push({ type: 'door', id: d1.id, label: d1.label });

        // POE anchored to entry door
        const poe1 = {
            id: Doc.uid(), label: Doc.label(doc, 'poe'), type: 'entry',
            parentWallSegmentId: livingSouthWall.id,
            parentRoomId: living.id,
            anchorDoorId: d1.id,
            distanceFromStart: 4.5 * FOOT
        };
        doc.mep.push(poe1);
        livingSouthWall.attachedObjects.push({ type: 'poe', id: poe1.id, label: poe1.label });
    }

    // D-02: Bed 1 to Hall - on Bed1's east wall (W4)
    const bed1EastWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W4');
    if (bed1EastWall) {
        const d2 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed1EastWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d2);
        bed1EastWall.attachedObjects.push({ type: 'door', id: d2.id, label: d2.label });
    }

    // D-03: Bath to Hall - on Bath's north wall (W3)
    const bathNorthWall = doc.wallSegments.find(ws => ws.roomId === bath.id && ws.label === 'W3');
    if (bathNorthWall) {
        const d3 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bathNorthWall.id,
            parentRoomId: bath.id,
            distanceFromStart: 0.5 * FOOT,
            width: 2.5 * FOOT,
            swing: 'in', swingDir: 'right'
        };
        doc.doors.push(d3);
        bathNorthWall.attachedObjects.push({ type: 'door', id: d3.id, label: d3.label });
    }

    // D-04: Bed 2 to Bath - on Bed2's west wall (W2)
    const bed2WestWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W2');
    if (bed2WestWall) {
        const d4 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: bed2WestWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d4);
        bed2WestWall.attachedObjects.push({ type: 'door', id: d4.id, label: d4.label });
    }

    // D-05: Kitchen to Hall - on Kitchen's west wall (W2)
    const kitchenWestWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W2');
    if (kitchenWestWall) {
        const d5 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: kitchenWestWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'in', swingDir: 'left'
        };
        doc.doors.push(d5);
        kitchenWestWall.attachedObjects.push({ type: 'door', id: d5.id, label: d5.label });
    }

    // D-06: Living to Bath - on Living's east wall (W4)
    const livingEastWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W4');
    if (livingEastWall) {
        const d6 = {
            id: Doc.uid(), label: Doc.label(doc, 'door'), type: 'interior',
            parentWallSegmentId: livingEastWall.id,
            parentRoomId: living.id,
            distanceFromStart: 4 * FOOT,
            width: 2.67 * FOOT,
            swing: 'out', swingDir: 'right'
        };
        doc.doors.push(d6);
        livingEastWall.attachedObjects.push({ type: 'door', id: d6.id, label: d6.label });
    }

    // ========== WINDOWS ==========
    // WIN-01: Living west wall
    const livingWestWall = doc.wallSegments.find(ws => ws.roomId === living.id && ws.label === 'W2');
    if (livingWestWall) {
        const w1 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 2 * FOOT,
            width: 5 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w1);
        livingWestWall.attachedObjects.push({ type: 'window', id: w1.id, label: w1.label });
    }

    // WIN-02: Bed 1 north wall
    const bed1NorthWall = doc.wallSegments.find(ws => ws.roomId === bed1.id && ws.label === 'W3');
    if (bed1NorthWall) {
        const w2 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed1NorthWall.id,
            parentRoomId: bed1.id,
            distanceFromStart: 3 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w2);
        bed1NorthWall.attachedObjects.push({ type: 'window', id: w2.id, label: w2.label });
    }

    // WIN-03: Bed 2 south wall
    const bed2SouthWall = doc.wallSegments.find(ws => ws.roomId === bed2.id && ws.label === 'W1');
    if (bed2SouthWall) {
        const w3 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: bed2SouthWall.id,
            parentRoomId: bed2.id,
            distanceFromStart: 4 * FOOT,
            width: 4 * FOOT,
            sillHeight: 36 * INCH
        };
        doc.windows.push(w3);
        bed2SouthWall.attachedObjects.push({ type: 'window', id: w3.id, label: w3.label });
    }

    // WIN-04: Kitchen east wall
    const kitchenEastWall = doc.wallSegments.find(ws => ws.roomId === kitchen.id && ws.label === 'W4');
    if (kitchenEastWall) {
        const w4 = {
            id: Doc.uid(), label: Doc.label(doc, 'window'),
            parentWallSegmentId: kitchenEastWall.id,
            parentRoomId: kitchen.id,
            distanceFromStart: 3 * FOOT,
            width: 3 * FOOT,
            sillHeight: 42 * INCH
        };
        doc.windows.push(w4);
        kitchenEastWall.attachedObjects.push({ type: 'window', id: w4.id, label: w4.label });
    }

    // ========== MEP ==========
    // Radiator in Living
    if (livingWestWall) {
        const rad1 = {
            id: Doc.uid(), label: Doc.label(doc, 'radiator'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 8 * FOOT,
            width: 3 * FOOT, height: 1 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rad1);
        livingWestWall.attachedObjects.push({ type: 'radiator', id: rad1.id, label: rad1.label });

        // Riser near radiator
        const rsr1 = {
            id: Doc.uid(), label: Doc.label(doc, 'riser'),
            parentWallSegmentId: livingWestWall.id,
            parentRoomId: living.id,
            distanceFromStart: 7.5 * FOOT,
            width: 0.5 * FOOT, height: 0.5 * FOOT,
            side: 'interior'
        };
        doc.mep.push(rsr1);
        livingWestWall.attachedObjects.push({ type: 'riser', id: rsr1.id, label: rsr1.label });
    }

    // ========== DIMENSIONS ==========
    const totalW = col4 - col1;  // 26'
    const totalH = row3 - row1;  // 20'
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalW / FOOT)}'-0"`, x1: startX, y1: startY - 25, x2: startX + totalW, y2: startY - 25 });
    doc.dimensions.push({ type: 'linear', label: `${Math.round(totalH / FOOT)}'-0"`, x1: startX - 25, y1: startY, x2: startX - 25, y2: startY + totalH, vertical: true });

    return doc;
}

// ========== RENDERER ==========
const Render = {
    stage: null,
    layers: {},
    wallGroups: {},
    selection: { type: null, id: null },
    multiSelection: [],  // Array of {type, id} for multi-select

    init(containerId) {
        const c = document.getElementById(containerId);
        if (!c) return false;
        const r = c.getBoundingClientRect();
        this.stage = new Konva.Stage({ container: containerId, width: r.width, height: r.height, draggable: true });

        this.layers.grid = new Konva.Layer({ listening: false }); // Grid layer (bottom)
        this.layers.rooms = new Konva.Layer();
        this.layers.walls = new Konva.Layer();
        this.layers.openings = new Konva.Layer();
        this.layers.mep = new Konva.Layer();
        this.layers.labels = new Konva.Layer();
        this.layers.dims = new Konva.Layer();
        this.layers.hit = new Konva.Layer(); // Hit regions layer

        this.stage.add(this.layers.grid, this.layers.rooms, this.layers.walls, this.layers.hit, this.layers.openings, this.layers.mep, this.layers.labels, this.layers.dims);

        this.stage.on('wheel', e => {
            e.evt.preventDefault();
            const oldScale = this.stage.scaleX();
            const pointer = this.stage.getPointerPosition();
            const mousePointTo = { x: (pointer.x - this.stage.x()) / oldScale, y: (pointer.y - this.stage.y()) / oldScale };

            // Gentler zoom factor (1.03 instead of 1.1) with min/max limits
            const zoomFactor = 1.03;
            const minScale = 0.15;  // Allow more zoom out for overview
            const maxScale = 3;
            let newScale = e.evt.deltaY > 0 ? oldScale / zoomFactor : oldScale * zoomFactor;
            newScale = Math.max(minScale, Math.min(maxScale, newScale));

            this.stage.scale({ x: newScale, y: newScale });
            this.stage.position({ x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale });
        });

        // Click on empty canvas to deselect
        this.stage.on('click tap', e => {
            // Only deselect if clicking on stage or layer (not on any shape)
            // Also check we're in select mode
            if ((e.target === this.stage || e.target instanceof Konva.Layer) && App.currentTool === 'select') {
                this.deselect();
                App.render();
            }
        });

        // Cased opening drag-to-draw handlers
        this.stage.on('mousemove touchmove', e => {
            if (App.isDrawingCased && App.casedDrawWall) {
                const pointer = this.stage.getPointerPosition();
                const transform = this.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const ws = App.casedDrawWall;
                const currentOffset = this.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const segLen = getSegmentLength(ws);

                // Calculate width (can drag left or right)
                let start = App.casedDrawStart;
                let width = currentOffset - start;
                if (width < 0) {
                    start = currentOffset;
                    width = -width;
                }
                // Clamp to wall bounds
                start = Math.max(0, start);
                width = Math.min(width, segLen - start);

                App.casedPreview = { ws: ws, start: start, width: width };
                App.renderCasedPreview();
            }
        });

        this.stage.on('mouseup touchend', e => {
            if (App.isDrawingCased && App.casedDrawWall && App.casedPreview) {
                const preview = App.casedPreview;
                // Only create if width is meaningful (> 6 inches)
                if (preview.width > 0.5 * FOOT) {
                    const obj = {
                        id: Doc.uid(),
                        label: Doc.label(App.doc, 'cased'),
                        parentWallSegmentId: preview.ws.id,
                        parentRoomId: preview.ws.roomId,
                        distanceFromStart: preview.start,
                        width: preview.width
                    };
                    App.doc.casedOpenings.push(obj);
                    App.saveState();
                }
                // Reset state
                App.isDrawingCased = false;
                App.casedDrawWall = null;
                App.casedDrawStart = 0;
                App.casedPreview = null;
                this.stage.draggable(true);
                App.render();
                App.updateTree();
                App.setTool('select');
            }
        });

        new ResizeObserver(() => {
            const rect = c.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                this.stage.width(rect.width);
                this.stage.height(rect.height);
            }
        }).observe(c);

        // Auto-fit on mobile
        if (window.innerWidth <= 768) {
            setTimeout(() => this.fitToContent(), 100);
        }

        return true;
    },

    // Fit the canvas to show all content with padding
    fitToContent(doc) {
        if (!doc) doc = App.doc;
        if (!doc || !doc.rooms || doc.rooms.length === 0) return;

        // Find bounding box of all rooms and closets
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        doc.rooms.forEach(room => {
            const g = room.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        doc.closets.forEach(closet => {
            const g = closet.geometry;
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        if (minX === Infinity) return;

        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const padding = 60;

        const stageWidth = this.stage.width();
        const stageHeight = this.stage.height();

        // Calculate scale to fit content with padding
        const scaleX = (stageWidth - padding * 2) / contentWidth;
        const scaleY = (stageHeight - padding * 2) / contentHeight;
        const newScale = Math.min(scaleX, scaleY, 0.7); // Cap at 0.7x for better overview

        // Center the content
        const centerX = minX + contentWidth / 2;
        const centerY = minY + contentHeight / 2;
        const newX = stageWidth / 2 - centerX * newScale;
        const newY = stageHeight / 2 - centerY * newScale;

        this.stage.scale({ x: newScale, y: newScale });
        this.stage.position({ x: newX, y: newY });
        this.stage.batchDraw();
    },

    // Live update walls during drag
    updateWallsLive(doc) {
        this.layers.walls.destroyChildren();
        this.layers.hit.destroyChildren();

        doc.wallSegments.forEach(ws => {
            let room = doc.rooms.find(r => r.id === ws.roomId);
            if (!room) room = doc.closets.find(c => c.id === ws.roomId);
            const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
            const isExterior = ws.type === 'exterior';

            const wallColor = isSelected ? '#3b82f6' : '#2d3748';
            const wallWidth = isSelected ? 3 : (isExterior ? 2 : 1);

            // Main wall line
            this.layers.walls.add(new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: wallColor,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            }));

            // Hit region
            const hitLine = new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: 'transparent',
                strokeWidth: HIT_WIDTH,
                lineCap: 'round',
                hitStrokeWidth: HIT_WIDTH
            });
            hitLine.on('tap click', (e) => {
                const pos = this.stage.getPointerPosition();
                const transform = this.stage.getAbsoluteTransform().copy().invert();
                const worldPos = pos ? transform.point(pos) : null;
                App.onWallTap(ws.id, worldPos);
            });
            hitLine.on('pointerdown', (e) => {
                const pos = this.stage.getPointerPosition();
                const transform = this.stage.getAbsoluteTransform().copy().invert();
                const worldPos = pos ? transform.point(pos) : null;
                App.onWallTap(ws.id, worldPos);
            });
            this.layers.hit.add(hitLine);
        });

        this.layers.walls.batchDraw();
        this.layers.hit.batchDraw();
    },

    // Live update dimensions during drag (lightweight, doesn't recreate room groups)
    updateDimensionsLive(doc) {
        // Clear only dims and labels layers
        this.layers.dims.destroyChildren();
        this.layers.labels.destroyChildren();

        // Re-render room labels (dimensions now handled by renderInteriorDimensions)
        doc.rooms.forEach(room => {
            // Ensure geometry exists
            let g = room.geometry;
            if (!g && room.vertices) {
                g = getGeometryFromVertices(room.vertices);
                room.geometry = g;
            }
            if (!g) return;
            const isSelected = this.selection.type === 'room' && this.selection.id === room.id;

            // Room label (inside) - show type as main label, ID underneath
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
                text: room.type, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
            }));
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 4, width: g.width,
                text: room.label, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
            }));
            // Note: Interior dimension LINES are rendered by renderInteriorDimensions()
            // Note: Exterior dimensions are handled by renderChainDimensions()
        });

        // Re-render closet labels
        doc.closets.forEach(closet => {
            // Ensure geometry exists
            let g = closet.geometry;
            if (!g && closet.vertices) {
                g = getGeometryFromVertices(closet.vertices);
                closet.geometry = g;
            }
            if (!g) return;
            const isSelected = this.selection.type === 'closet' && this.selection.id === closet.id;
            const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);

            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
                text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#6b7280', align: 'center', listening: false
            }));
            if (parentRoom) {
                this.layers.labels.add(new Konva.Text({
                    x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                    text: `(${parentRoom.label})`, fontSize: 8, fill: '#9ca3af', align: 'center', listening: false
                }));
            }
        });

        // Re-render wall labels
        doc.wallSegments.forEach(ws => {
            let room = doc.rooms.find(r => r.id === ws.roomId);
            if (!room) room = doc.closets.find(c => c.id === ws.roomId);
            if (!room) return;

            const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        });

        // Auto-generate chain dimensions if showDims is enabled
        if (App.showDims && doc.rooms.length > 0) {
            this.renderChainDimensions(doc);
            this.renderInteriorDimensions(doc);
            this.renderWallSegmentDimensions(doc);
        }

        this.layers.dims.batchDraw();
        this.layers.labels.batchDraw();
    },

    // Render grid lines at 1-foot intervals (scales with canvas)
    renderGrid() {
        if (!App.showGrid) return;

        this.layers.grid.destroyChildren();

        // Grid covers a large area to allow panning
        const gridExtent = 200 * FOOT; // 200 feet in each direction
        const startX = -gridExtent;
        const startY = -gridExtent;
        const endX = gridExtent;
        const endY = gridExtent;

        const minorStep = FOOT;      // 1 foot minor grid
        const majorStep = 5 * FOOT;  // 5 feet major grid

        // Minor grid lines (light)
        for (let x = startX; x <= endX; x += minorStep) {
            const isMajor = Math.abs(x % majorStep) < 0.1;
            if (!isMajor) {
                this.layers.grid.add(new Konva.Line({
                    points: [x, startY, x, endY],
                    stroke: 'rgba(59, 130, 246, 0.08)',
                    strokeWidth: 1,
                    listening: false
                }));
            }
        }
        for (let y = startY; y <= endY; y += minorStep) {
            const isMajor = Math.abs(y % majorStep) < 0.1;
            if (!isMajor) {
                this.layers.grid.add(new Konva.Line({
                    points: [startX, y, endX, y],
                    stroke: 'rgba(59, 130, 246, 0.08)',
                    strokeWidth: 1,
                    listening: false
                }));
            }
        }

        // Major grid lines (darker, every 5 feet)
        for (let x = startX; x <= endX; x += majorStep) {
            this.layers.grid.add(new Konva.Line({
                points: [x, startY, x, endY],
                stroke: 'rgba(59, 130, 246, 0.15)',
                strokeWidth: 1,
                listening: false
            }));
        }
        for (let y = startY; y <= endY; y += majorStep) {
            this.layers.grid.add(new Konva.Line({
                points: [startX, y, endX, y],
                stroke: 'rgba(59, 130, 246, 0.15)',
                strokeWidth: 1,
                listening: false
            }));
        }

        this.layers.grid.batchDraw();
    },

    render(doc, opts = {}) {
        if (!this.stage) return;
        const { showWallIds = true, showDims = true } = opts;

        ['rooms', 'walls', 'hit', 'openings', 'mep', 'labels', 'dims'].forEach(l => this.layers[l].destroyChildren());
        this.wallGroups = {};

        // Render grid (scales with canvas)
        this.renderGrid();

        // Room fills (non-listening)
        doc.rooms.forEach(r => this.renderRoomFill(r, doc));

        // Vertex handles for rooms with extra vertices (more than 4)
        doc.rooms.forEach(r => {
            if (r.vertices && r.vertices.length > 4) {
                this.renderVertexHandles(r, doc);
            }
        });

        // Wall segments (with hit regions)
        doc.wallSegments.forEach(ws => this.renderWallSegment(ws, doc, showWallIds));

        // Closets
        doc.closets.forEach(c => this.renderCloset(c, doc));

        // Doors
        doc.doors.forEach(d => this.renderDoor(d, doc));

        // Windows
        doc.windows.forEach(w => this.renderWindow(w, doc));

        // Cased openings
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));

        // MEP
        doc.mep.forEach(m => this.renderMEP(m, doc));

        // Dust Wipes
        if (doc.dustWipes) {
            doc.dustWipes.forEach(dw => this.renderDustWipe(dw, doc));
        }

        // Auto-generate chain dimensions based on current room layout
        if (showDims && doc.rooms.length > 0) {
            this.renderChainDimensions(doc);
            this.renderInteriorDimensions(doc);
            this.renderWallSegmentDimensions(doc);
        }

        Object.values(this.layers).forEach(l => l.batchDraw());
    },

    renderRoomFill(room, doc) {
        // Ensure both geometry and vertices exist
        let g = room.geometry;
        if (!g && room.vertices) {
            g = getGeometryFromVertices(room.vertices);
            room.geometry = g;
        }
        if (!g) return; // Can't render without geometry

        const isSelected = this.isSelected('room', room.id);
        const self = this;

        // Ensure room has vertices
        if (!room.vertices) {
            room.vertices = verticesFromGeometry(g);
        }
        const verts = room.vertices;
        const isPolygon = verts.length > 4; // Non-rectangular if more than 4 vertices

        // Find closets that belong to this room
        const roomClosets = doc.closets.filter(c => c.parentRoomId === room.id);

        // Create a group for the room (for dragging)
        // Disable dragging when in Edit Path mode
        const canDrag = isSelected && !App.editPathMode;
        const roomGroup = new Konva.Group({
            x: 0, y: 0,
            draggable: canDrag
        });

        // Room fill - light blue tint when selected, white when not
        const roomFill = isSelected ? '#dbeafe' : '#fafbfc';
        const roomBorder = isSelected ? '#2563eb' : '#2d3748'; // Dark border to match wall color

        // Shadow properties - subtle glow when selected, very light shadow when not
        const shadowProps = isSelected ? {
            shadowColor: '#3b82f6',
            shadowBlur: 12,
            shadowOffset: { x: 0, y: 0 },
            shadowOpacity: 0.5
        } : {
            shadowColor: 'rgba(0,0,0,0.15)',
            shadowBlur: 4,
            shadowOffset: { x: 2, y: 2 },
            shadowOpacity: 0.2
        };

        if (isPolygon) {
            // Render as polygon for non-rectangular rooms
            // Position the group at the bounding box origin, use relative coords for polygon
            roomGroup.x(g.x);
            roomGroup.y(g.y);
            const relativePoints = verts.flatMap(v => [v.x - g.x, v.y - g.y]);
            const polygon = new Konva.Line({
                points: relativePoints,
                fill: roomFill,
                stroke: roomBorder,
                strokeWidth: isSelected ? 2 : 1,
                closed: true,
                ...shadowProps
            });
            roomGroup.add(polygon);
        } else {
            // Simple room rectangle - positioned at room coordinates
            roomGroup.x(g.x);
            roomGroup.y(g.y);

            if (roomClosets.length === 0) {
                // Simple case: no closets
                roomGroup.add(new Konva.Rect({
                    x: 0, y: 0, width: g.width, height: g.height,
                    fill: roomFill,
                    stroke: roomBorder,
                    strokeWidth: isSelected ? 2 : 1,
                    ...shadowProps
                }));
            } else {
                // Room has closets - draw room fill excluding closet areas
                const roomShape = new Konva.Shape({
                    sceneFunc: (context, shape) => {
                        context.beginPath();
                        context.rect(0, 0, g.width, g.height);
                        // Cut out closet areas relative to room
                        roomClosets.forEach(closet => {
                            const cg = closet.geometry;
                            const cx = cg.x - g.x;
                            const cy = cg.y - g.y;
                            context.moveTo(cx, cy);
                            context.lineTo(cx, cy + cg.height);
                            context.lineTo(cx + cg.width, cy + cg.height);
                            context.lineTo(cx + cg.width, cy);
                            context.closePath();
                        });
                        context.fillStrokeShape(shape);
                    },
                    fill: roomFill,
                    stroke: roomBorder,
                    strokeWidth: isSelected ? 2 : 1,
                    ...shadowProps
                });
                roomGroup.add(roomShape);
            }
        }

        // Add tap handler for room selection
        roomGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            const pos = this.stage.getPointerPosition();
            const transform = this.stage.getAbsoluteTransform().copy().invert();
            const worldPos = pos ? transform.point(pos) : null;
            App.onRoomTap(room.id, worldPos);
        });

        // Prevent stage panning when clicking on rooms
        roomGroup.on('mousedown touchstart', (e) => {
            e.cancelBubble = true;
        });

        // Drag handling - only when selected and not in Edit Path mode
        if (canDrag) {
            let origGX, origGY, origVerts = [], startClosetPositions = [], snapPoints = null;

            roomGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                origGX = g.x;
                origGY = g.y;
                origVerts = room.vertices.map(v => ({ ...v }));
                startClosetPositions = roomClosets.map(c => ({ id: c.id, x: c.geometry.x, y: c.geometry.y }));
                snapPoints = findRoomSnapPoints(doc, room.id);
            });

            roomGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const rawX = this.x();
                const rawY = this.y();
                const snapped = snapRoomPosition(rawX, rawY, g.width, g.height, snapPoints);
                this.x(snapped.x);
                this.y(snapped.y);
            });

            roomGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                const finalX = this.x();
                const finalY = this.y();
                const dx = finalX - origGX;
                const dy = finalY - origGY;

                // Update room geometry
                g.x = finalX;
                g.y = finalY;

                // Update vertices
                room.vertices = origVerts.map(v => ({ x: v.x + dx, y: v.y + dy }));

                // Update wall segments from vertices
                const edges = getWallEdgesFromVertices(room);
                const segs = doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach((ws, idx) => {
                    if (edges[idx]) {
                        ws.x1 = edges[idx].start.x;
                        ws.y1 = edges[idx].start.y;
                        ws.x2 = edges[idx].end.x;
                        ws.y2 = edges[idx].end.y;
                    }
                });

                // Update closets
                roomClosets.forEach(closet => {
                    const sp = startClosetPositions.find(p => p.id === closet.id);
                    if (sp) {
                        closet.geometry.x = sp.x + dx;
                        closet.geometry.y = sp.y + dy;
                        // Update closet vertices
                        if (closet.vertices) {
                            closet.vertices = closet.vertices.map(v => ({ x: v.x + dx, y: v.y + dy }));
                        }
                        // Update closet wall segments
                        const closetEdges = getWallEdgesFromVertices(closet);
                        doc.wallSegments.filter(ws => ws.roomId === closet.id).forEach((ws, idx) => {
                            if (closetEdges[idx]) {
                                ws.x1 = closetEdges[idx].start.x;
                                ws.y1 = closetEdges[idx].start.y;
                                ws.x2 = closetEdges[idx].end.x;
                                ws.y2 = closetEdges[idx].end.y;
                            }
                        });
                    }
                });

                markExteriorWalls(doc);
                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });
        }

        this.layers.rooms.add(roomGroup);

        // Room label (inside) - show type as main label, ID underneath
        // Skip labels during live update to prevent duplicates
        if (!this._isLiveUpdating) {
            const centroid = isPolygon ? getPolygonCentroid(verts) : { x: g.x + g.width / 2, y: g.y + g.height / 2 };
            this.layers.labels.add(new Konva.Text({
                x: centroid.x - 50, y: centroid.y - 12, width: 100,
                text: room.type, fontSize: 13, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
            }));
            this.layers.labels.add(new Konva.Text({
                x: centroid.x - 50, y: centroid.y + 4, width: 100,
                text: room.label, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
            }));
        }
        // Note: Interior dimension LINES are rendered by renderInteriorDimensions()
        // Note: Exterior dimension lines are handled by renderChainDimensions()

        // Show handles when room is selected (skip during live update to preserve drag)
        if (isSelected && !this._isLiveUpdating) {
            // Show corner and edge resize handles
            this.renderResizeHandles(room, doc);

            // Show new vertex handle if one was just added
            if (App.newVertexInfo && App.newVertexInfo.roomId === room.id) {
                this.renderNewVertexHandle(room, doc);
            }
            // Or show all vertex handles for non-rectangular rooms (more than 4 vertices)
            else if (room.vertices && room.vertices.length > 4) {
                this.renderAllVertexHandles(room, doc);
            }
        }
    },

    // Render resize handles for rectangular rooms (4 corners)
    renderResizeHandles(room, doc) {
        const g = room.geometry;
        const self = this;
        const handleSize = 20;  // Larger for visibility

        // Corner positions: TL, TR, BR, BL
        const corners = [
            { x: g.x, y: g.y, cursor: 'nw-resize', corner: 'tl' },
            { x: g.x + g.width, y: g.y, cursor: 'ne-resize', corner: 'tr' },
            { x: g.x + g.width, y: g.y + g.height, cursor: 'se-resize', corner: 'br' },
            { x: g.x, y: g.y + g.height, cursor: 'sw-resize', corner: 'bl' }
        ];

        corners.forEach((c, idx) => {
            // Create a group for each handle
            const handleGroup = new Konva.Group({
                x: c.x,
                y: c.y,
                draggable: true,
                name: 'resize-handle'
            });

            // Background circle
            handleGroup.add(new Konva.Circle({
                x: 0, y: 0,
                radius: handleSize / 2,
                fill: '#3b82f6',
                stroke: '#fff',
                strokeWidth: 2
            }));

            // Plus sign
            handleGroup.add(new Konva.Line({
                points: [-6, 0, 6, 0],
                stroke: '#fff',
                strokeWidth: 2,
                lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [0, -6, 0, 6],
                stroke: '#fff',
                strokeWidth: 2,
                lineCap: 'round'
            }));

            const handle = handleGroup;

            let startG = null;

            handle.on('dragstart', function() {
                startG = { ...g };
                self.stage.draggable(false);
            });

            handle.on('dragmove', function() {
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                this.x(newX);
                this.y(newY);

                // Update geometry based on which corner is being dragged
                if (c.corner === 'tl') {
                    g.width = startG.x + startG.width - newX;
                    g.height = startG.y + startG.height - newY;
                    g.x = newX;
                    g.y = newY;
                } else if (c.corner === 'tr') {
                    g.width = newX - g.x;
                    g.height = startG.y + startG.height - newY;
                    g.y = newY;
                } else if (c.corner === 'br') {
                    g.width = newX - g.x;
                    g.height = newY - g.y;
                } else if (c.corner === 'bl') {
                    g.width = startG.x + startG.width - newX;
                    g.height = newY - g.y;
                    g.x = newX;
                }

                // Enforce minimum size
                if (g.width < 2 * FOOT) g.width = 2 * FOOT;
                if (g.height < 2 * FOOT) g.height = 2 * FOOT;

                // Update vertices from geometry
                room.vertices = verticesFromGeometry(g);

                // Live update
                self.updateRoomLive(room, doc);
            });

            handle.on('dragend', function() {
                self.stage.draggable(true);
                self.clearResizePreview();
                App.syncGeometryFromVertices(room);
                regenerateWallSegments(room, doc);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
            });

            this.layers.openings.add(handle);
        });

        // Mid-edge handles for single-direction resize (top, right, bottom, left)
        const edgeHandleSize = 16;
        const edges = [
            { x: g.x + g.width / 2, y: g.y, dir: 'top', axis: 'y' },
            { x: g.x + g.width, y: g.y + g.height / 2, dir: 'right', axis: 'x' },
            { x: g.x + g.width / 2, y: g.y + g.height, dir: 'bottom', axis: 'y' },
            { x: g.x, y: g.y + g.height / 2, dir: 'left', axis: 'x' }
        ];

        edges.forEach((e) => {
            const edgeGroup = new Konva.Group({
                x: e.x,
                y: e.y,
                draggable: true,
                name: 'edge-handle'
            });

            // Background circle (smaller, different color)
            edgeGroup.add(new Konva.Circle({
                x: 0, y: 0,
                radius: edgeHandleSize / 2,
                fill: '#22c55e',
                stroke: '#fff',
                strokeWidth: 2
            }));

            // Arrow indicator based on direction
            if (e.axis === 'y') {
                // Vertical arrows for top/bottom
                edgeGroup.add(new Konva.Line({
                    points: [0, -4, 0, 4],
                    stroke: '#fff',
                    strokeWidth: 2,
                    lineCap: 'round'
                }));
                edgeGroup.add(new Konva.Line({
                    points: [-3, -1, 0, -4, 3, -1],
                    stroke: '#fff',
                    strokeWidth: 1.5,
                    lineCap: 'round',
                    lineJoin: 'round'
                }));
                edgeGroup.add(new Konva.Line({
                    points: [-3, 1, 0, 4, 3, 1],
                    stroke: '#fff',
                    strokeWidth: 1.5,
                    lineCap: 'round',
                    lineJoin: 'round'
                }));
            } else {
                // Horizontal arrows for left/right
                edgeGroup.add(new Konva.Line({
                    points: [-4, 0, 4, 0],
                    stroke: '#fff',
                    strokeWidth: 2,
                    lineCap: 'round'
                }));
                edgeGroup.add(new Konva.Line({
                    points: [-1, -3, -4, 0, -1, 3],
                    stroke: '#fff',
                    strokeWidth: 1.5,
                    lineCap: 'round',
                    lineJoin: 'round'
                }));
                edgeGroup.add(new Konva.Line({
                    points: [1, -3, 4, 0, 1, 3],
                    stroke: '#fff',
                    strokeWidth: 1.5,
                    lineCap: 'round',
                    lineJoin: 'round'
                }));
            }

            let startG = null;

            edgeGroup.on('dragstart', function() {
                startG = { ...g };
                self.stage.draggable(false);
            });

            edgeGroup.on('dragmove', function() {
                // Constrain to single axis
                if (e.axis === 'x') {
                    this.y(e.y);  // Lock Y
                    const newX = snapToGrid(this.x());
                    this.x(newX);

                    if (e.dir === 'left') {
                        g.width = startG.x + startG.width - newX;
                        g.x = newX;
                    } else { // right
                        g.width = newX - g.x;
                    }
                } else {
                    this.x(e.x);  // Lock X
                    const newY = snapToGrid(this.y());
                    this.y(newY);

                    if (e.dir === 'top') {
                        g.height = startG.y + startG.height - newY;
                        g.y = newY;
                    } else { // bottom
                        g.height = newY - g.y;
                    }
                }

                // Enforce minimum size
                if (g.width < 2 * FOOT) g.width = 2 * FOOT;
                if (g.height < 2 * FOOT) g.height = 2 * FOOT;

                // Update vertices from geometry
                room.vertices = verticesFromGeometry(g);

                // Live update
                self.updateRoomLive(room, doc);
            });

            edgeGroup.on('dragend', function() {
                self.stage.draggable(true);
                self.clearResizePreview();
                App.syncGeometryFromVertices(room);
                regenerateWallSegments(room, doc);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
            });

            this.layers.openings.add(edgeGroup);
        });
    },

    // Render vertex handles for rooms with extra vertices (non-rectangular)
    // Shows draggable points that can be used to reshape the room
    renderVertexHandles(room, doc) {
        const verts = room.vertices;
        if (!verts || verts.length <= 4) return; // Only show for non-rectangular rooms

        const self = this;
        const handleRadius = 10;

        // Vertex handles - orange circles, draggable
        // Double-tap to delete (if >4 vertices)
        verts.forEach((v, idx) => {
            const handle = new Konva.Circle({
                x: v.x, y: v.y,
                radius: handleRadius,
                fill: '#f97316',
                stroke: '#fff',
                strokeWidth: 2,
                draggable: true,
                name: 'vertex-handle'
            });

            let lastTapTime = 0;

            handle.on('dragstart', function() {
                self.stage.draggable(false);
            });

            handle.on('dragmove', function() {
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                this.x(newX);
                this.y(newY);

                // Update vertex
                const tempVerts = room.vertices.map(v => ({ ...v }));
                tempVerts[idx] = { x: newX, y: newY };

                // Only apply if no self-intersection
                if (!polygonSelfIntersects(tempVerts)) {
                    room.vertices[idx] = { x: newX, y: newY };
                    self.updateRoomLive(room, doc);
                }
            });

            handle.on('dragend', function() {
                self.stage.draggable(true);
                self.clearResizePreview();
                App.syncGeometryFromVertices(room);
                regenerateWallSegments(room, doc);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
            });

            // Double-tap to delete vertex (if >4 remain)
            handle.on('tap click', function(e) {
                const now = Date.now();
                if (now - lastTapTime < 400) {
                    e.cancelBubble = true;
                    App.deleteVertex(room, idx);
                }
                lastTapTime = now;
            });

            this.layers.openings.add(handle);
        });
    },

    // Render a push handle for the newly added segment
    // User can drag this perpendicular to the segment to create L, T, H shapes
    renderPushHandle(room, doc) {
        const ps = App.pushableSegment;
        if (!ps || ps.roomId !== room.id) return;

        const verts = room.vertices;
        const v1 = verts[ps.vertexIdx1];
        const v2 = verts[ps.vertexIdx2];
        if (!v1 || !v2) {
            // Indices no longer valid, clear pushable segment
            App.pushableSegment = null;
            return;
        }

        const self = this;
        const handleSize = 20;

        // Calculate midpoint of the pushable segment
        const midX = (v1.x + v2.x) / 2;
        const midY = (v1.y + v2.y) / 2;

        // Calculate the perpendicular direction (for constraining drag)
        const segDx = v2.x - v1.x;
        const segDy = v2.y - v1.y;
        const isHorizontal = Math.abs(segDx) > Math.abs(segDy);

        // Create handle group - green like edge handles but larger
        const handleGroup = new Konva.Group({
            x: midX,
            y: midY,
            draggable: true,
            name: 'push-handle'
        });

        // Background circle - green to match edge handles
        handleGroup.add(new Konva.Circle({
            x: 0, y: 0,
            radius: handleSize / 2,
            fill: '#22c55e',
            stroke: '#fff',
            strokeWidth: 3
        }));

        // Arrow indicator based on direction
        if (isHorizontal) {
            // Vertical arrows for horizontal segment (push up/down)
            handleGroup.add(new Konva.Line({
                points: [0, -5, 0, 5],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-3, -2, 0, -5, 3, -2],
                stroke: '#fff', strokeWidth: 1.5, lineCap: 'round', lineJoin: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-3, 2, 0, 5, 3, 2],
                stroke: '#fff', strokeWidth: 1.5, lineCap: 'round', lineJoin: 'round'
            }));
        } else {
            // Horizontal arrows for vertical segment (push left/right)
            handleGroup.add(new Konva.Line({
                points: [-5, 0, 5, 0],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-2, -3, -5, 0, -2, 3],
                stroke: '#fff', strokeWidth: 1.5, lineCap: 'round', lineJoin: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [2, -3, 5, 0, 2, 3],
                stroke: '#fff', strokeWidth: 1.5, lineCap: 'round', lineJoin: 'round'
            }));
        }

        const handle = handleGroup;

        let startV1 = null, startV2 = null;

        handle.on('dragstart', function() {
            self.stage.draggable(false);
            startV1 = { ...v1 };
            startV2 = { ...v2 };
        });

        handle.on('dragmove', function() {
            // Constrain drag to perpendicular direction only
            const newX = this.x();
            const newY = this.y();
            const dx = newX - midX;
            const dy = newY - midY;

            let offsetX = 0, offsetY = 0;
            if (isHorizontal) {
                // Only allow vertical movement
                offsetY = snapToGrid(dy);
                this.x(midX);  // Lock X position
                this.y(snapToGrid(midY + offsetY));
            } else {
                // Only allow horizontal movement
                offsetX = snapToGrid(dx);
                this.x(snapToGrid(midX + offsetX));
                this.y(midY);  // Lock Y position
            }

            // Move both vertices perpendicular
            const newV1 = { x: snapToGrid(startV1.x + offsetX), y: snapToGrid(startV1.y + offsetY) };
            const newV2 = { x: snapToGrid(startV2.x + offsetX), y: snapToGrid(startV2.y + offsetY) };

            // Check for self-intersection
            const tempVerts = room.vertices.map(v => ({ ...v }));
            tempVerts[ps.vertexIdx1] = newV1;
            tempVerts[ps.vertexIdx2] = newV2;

            if (!polygonSelfIntersects(tempVerts)) {
                room.vertices[ps.vertexIdx1] = newV1;
                room.vertices[ps.vertexIdx2] = newV2;
                self.updateRoomLive(room, doc);
            }
        });

        handle.on('dragend', function() {
            self.stage.draggable(true);
            App.syncGeometryFromVertices(room);
            regenerateWallSegments(room, doc);
            markExteriorWalls(doc);
            App.pushableSegment = null;  // Clear after first push
            App.saveState();
            App.render();

            // Hide hint
            $('#toolHint').classList.remove('show');
        });

        this.layers.openings.add(handle);
    },

    // Render a handle for the newly added segment (2 vertices) - drag to reshape
    renderNewVertexHandle(room, doc) {
        const info = App.newVertexInfo;
        if (!info || info.roomId !== room.id) return;

        const verts = room.vertices;
        const v1 = verts[info.vertexIdx1];
        const v2 = verts[info.vertexIdx2];
        if (!v1 || !v2) {
            App.newVertexInfo = null;
            return;
        }

        const self = this;
        const handleSize = 24;

        // Position at midpoint of the two vertices
        const midX = (v1.x + v2.x) / 2;
        const midY = (v1.y + v2.y) / 2;

        // Create handle group - bright green, larger
        const handleGroup = new Konva.Group({
            x: midX,
            y: midY,
            draggable: true,
            name: 'new-segment-handle'
        });

        // Background circle
        handleGroup.add(new Konva.Circle({
            x: 0, y: 0,
            radius: handleSize / 2,
            fill: '#22c55e',
            stroke: '#fff',
            strokeWidth: 3
        }));

        // Arrow indicator based on direction
        if (info.isHorizontal) {
            // Vertical arrows (up/down) for horizontal wall segment
            handleGroup.add(new Konva.Line({
                points: [0, -6, 0, 6],
                stroke: '#fff', strokeWidth: 2.5, lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-4, -2, 0, -6, 4, -2],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round', lineJoin: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-4, 2, 0, 6, 4, 2],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round', lineJoin: 'round'
            }));
        } else {
            // Horizontal arrows (left/right) for vertical wall segment
            handleGroup.add(new Konva.Line({
                points: [-6, 0, 6, 0],
                stroke: '#fff', strokeWidth: 2.5, lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [-2, -4, -6, 0, -2, 4],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round', lineJoin: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [2, -4, 6, 0, 2, 4],
                stroke: '#fff', strokeWidth: 2, lineCap: 'round', lineJoin: 'round'
            }));
        }

        let startV1 = null, startV2 = null;

        handleGroup.on('dragstart', function() {
            self.stage.draggable(false);
            startV1 = { ...v1 };
            startV2 = { ...v2 };
        });

        handleGroup.on('dragmove', function() {
            const dx = this.x() - midX;
            const dy = this.y() - midY;

            // Constrain to perpendicular direction
            let offsetX = 0, offsetY = 0;
            if (info.isHorizontal) {
                // Only allow vertical movement
                offsetY = snapToGrid(dy);
                this.x(midX);
                this.y(snapToGrid(midY + offsetY));
            } else {
                // Only allow horizontal movement
                offsetX = snapToGrid(dx);
                this.x(snapToGrid(midX + offsetX));
                this.y(midY);
            }

            // Move both vertices together
            const newV1 = { x: snapToGrid(startV1.x + offsetX), y: snapToGrid(startV1.y + offsetY) };
            const newV2 = { x: snapToGrid(startV2.x + offsetX), y: snapToGrid(startV2.y + offsetY) };

            // Check for self-intersection
            const tempVerts = room.vertices.map(v => ({ ...v }));
            tempVerts[info.vertexIdx1] = newV1;
            tempVerts[info.vertexIdx2] = newV2;

            if (!polygonSelfIntersects(tempVerts)) {
                room.vertices[info.vertexIdx1] = newV1;
                room.vertices[info.vertexIdx2] = newV2;
                self.updateRoomLive(room, doc);
            }
        });

        handleGroup.on('dragend', function() {
            self.stage.draggable(true);
            self.clearResizePreview();
            App.syncGeometryFromVertices(room);
            regenerateWallSegments(room, doc);
            markExteriorWalls(doc);
            App.newVertexInfo = null;  // Clear after dragging
            App.saveState();
            App.render();
        });

        this.layers.openings.add(handleGroup);
    },

    // Render handles for all vertices (for non-rectangular rooms)
    renderAllVertexHandles(room, doc) {
        const verts = room.vertices;
        if (!verts || verts.length <= 4) return;

        const self = this;
        const handleSize = 16;

        verts.forEach((v, idx) => {
            const handleGroup = new Konva.Group({
                x: v.x,
                y: v.y,
                draggable: true,
                name: 'vertex-handle'
            });

            // Green circle
            handleGroup.add(new Konva.Circle({
                x: 0, y: 0,
                radius: handleSize / 2,
                fill: '#22c55e',
                stroke: '#fff',
                strokeWidth: 2
            }));

            handleGroup.on('dragstart', function() {
                self.stage.draggable(false);
            });

            handleGroup.on('dragmove', function() {
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                this.x(newX);
                this.y(newY);

                const tempVerts = room.vertices.map(v => ({ ...v }));
                tempVerts[idx] = { x: newX, y: newY };

                if (!polygonSelfIntersects(tempVerts)) {
                    room.vertices[idx] = { x: newX, y: newY };
                    self.updateRoomLive(room, doc);
                }
            });

            handleGroup.on('dragend', function() {
                self.stage.draggable(true);
                self.clearResizePreview();
                App.syncGeometryFromVertices(room);
                regenerateWallSegments(room, doc);
                markExteriorWalls(doc);
                App.saveState();
                App.render();
            });

            this.layers.openings.add(handleGroup);
        });
    },

    // Live update room during resize - smooth real-time update
    updateRoomLive(room, doc) {
        // Update geometry
        const g = getGeometryFromVertices(room.vertices);
        if (g) room.geometry = g;

        // Update wall coordinates (for dragend)
        const edges = getWallEdgesFromVertices(room);
        const roomWalls = doc.wallSegments.filter(ws => ws.roomId === room.id);
        roomWalls.forEach((ws, i) => {
            if (edges[i]) {
                ws.x1 = edges[i].start.x;
                ws.y1 = edges[i].start.y;
                ws.x2 = edges[i].end.x;
                ws.y2 = edges[i].end.y;
            }
        });

        // Set flag to skip label rendering (prevents duplicates)
        this._isLiveUpdating = true;

        // Clear and re-render only the rooms layer for smooth visual update
        this.layers.rooms.destroyChildren();
        doc.rooms.forEach(r => this.renderRoomFill(r, doc));
        this.layers.rooms.batchDraw();

        this._isLiveUpdating = false;
    },

    // Clear resize state after drag ends (legacy, kept for compatibility)
    clearResizePreview() {
        // Cleanup any preview elements if they exist
        if (this._resizePreview) {
            this._resizePreview.destroy();
            this._resizePreview = null;
        }
        this._isLiveUpdating = false;
    },

    // Render room as polygon (for vertex editing)
    renderRoomFillPolygon(room, doc) {
        const verts = room.vertices || verticesFromGeometry(room.geometry);
        const g = room.geometry;
        const isSelected = this.isSelected('room', room.id);

        const roomFill = isSelected ? '#dbeafe' : '#fafbfc';
        const roomBorder = isSelected ? '#2563eb' : '#2d3748'; // Dark border to match wall color

        const shadowProps = isSelected ? {
            shadowColor: '#3b82f6',
            shadowBlur: 12,
            shadowOffset: { x: 0, y: 0 },
            shadowOpacity: 0.5
        } : {
            shadowColor: 'rgba(0,0,0,0.15)',
            shadowBlur: 4,
            shadowOffset: { x: 2, y: 2 },
            shadowOpacity: 0.2
        };

        // Render as closed polygon
        const points = getVerticesAsPoints(verts);
        const polygon = new Konva.Line({
            points: points,
            fill: roomFill,
            stroke: roomBorder,
            strokeWidth: isSelected ? 2 : 1,
            closed: true,
            ...shadowProps
        });

        polygon.on('tap click', (e) => {
            e.cancelBubble = true;
            const pos = this.stage.getPointerPosition();
            const transform = this.stage.getAbsoluteTransform().copy().invert();
            const worldPos = pos ? transform.point(pos) : null;
            App.onRoomTap(room.id, worldPos);
        });

        polygon.on('mousedown touchstart', (e) => {
            e.cancelBubble = true;
        });

        this.layers.rooms.add(polygon);

        // Room labels
        const centroid = getPolygonCentroid(verts);
        this.layers.labels.add(new Konva.Text({
            x: centroid.x - 50, y: centroid.y - 12, width: 100,
            text: room.type, fontSize: 13, fontStyle: 'bold',
            fill: isSelected ? '#3b82f6' : '#1f2937', align: 'center', listening: false
        }));
        this.layers.labels.add(new Konva.Text({
            x: centroid.x - 50, y: centroid.y + 4, width: 100,
            text: room.label, fontSize: 10, fill: '#6b7280', align: 'center', listening: false
        }));
    },

    // Update walls from vertices during live editing
    updateWallsFromVertices(room, doc) {
        const edges = getWallEdgesFromVertices(room);

        // Clear and redraw walls
        this.layers.walls.destroyChildren();
        this.layers.hit.destroyChildren();

        // Re-render all wall segments with updated positions for this room
        doc.wallSegments.forEach(ws => {
            // For the editing room, use edge positions from vertices
            if (ws.roomId === room.id) {
                // Use edge index (stored in ws.index - 1, since index is 1-based)
                const edgeIdx = (ws.index || 1) - 1;
                if (edges[edgeIdx]) {
                    ws.x1 = edges[edgeIdx].start.x;
                    ws.y1 = edges[edgeIdx].start.y;
                    ws.x2 = edges[edgeIdx].end.x;
                    ws.y2 = edges[edgeIdx].end.y;
                    ws.side = edges[edgeIdx].side;
                    ws.label = edges[edgeIdx].label;
                }
            }

            // Render wall
            const wallColor = '#2d3748';
            const isExterior = ws.type === 'exterior';
            const wallWidth = isExterior ? 2 : 1;

            this.layers.walls.add(new Konva.Line({
                points: [ws.x1 + 4, ws.y1 + 4, ws.x2 + 4, ws.y2 + 4],
                stroke: 'rgba(0,0,0,0.5)',
                strokeWidth: wallWidth + 2,
                lineCap: 'round',
                listening: false
            }));
            this.layers.walls.add(new Konva.Line({
                points: [ws.x1, ws.y1, ws.x2, ws.y2],
                stroke: wallColor,
                strokeWidth: wallWidth,
                lineCap: 'round',
                listening: false
            }));
        });

        this.layers.walls.batchDraw();
        this.layers.hit.batchDraw();

        // Also re-render openings so they move with walls
        this.layers.openings.destroyChildren();
        doc.doors.forEach(d => this.renderDoor(d, doc));
        doc.windows.forEach(w => this.renderWindow(w, doc));
        doc.casedOpenings.forEach(o => this.renderCasedOpening(o, doc));
        this.layers.openings.batchDraw();
    },

    renderWallSegment(ws, doc, showWallIds) {
        // Find room or closet (closets are rooms too)
        let room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) room = doc.closets.find(c => c.id === ws.roomId);
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const isExterior = ws.type === 'exterior';

        // Wall group
        const group = new Konva.Group({ id: ws.id });
        this.wallGroups[ws.id] = group;

        // Visible wall line - dark grey, exterior walls thicker
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = isSelected ? 3 : (isExterior ? 2 : 1);

        // Main wall line
        const visibleLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: wallColor,
            strokeWidth: wallWidth,
            lineCap: 'round',
            listening: false
        });
        group.add(visibleLine);

        // HIT REGION (invisible, wide stroke for mobile tapping)
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', (e) => {
            const pos = this.stage.getPointerPosition();
            const transform = this.stage.getAbsoluteTransform().copy().invert();
            const worldPos = pos ? transform.point(pos) : null;
            App.onWallTap(ws.id, worldPos);
        });
        hitLine.on('pointerdown', (e) => {
            const pos = this.stage.getPointerPosition();
            const transform = this.stage.getAbsoluteTransform().copy().invert();
            const worldPos = pos ? transform.point(pos) : null;
            App.onWallTap(ws.id, worldPos);
        });
        this.layers.hit.add(hitLine);

        // Wall ID label
        if (showWallIds) {
            const mid = getSegmentMidpoint(ws);
            const labelOffset = this.getLabelOffset(ws, room);
            this.layers.labels.add(new Konva.Text({
                x: mid.x + labelOffset.x - 8, y: mid.y + labelOffset.y - 5,
                text: ws.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#9ca3af', fontStyle: 'bold', listening: false
            }));
        }

        this.layers.walls.add(group);
    },

    getLabelOffset(ws, room) {
        if (!room) return { x: 0, y: 0 };
        const g = room.geometry;
        const mid = getSegmentMidpoint(ws);
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = mid.x - cx;
        const dy = mid.y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        // Push label outward (away from room center) to avoid overlapping
        return { x: (dx / dist) * 16, y: (dy / dist) * 12 };
    },

    renderCloset(closet, doc) {
        const g = closet.geometry;
        const isSelected = this.isSelected('closet', closet.id);
        const parentRoom = doc.rooms.find(r => r.id === closet.parentRoomId);
        const pg = parentRoom ? parentRoom.geometry : null;

        // Closet fill with light grey and shadow (closets are rooms too)
        // Blue glow when selected, dark shadow when not
        const closetShadowProps = isSelected ? {
            shadowColor: '#3b82f6',
            shadowBlur: 10,
            shadowOffset: { x: 0, y: 0 },
            shadowOpacity: 0.4
        } : {
            shadowColor: 'rgba(0,0,0,0.15)',
            shadowBlur: 3,
            shadowOffset: { x: 2, y: 2 },
            shadowOpacity: 0.15
        };
        // Closet is a room - render in rooms layer so shadow shows properly
        const closetGroup = new Konva.Group({
            x: g.x, y: g.y,
            draggable: isSelected
        });
        const self = this;

        const rect = new Konva.Rect({
            x: 0, y: 0, width: g.width, height: g.height,
            fill: '#f3f4f6', stroke: isSelected ? '#3b82f6' : '#d1d5db', strokeWidth: isSelected ? 2 : 1,
            ...closetShadowProps
        });
        closetGroup.add(rect);

        // Diagonal hatch lines (architectural convention for closets)
        const hatchGroup = new Konva.Group({ clip: { x: 0, y: 0, width: g.width, height: g.height } });
        const spacing = 12;
        const hatchColor = '#d1d5db';
        for (let i = -g.height; i < g.width + g.height; i += spacing) {
            hatchGroup.add(new Konva.Line({
                points: [i, 0, i + g.height, g.height],
                stroke: hatchColor, strokeWidth: 1, listening: false
            }));
        }
        closetGroup.add(hatchGroup);

        closetGroup.on('tap click', (e) => {
            e.cancelBubble = true;
            // If dust wipe tool is active, place floor sample
            if (App.currentTool === 'dustwipe') {
                const pos = this.stage.getPointerPosition();
                const transform = this.stage.getAbsoluteTransform().copy().invert();
                const worldPos = pos ? transform.point(pos) : null;
                if (worldPos) {
                    App.showFloorSampleModal(worldPos.x, worldPos.y, closet.id);
                }
            } else {
                App.onObjectTap('closet', closet.id);
            }
        });
        // Prevent stage panning when clicking on closets
        closetGroup.on('mousedown touchstart', (e) => {
            e.cancelBubble = true;
        });

        // Add drag functionality for closets when selected
        if (isSelected) {
            let snapPoints = null;

            closetGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
                snapPoints = findRoomSnapPoints(doc, closet.id);
            });

            closetGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                // this.x() and this.y() are the absolute position of the group
                const rawX = this.x();
                const rawY = this.y();
                const snapped = snapRoomPosition(rawX, rawY, g.width, g.height, snapPoints);
                // Set snapped position directly
                this.x(snapped.x);
                this.y(snapped.y);
            });

            closetGroup.on('dragend', function(e) {
                self.stage.draggable(true);

                // Final position is just the group's current position
                const finalX = this.x();
                const finalY = this.y();

                // Update closet geometry
                g.x = finalX;
                g.y = finalY;

                // Update closet wall segments
                doc.wallSegments.filter(ws => ws.roomId === closet.id).forEach(ws => {
                    if (ws.label === 'W1') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                    else if (ws.label === 'W2') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x; ws.y2 = g.y; }
                    else if (ws.label === 'W3') { ws.x1 = g.x; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y; }
                    else if (ws.label === 'W4') { ws.x1 = g.x + g.width; ws.y1 = g.y; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                });

                // Update parentRoomId if closet moved outside its parent
                const newParent = doc.rooms.find(room => {
                    const rg = room.geometry;
                    const overlapX = Math.max(0, Math.min(g.x + g.width, rg.x + rg.width) - Math.max(g.x, rg.x));
                    const overlapY = Math.max(0, Math.min(g.y + g.height, rg.y + rg.height) - Math.max(g.y, rg.y));
                    const overlapArea = overlapX * overlapY;
                    const closetArea = g.width * g.height;
                    return overlapArea > closetArea * 0.5;
                });
                if (newParent) {
                    closet.parentRoomId = newParent.id;
                    closet.parentRoomLabel = newParent.label;
                } else {
                    closet.parentRoomId = null;
                    closet.parentRoomLabel = null;
                }

                App.saveState();
                App.render();
                App.updateTree();
                App.updateInspector();
                App.updateQABadge();
            });
        }

        this.layers.rooms.add(closetGroup);

        // Draw closet walls and make them clickable for placing doors
        const wallColor = isSelected ? '#3b82f6' : '#2d3748';
        const wallWidth = 1;

        // Get closet's wall segments for hit detection
        const closetWalls = doc.wallSegments.filter(ws => ws.roomId === closet.id);

        // Helper to check if wall should be rendered (not touching parent room edge)
        const shouldRenderWall = (side) => {
            if (!pg) return true;  // Always render if no parent room
            switch (side) {
                case 'south': return g.y + g.height < pg.y + pg.height;
                case 'north': return g.y > pg.y;
                case 'west': return g.x > pg.x;
                case 'east': return g.x + g.width < pg.x + pg.width;
                default: return true;
            }
        };

        // Render all closet walls (with hit detection for door placement)
        closetWalls.forEach(wall => {
            if (shouldRenderWall(wall.side)) {
                this.renderClosetWall(wall, wallColor, wallWidth);
            }
        });

        // Fallback: if no wall segments exist, draw basic lines
        if (closetWalls.length === 0) {
            if (shouldRenderWall('south')) {
                this.layers.walls.add(new Konva.Line({
                    points: [g.x, g.y + g.height, g.x + g.width, g.y + g.height],
                    stroke: wallColor, strokeWidth: wallWidth, listening: false
                }));
            }
            if (shouldRenderWall('north')) {
                this.layers.walls.add(new Konva.Line({
                    points: [g.x, g.y, g.x + g.width, g.y],
                    stroke: wallColor, strokeWidth: wallWidth, listening: false
                }));
            }
            if (shouldRenderWall('west')) {
                this.layers.walls.add(new Konva.Line({
                    points: [g.x, g.y, g.x, g.y + g.height],
                    stroke: wallColor, strokeWidth: wallWidth, listening: false
                }));
            }
            if (shouldRenderWall('east')) {
                this.layers.walls.add(new Konva.Line({
                    points: [g.x + g.width, g.y, g.x + g.width, g.y + g.height],
                    stroke: wallColor, strokeWidth: wallWidth, listening: false
                }));
            }
        }

        // Closet label with parent room indicator
        const parentLabel = parentRoom ? ` → ${parentRoom.label}` : '';
        this.layers.labels.add(new Konva.Text({
            x: g.x, y: g.y + g.height / 2 - 12, width: g.width,
            text: closet.label, fontSize: 10, fontStyle: 'bold', fill: isSelected ? '#3b82f6' : '#6b7280', align: 'center', listening: false
        }));
        // Show parent room indicator
        if (parentRoom) {
            this.layers.labels.add(new Konva.Text({
                x: g.x, y: g.y + g.height / 2 + 2, width: g.width,
                text: `(${parentRoom.label})`, fontSize: 8, fill: '#9ca3af', align: 'center', listening: false
            }));
        }

        // Show connection line to parent room when selected
        if (isSelected && parentRoom && pg) {
            const closetCenterX = g.x + g.width / 2;
            const closetCenterY = g.y + g.height / 2;
            const roomCenterX = pg.x + pg.width / 2;
            const roomCenterY = pg.y + pg.height / 2;

            this.layers.dims.add(new Konva.Line({
                points: [closetCenterX, closetCenterY, roomCenterX, roomCenterY],
                stroke: '#3b82f6',
                strokeWidth: 1,
                dash: [4, 4],
                listening: false
            }));
        }

        // Show resize handles when closet is selected (same as rooms)
        if (isSelected) {
            this.renderClosetResizeHandles(closet, doc);

            // Show new vertex handle if one was just added (for joints)
            if (App.newVertexInfo && App.newVertexInfo.roomId === closet.id) {
                this.renderNewVertexHandle(closet, doc);
            }
            // Or show all vertex handles for non-rectangular closets (more than 4 vertices)
            else if (closet.vertices && closet.vertices.length > 4) {
                this.renderAllVertexHandles(closet, doc);
            }
        }
    },

    // Render resize handles for closets (similar to rooms)
    renderClosetResizeHandles(closet, doc) {
        const g = closet.geometry;
        const self = this;
        const handleSize = 16;  // Slightly smaller than room handles

        // Corner positions: TL, TR, BR, BL
        const corners = [
            { x: g.x, y: g.y, cursor: 'nw-resize', corner: 'tl' },
            { x: g.x + g.width, y: g.y, cursor: 'ne-resize', corner: 'tr' },
            { x: g.x + g.width, y: g.y + g.height, cursor: 'se-resize', corner: 'br' },
            { x: g.x, y: g.y + g.height, cursor: 'sw-resize', corner: 'bl' }
        ];

        corners.forEach((c, idx) => {
            const handleGroup = new Konva.Group({
                x: c.x,
                y: c.y,
                draggable: true,
                name: 'closet-resize-handle'
            });

            // Background circle
            handleGroup.add(new Konva.Circle({
                x: 0, y: 0,
                radius: handleSize / 2,
                fill: '#6b7280',
                stroke: '#fff',
                strokeWidth: 2
            }));

            // Plus sign
            handleGroup.add(new Konva.Line({
                points: [-5, 0, 5, 0],
                stroke: '#fff',
                strokeWidth: 2,
                lineCap: 'round'
            }));
            handleGroup.add(new Konva.Line({
                points: [0, -5, 0, 5],
                stroke: '#fff',
                strokeWidth: 2,
                lineCap: 'round'
            }));

            let startG = null;

            handleGroup.on('dragstart', function() {
                startG = { ...g };
                self.stage.draggable(false);
            });

            handleGroup.on('dragmove', function() {
                const newX = snapToGrid(this.x());
                const newY = snapToGrid(this.y());
                this.x(newX);
                this.y(newY);

                // Update geometry based on which corner is being dragged
                if (c.corner === 'tl') {
                    g.width = startG.x + startG.width - newX;
                    g.height = startG.y + startG.height - newY;
                    g.x = newX;
                    g.y = newY;
                } else if (c.corner === 'tr') {
                    g.width = newX - g.x;
                    g.height = startG.y + startG.height - newY;
                    g.y = newY;
                } else if (c.corner === 'br') {
                    g.width = newX - g.x;
                    g.height = newY - g.y;
                } else if (c.corner === 'bl') {
                    g.width = startG.x + startG.width - newX;
                    g.height = newY - g.y;
                    g.x = newX;
                }

                // Enforce minimum size (closets can be smaller than rooms: 1.5' min)
                if (g.width < 1.5 * FOOT) g.width = 1.5 * FOOT;
                if (g.height < 1.5 * FOOT) g.height = 1.5 * FOOT;

                // Update vertices from geometry
                closet.vertices = verticesFromGeometry(g);

                // Live update
                self.updateClosetLive(closet, doc);
            });

            handleGroup.on('dragend', function() {
                App.restoreStageDraggable();
                App.syncGeometryFromVertices(closet);
                regenerateWallSegments(closet, doc);
                App.saveState();
                App.render();
            });

            this.layers.openings.add(handleGroup);
        });

        // Mid-edge handles for single-direction resize
        const edgeHandleSize = 14;
        const edges = [
            { x: g.x + g.width / 2, y: g.y, dir: 'top', axis: 'y' },
            { x: g.x + g.width, y: g.y + g.height / 2, dir: 'right', axis: 'x' },
            { x: g.x + g.width / 2, y: g.y + g.height, dir: 'bottom', axis: 'y' },
            { x: g.x, y: g.y + g.height / 2, dir: 'left', axis: 'x' }
        ];

        edges.forEach((e) => {
            const edgeGroup = new Konva.Group({
                x: e.x,
                y: e.y,
                draggable: true,
                name: 'closet-edge-handle'
            });

            edgeGroup.add(new Konva.Circle({
                x: 0, y: 0,
                radius: edgeHandleSize / 2,
                fill: '#9ca3af',
                stroke: '#fff',
                strokeWidth: 2
            }));

            // Arrow indicator
            if (e.axis === 'y') {
                edgeGroup.add(new Konva.Line({
                    points: [0, -3, 0, 3],
                    stroke: '#fff', strokeWidth: 2, lineCap: 'round'
                }));
            } else {
                edgeGroup.add(new Konva.Line({
                    points: [-3, 0, 3, 0],
                    stroke: '#fff', strokeWidth: 2, lineCap: 'round'
                }));
            }

            let startG = null;

            edgeGroup.on('dragstart', function() {
                startG = { ...g };
                self.stage.draggable(false);
            });

            edgeGroup.on('dragmove', function() {
                if (e.axis === 'y') {
                    const newY = snapToGrid(this.y());
                    this.x(e.x);
                    this.y(newY);
                    if (e.dir === 'top') {
                        g.height = startG.y + startG.height - newY;
                        g.y = newY;
                    } else {
                        g.height = newY - g.y;
                    }
                } else {
                    const newX = snapToGrid(this.x());
                    this.x(newX);
                    this.y(e.y);
                    if (e.dir === 'left') {
                        g.width = startG.x + startG.width - newX;
                        g.x = newX;
                    } else {
                        g.width = newX - g.x;
                    }
                }

                // Closets can be smaller than rooms: 1.5' min
                if (g.width < 1.5 * FOOT) g.width = 1.5 * FOOT;
                if (g.height < 1.5 * FOOT) g.height = 1.5 * FOOT;

                closet.vertices = verticesFromGeometry(g);
                self.updateClosetLive(closet, doc);
            });

            edgeGroup.on('dragend', function() {
                App.restoreStageDraggable();
                App.syncGeometryFromVertices(closet);
                regenerateWallSegments(closet, doc);
                App.saveState();
                App.render();
            });

            this.layers.openings.add(edgeGroup);
        });
    },

    // Live update closet during resize drag
    updateClosetLive(closet, doc) {
        const g = getGeometryFromVertices(closet.vertices);
        if (g) closet.geometry = g;

        // Set flag to skip label rendering (prevents duplicates)
        this._isLiveUpdating = true;

        // Rebuild closets layer
        this.layers.rooms.destroyChildren();
        doc.rooms.forEach(r => this.renderRoomFill(r, doc));
        doc.closets.forEach(c => this.renderCloset(c, doc));
        this.layers.rooms.batchDraw();

        this._isLiveUpdating = false;
    },

    // Render a closet wall with hit detection for placing doors
    renderClosetWall(ws, wallColor, wallWidth) {
        const isSelected = this.selection.type === 'wall' && this.selection.id === ws.id;
        const finalWidth = isSelected ? 2 : wallWidth;

        // Visible wall line
        this.layers.walls.add(new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: isSelected ? '#3b82f6' : wallColor,
            strokeWidth: finalWidth,
            lineCap: 'round',
            listening: false
        }));

        // Hit region for wall selection and door placement
        const hitLine = new Konva.Line({
            points: [ws.x1, ws.y1, ws.x2, ws.y2],
            stroke: 'transparent',
            strokeWidth: HIT_WIDTH,
            lineCap: 'round',
            hitStrokeWidth: HIT_WIDTH
        });
        hitLine.on('tap click', (e) => {
            const pos = this.stage.getPointerPosition();
            const transform = this.stage.getAbsoluteTransform().copy().invert();
            const worldPos = pos ? transform.point(pos) : null;
            App.onWallTap(ws.id, worldPos);
        });
        this.layers.hit.add(hitLine);
    },

    renderDoor(door, doc) {
        const ws = doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, door.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isVertical = Math.abs(Math.sin(angle)) > 0.5;
        const isSelected = this.selection.type === 'door' && this.selection.id === door.id;

        const doorGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Door opening (gap in wall) - covers wall line and shadow
        const wallClearHeight = 16;  // Enough to cover wall + shadow
        const doorRect = new Konva.Rect({
            x: -2, y: -wallClearHeight / 2,
            width: door.width + 4,
            height: wallClearHeight,
            fill: '#f0f7ff',  // Match blueprint background
            stroke: 'transparent'
        });
        doorGroup.add(doorRect);

        // Door jambs (thin lines at edges of opening)
        const jambColor = '#2d3748';
        const jambHeight = 8;
        doorGroup.add(new Konva.Line({
            points: [0, -jambHeight/2, 0, jambHeight/2],
            stroke: jambColor, strokeWidth: 2
        }));
        doorGroup.add(new Konva.Line({
            points: [door.width, -jambHeight/2, door.width, jambHeight/2],
            stroke: jambColor, strokeWidth: 2
        }));

        // Different rendering based on door type
        let swingArc, doorLeaf, hingeY = 0, leafEndY = 0;
        const doorColor = isSelected ? '#3b82f6' : '#2d3748';
        const swingOut = door.swing === 'out' ? -1 : 1;

        if (door.type === 'sliding') {
            // Sliding door - door panel halfway in front of perforated line
            hingeY = 0; leafEndY = 0;
            const panelWidth = door.width * 0.55;
            // Perforated/dashed line (track) behind
            doorGroup.add(new Konva.Line({
                points: [0, 0, door.width, 0],
                stroke: '#9ca3af', strokeWidth: 1.5, dash: [4, 3]
            }));
            // Door panel in front (shifted to show it's halfway open)
            doorGroup.add(new Konva.Rect({
                x: door.width * 0.25, y: -4,
                width: panelWidth, height: 8,
                fill: doorColor, stroke: doorColor, strokeWidth: 1, cornerRadius: 1
            }));
        } else if (door.type === 'double' || door.swingDir === 'both') {
            // Double door - two leaves swinging forward (like regular but mirrored)
            const halfWidth = door.width / 2;
            const leafLength = halfWidth * 0.9;
            hingeY = swingOut * ws.thickness / 2;
            leafEndY = hingeY + swingOut * leafLength;
            // Left door - hinged on left, swings right
            doorGroup.add(new Konva.Arc({ x: 0, y: hingeY, innerRadius: leafLength - 1, outerRadius: leafLength, angle: 90, rotation: swingOut > 0 ? 0 : -90, stroke: '#9ca3af', strokeWidth: 1, dash: [4, 3] }));
            doorGroup.add(new Konva.Line({ points: [0, hingeY, 0, leafEndY], stroke: doorColor, strokeWidth: 3, lineCap: 'round' }));
            // Right door - hinged on right, swings left
            doorGroup.add(new Konva.Arc({ x: door.width, y: hingeY, innerRadius: leafLength - 1, outerRadius: leafLength, angle: 90, rotation: swingOut > 0 ? 90 : 180, stroke: '#9ca3af', strokeWidth: 1, dash: [4, 3] }));
            doorGroup.add(new Konva.Line({ points: [door.width, hingeY, door.width, leafEndY], stroke: doorColor, strokeWidth: 3, lineCap: 'round' }));
        } else if (door.type === 'bifold') {
            // Single bifold - V shape (two panels meeting at a point)
            hingeY = swingOut * ws.thickness / 2;
            const vDepth = door.width * 0.4 * swingOut;
            leafEndY = hingeY + vDepth;
            const midX = door.width / 2;
            // Left panel (from left jamb to center point)
            doorGroup.add(new Konva.Line({ points: [0, hingeY, midX, leafEndY], stroke: doorColor, strokeWidth: 3, lineCap: 'round' }));
            // Right panel (from center point to right jamb)
            doorGroup.add(new Konva.Line({ points: [midX, leafEndY, door.width, hingeY], stroke: doorColor, strokeWidth: 3, lineCap: 'round' }));
            // Fold point indicator
            doorGroup.add(new Konva.Circle({ x: midX, y: leafEndY, radius: 3, fill: '#9ca3af' }));
        } else if (door.type === 'bifold-double') {
            // Double bifold - W shape (two V's side by side)
            hingeY = swingOut * ws.thickness / 2;
            const vDepth = door.width * 0.25 * swingOut;
            leafEndY = hingeY + vDepth;
            const quarterX = door.width / 4;
            const threeQuarterX = door.width * 3 / 4;
            // Left V
            doorGroup.add(new Konva.Line({ points: [0, hingeY, quarterX, leafEndY], stroke: doorColor, strokeWidth: 2.5, lineCap: 'round' }));
            doorGroup.add(new Konva.Line({ points: [quarterX, leafEndY, door.width / 2, hingeY], stroke: doorColor, strokeWidth: 2.5, lineCap: 'round' }));
            doorGroup.add(new Konva.Circle({ x: quarterX, y: leafEndY, radius: 2.5, fill: '#9ca3af' }));
            // Right V
            doorGroup.add(new Konva.Line({ points: [door.width / 2, hingeY, threeQuarterX, leafEndY], stroke: doorColor, strokeWidth: 2.5, lineCap: 'round' }));
            doorGroup.add(new Konva.Line({ points: [threeQuarterX, leafEndY, door.width, hingeY], stroke: doorColor, strokeWidth: 2.5, lineCap: 'round' }));
            doorGroup.add(new Konva.Circle({ x: threeQuarterX, y: leafEndY, radius: 2.5, fill: '#9ca3af' }));
        } else if (door.type === 'pocket') {
            // Pocket door - panel slides into wall
            hingeY = 0; leafEndY = 0;
            // Panel (partially hidden)
            doorGroup.add(new Konva.Rect({ x: -door.width * 0.3, y: -3, width: door.width * 0.8, height: 6, fill: doorColor, cornerRadius: 1 }));
            // Wall pocket indicator (dashed)
            doorGroup.add(new Konva.Rect({ x: -door.width * 0.5, y: -5, width: door.width * 0.5, height: 10, stroke: '#9ca3af', strokeWidth: 1, dash: [3, 2], fill: 'transparent' }));
            // Arrow
            doorGroup.add(new Konva.Line({ points: [door.width * 0.3, -8, door.width * 0.3 - 10, -8], stroke: '#9ca3af', strokeWidth: 1.5 }));
            doorGroup.add(new Konva.Line({ points: [door.width * 0.3 - 7, -11, door.width * 0.3 - 10, -8, door.width * 0.3 - 7, -5], stroke: '#9ca3af', strokeWidth: 1.5, lineCap: 'round' }));
        } else if (door.type === 'overhead') {
            // Overhead door - door behind perforated line (door in back, dashed line in front)
            hingeY = 0; leafEndY = 0;
            const panelOffset = swingOut * 12; // Door panel offset behind the wall line
            // Door panel behind (solid rectangle)
            doorGroup.add(new Konva.Rect({
                x: 2, y: panelOffset - 4,
                width: door.width - 4, height: 8,
                fill: doorColor, stroke: doorColor, strokeWidth: 1, cornerRadius: 1
            }));
            // Perforated/dashed line in front (at wall line)
            doorGroup.add(new Konva.Line({
                points: [0, 0, door.width, 0],
                stroke: '#9ca3af', strokeWidth: 2, dash: [6, 4]
            }));
        } else if (door.type === 'elevator') {
            // Elevator door - center opening
            hingeY = 0; leafEndY = 0;
            const panelWidth = door.width / 2;
            // Left panel
            doorGroup.add(new Konva.Rect({ x: 2, y: -4, width: panelWidth - 4, height: 8, stroke: doorColor, strokeWidth: 2, fill: 'transparent' }));
            // Right panel
            doorGroup.add(new Konva.Rect({ x: panelWidth + 2, y: -4, width: panelWidth - 4, height: 8, stroke: doorColor, strokeWidth: 2, fill: 'transparent' }));
            // Center arrows
            doorGroup.add(new Konva.Line({ points: [panelWidth - 4, 0, panelWidth - 10, 0], stroke: '#9ca3af', strokeWidth: 1.5 }));
            doorGroup.add(new Konva.Line({ points: [panelWidth - 7, -3, panelWidth - 10, 0, panelWidth - 7, 3], stroke: '#9ca3af', strokeWidth: 1.5, lineCap: 'round' }));
            doorGroup.add(new Konva.Line({ points: [panelWidth + 4, 0, panelWidth + 10, 0], stroke: '#9ca3af', strokeWidth: 1.5 }));
            doorGroup.add(new Konva.Line({ points: [panelWidth + 7, -3, panelWidth + 10, 0, panelWidth + 7, 3], stroke: '#9ca3af', strokeWidth: 1.5, lineCap: 'round' }));
        } else if (door.type === 'revolving') {
            // Revolving door - circular with cross
            hingeY = 0; leafEndY = 0;
            const radius = Math.min(door.width / 2, 20);
            const centerX = door.width / 2;
            doorGroup.add(new Konva.Circle({ x: centerX, y: 0, radius: radius, stroke: doorColor, strokeWidth: 2, fill: 'transparent' }));
            // Cross panels
            doorGroup.add(new Konva.Line({ points: [centerX - radius + 2, 0, centerX + radius - 2, 0], stroke: doorColor, strokeWidth: 2 }));
            doorGroup.add(new Konva.Line({ points: [centerX, -radius + 2, centerX, radius - 2], stroke: doorColor, strokeWidth: 2 }));
            // Center hub
            doorGroup.add(new Konva.Circle({ x: centerX, y: 0, radius: 3, fill: doorColor }));
        } else {
            // Regular single door
            const hingeLeft = door.swingDir === 'left';
            const hingeX = hingeLeft ? 0 : door.width;
            hingeY = swingOut * ws.thickness / 2;
            const leafLength = door.width * 0.9;
            leafEndY = hingeY + swingOut * leafLength;
            swingArc = new Konva.Arc({
                x: hingeX, y: hingeY, innerRadius: leafLength - 1, outerRadius: leafLength,
                angle: 90, rotation: hingeLeft ? (swingOut > 0 ? 0 : -90) : (swingOut > 0 ? 90 : 180),
                stroke: '#9ca3af', strokeWidth: 1, dash: [4, 3]
            });
            doorGroup.add(swingArc);
            doorLeaf = new Konva.Line({ points: [hingeX, hingeY, hingeX, leafEndY], stroke: doorColor, strokeWidth: 3, lineCap: 'round' });
            doorGroup.add(doorLeaf);
        }

        // Large invisible hit area for easier selection
        const hitHeight = Math.max(Math.abs(leafEndY - hingeY), 20) + 15;
        const hitArea = new Konva.Rect({
            x: -5,
            y: Math.min(hingeY, leafEndY, -10) - 5,
            width: door.width + 10,
            height: hitHeight,
            fill: 'transparent',
            stroke: 'transparent'
        });
        doorGroup.add(hitArea);

        doorGroup.on('tap click', () => {
            // If dust wipe tool is active, show door sample modal
            if (App.currentTool === 'dustwipe') {
                App.showDoorSampleModal(door.id);
            } else {
                App.onObjectTap('door', door.id);
            }
        });
        this.layers.openings.add(doorGroup);

        // Label
        const doorLabel = new Konva.Text({
            x: pos.x + (isVertical ? 12 : 0), y: pos.y + (isVertical ? 0 : -14),
            text: door.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#6b7280', listening: false
        });
        this.layers.labels.add(doorLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, door.distanceFromStart + door.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateDoorVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, door.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);

                // Recalculate door geometry
                const newHingeX = hingeLeft ? 0 : door.width;
                const newLeafLength = door.width * 0.9;
                const newLeafEndX = newHingeX;  // 90 degrees - straight perpendicular
                const newLeafEndY = hingeY + swingOut * newLeafLength;

                // Update door group position and rect width
                doorGroup.x(newPos.x);
                doorGroup.y(newPos.y);
                doorRect.width(door.width);

                // Update swing arc
                swingArc.x(newHingeX);
                swingArc.innerRadius(newLeafLength - 1);
                swingArc.outerRadius(newLeafLength);

                // Update door leaf
                doorLeaf.points([newHingeX, hingeY, newLeafEndX, newLeafEndY]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire door along wall
            doorGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            doorGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const maxOffset = getSegmentLength(ws) - door.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                door.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + door.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                doorLabel.x(newPos.x + (isVertical ? 12 : 0));
                doorLabel.y(newPos.y + (isVertical ? 0 : -14));

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            doorGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const oldEnd = door.distanceFromStart + door.width;
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches
                const maxWidth = 6 * FOOT;    // Doors max 6 feet

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth && (oldEnd - newOffset) <= maxWidth) {
                    door.width = oldEnd - newOffset;
                    door.distanceFromStart = newOffset;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newEnd = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const newWidth = newEnd - door.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 0.5 * FOOT;  // Doors min 6 inches
                const maxWidth = 6 * FOOT;    // Doors max 6 feet

                if (newWidth >= minWidth && newWidth <= maxWidth && newEnd <= maxOffset) {
                    door.width = newWidth;
                    updateDoorVisuals();
                }
                const handlePos = self.getPositionOnSegment(ws, door.distanceFromStart + door.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderWindow(win, doc) {
        const ws = doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
        if (!ws) return;

        const pos = this.getPositionOnSegment(ws, win.distanceFromStart);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'window' && this.selection.id === win.id;

        const winGroup = new Konva.Group({
            x: pos.x, y: pos.y,
            rotation: angle * 180 / Math.PI,
            draggable: isSelected  // Allow dragging when selected
        });

        // Window opening (gap in wall) - covers wall line and shadow
        const winThickness = 8;  // Thicker window frame
        const wallClearHeight = 16;  // Enough to cover wall + shadow
        const winRect = new Konva.Rect({
            x: -2, y: -wallClearHeight / 2,
            width: win.width + 4, height: wallClearHeight,
            fill: '#f0f7ff',  // Match blueprint background
            stroke: 'transparent'
        });
        winGroup.add(winRect);

        // Window frame lines (top and bottom sill) - thicker
        const frameColor = isSelected ? '#3b82f6' : '#60a5fa';
        const topSill = new Konva.Line({
            points: [0, -winThickness / 2, win.width, -winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(topSill);

        const bottomSill = new Konva.Line({
            points: [0, winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 3
        });
        winGroup.add(bottomSill);

        // Window jambs (ends)
        const leftJamb = new Konva.Line({
            points: [0, -winThickness / 2, 0, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(leftJamb);

        const rightJamb = new Konva.Line({
            points: [win.width, -winThickness / 2, win.width, winThickness / 2],
            stroke: frameColor, strokeWidth: 2
        });
        winGroup.add(rightJamb);

        // Mullion (center divider)
        const mullion = new Konva.Line({
            points: [win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2],
            stroke: frameColor, strokeWidth: 1
        });
        winGroup.add(mullion);

        winGroup.on('tap click', () => {
            // If dust wipe tool is active, show window sample modal
            if (App.currentTool === 'dustwipe') {
                App.showWindowSampleModal(win.id);
            } else {
                App.onObjectTap('window', win.id);
            }
        });
        this.layers.openings.add(winGroup);

        const winLabel = new Konva.Text({
            x: pos.x + win.width / 2 - 15, y: pos.y - 14,
            text: win.label, fontSize: 9, fill: isSelected ? '#3b82f6' : '#60a5fa', listening: false
        });
        this.layers.labels.add(winLabel);

        // Add resize handles and drag-to-move when selected
        if (isSelected) {
            const handleSize = 16;  // Mobile-friendly touch target
            const self = this;

            // Left handle (adjusts offset and width)
            const leftHandle = new Konva.Circle({
                x: pos.x, y: pos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Right handle (adjusts width only)
            const rightPos = this.getPositionOnSegment(ws, win.distanceFromStart + win.width);
            const rightHandle = new Konva.Circle({
                x: rightPos.x, y: rightPos.y,
                radius: handleSize / 2,
                fill: '#3b82f6', stroke: '#fff', strokeWidth: 2,
                draggable: true
            });

            // Update visuals directly without full re-render
            const updateWindowVisuals = () => {
                const newPos = self.getPositionOnSegment(ws, win.distanceFromStart);
                const newRightPos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);

                // Update window group position
                winGroup.x(newPos.x);
                winGroup.y(newPos.y);

                // Update rect width
                winRect.width(win.width);

                // Update frame lines
                topSill.points([0, -winThickness / 2, win.width, -winThickness / 2]);
                bottomSill.points([0, winThickness / 2, win.width, winThickness / 2]);
                rightJamb.points([win.width, -winThickness / 2, win.width, winThickness / 2]);
                mullion.points([win.width / 2, -winThickness / 2, win.width / 2, winThickness / 2]);

                // Update handle positions
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            };

            // Drag-to-move the entire window along wall
            winGroup.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);  // Disable stage panning
            });
            winGroup.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const maxOffset = getSegmentLength(ws) - win.width;

                // Constrain to wall bounds
                const clampedOffset = Math.max(0, Math.min(newOffset, maxOffset));
                win.distanceFromStart = clampedOffset;

                // Snap to wall position
                const newPos = self.getPositionOnSegment(ws, clampedOffset);
                this.x(newPos.x);
                this.y(newPos.y);

                // Update handle positions
                const newRightPos = self.getPositionOnSegment(ws, clampedOffset + win.width);
                leftHandle.x(newPos.x);
                leftHandle.y(newPos.y);
                rightHandle.x(newRightPos.x);
                rightHandle.y(newRightPos.y);

                // Update label position
                winLabel.x(newPos.x + win.width / 2 - 15);
                winLabel.y(newPos.y - 14);

                self.layers.openings.batchDraw();
                self.layers.labels.batchDraw();
            });
            winGroup.on('dragend', () => {
                self.stage.draggable(true);  // Re-enable stage panning
                App.saveState();
                App.updateInspector();
            });

            leftHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const oldEnd = win.distanceFromStart + win.width;
                const minWidth = 1 * FOOT;
                const maxWidth = 12 * FOOT;  // Windows max 12 feet

                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth && (oldEnd - newOffset) <= maxWidth) {
                    win.width = oldEnd - newOffset;
                    win.distanceFromStart = newOffset;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            rightHandle.on('dragstart', function(e) {
                e.cancelBubble = true;
                self.stage.draggable(false);
            });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newEnd = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const newWidth = newEnd - win.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 1 * FOOT;
                const maxWidth = 12 * FOOT;  // Windows max 12 feet

                if (newWidth >= minWidth && newWidth <= maxWidth && newEnd <= maxOffset) {
                    win.width = newWidth;
                    updateWindowVisuals();
                }
                // Keep handle at pointer position during drag
                const handlePos = self.getPositionOnSegment(ws, win.distanceFromStart + win.width);
                this.x(handlePos.x);
                this.y(handlePos.y);
            });

            leftHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });
            rightHandle.on('dragend', () => {
                self.stage.draggable(true);
                App.saveState();
                App.updateInspector();
                App.updateQABadge();
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);
        }
    },

    renderCasedOpening(op, doc) {
        const ws = doc.wallSegments.find(s => s.id === op.parentWallSegmentId);
        if (!ws) return;

        const self = this;
        const startPos = this.getPositionOnSegment(ws, op.distanceFromStart);
        const endPos = this.getPositionOnSegment(ws, op.distanceFromStart + op.width);
        const angle = getSegmentAngle(ws);
        const isSelected = this.selection.type === 'cased' && this.selection.id === op.id;
        const color = isSelected ? '#06b6d4' : '#888';

        // Calculate perpendicular direction for marks
        const perpX = -Math.sin(angle);
        const perpY = Math.cos(angle);
        const markLen = 8;

        // Create group positioned at start, rotated to wall angle
        const opGroup = new Konva.Group({
            x: startPos.x,
            y: startPos.y,
            rotation: angle * 180 / Math.PI,
            draggable: true
        });

        // Clear wall area (the gap/empty space)
        const wallClearHeight = 20;
        const clearRect = new Konva.Rect({
            x: -4,
            y: -wallClearHeight / 2,
            width: op.width + 8,
            height: wallClearHeight,
            fill: '#f0f7ff'
        });
        opGroup.add(clearRect);

        // Left end mark (perpendicular to wall)
        opGroup.add(new Konva.Line({
            points: [0, -markLen, 0, markLen],
            stroke: color, strokeWidth: 2, lineCap: 'round'
        }));
        // Right end mark
        opGroup.add(new Konva.Line({
            points: [op.width, -markLen, op.width, markLen],
            stroke: color, strokeWidth: 2, lineCap: 'round'
        }));

        opGroup.on('tap click', () => App.onObjectTap('cased', op.id));

        // Drag to reposition along wall
        opGroup.on('dragstart', (e) => { e.cancelBubble = true; self.stage.draggable(false); });
        opGroup.on('dragmove', function(e) {
            e.cancelBubble = true;
            const pointer = self.stage.getPointerPosition();
            const transform = self.stage.getAbsoluteTransform().copy().invert();
            const worldPos = transform.point(pointer);
            const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
            const maxOffset = getSegmentLength(ws) - op.width;
            op.distanceFromStart = Math.max(0, Math.min(newOffset, maxOffset));
            App.render();
        });
        opGroup.on('dragend', () => { self.stage.draggable(true); App.saveState(); });

        this.layers.openings.add(opGroup);

        // Label centered above the opening
        const midX = (startPos.x + endPos.x) / 2;
        const midY = (startPos.y + endPos.y) / 2;
        const opLabel = new Konva.Text({
            x: midX - 10, y: midY - 18,
            text: op.label, fontSize: 9, fill: color, listening: false
        });
        this.layers.labels.add(opLabel);

        // Add resize handles when selected
        if (isSelected) {
            const handleSize = 14;
            const handleColor = '#06b6d4';

            // Left resize handle at start of opening
            const leftHandle = new Konva.Circle({
                x: startPos.x, y: startPos.y,
                radius: handleSize / 2,
                fill: handleColor, stroke: '#fff', strokeWidth: 2, draggable: true
            });

            // Right resize handle at end of opening
            const rightHandle = new Konva.Circle({
                x: endPos.x, y: endPos.y,
                radius: handleSize / 2,
                fill: handleColor, stroke: '#fff', strokeWidth: 2, draggable: true
            });

            this.layers.openings.add(leftHandle);
            this.layers.openings.add(rightHandle);

            // Left handle - resize from left
            leftHandle.on('dragstart', (e) => { e.cancelBubble = true; self.stage.draggable(false); });
            leftHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newOffset = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const oldEnd = op.distanceFromStart + op.width;
                const minWidth = 0.5 * FOOT;
                const maxWidth = 12 * FOOT;
                if (newOffset >= 0 && (oldEnd - newOffset) >= minWidth && (oldEnd - newOffset) <= maxWidth) {
                    op.width = oldEnd - newOffset;
                    op.distanceFromStart = newOffset;
                    // Keep handle at pointer position along wall
                    const newPos = self.getPositionOnSegment(ws, op.distanceFromStart);
                    this.x(newPos.x);
                    this.y(newPos.y);
                }
            });
            leftHandle.on('dragend', () => { self.stage.draggable(true); App.saveState(); App.render(); });

            // Right handle - resize from right
            rightHandle.on('dragstart', (e) => { e.cancelBubble = true; self.stage.draggable(false); });
            rightHandle.on('dragmove', function(e) {
                e.cancelBubble = true;
                const pointer = self.stage.getPointerPosition();
                const transform = self.stage.getAbsoluteTransform().copy().invert();
                const worldPos = transform.point(pointer);
                const newEnd = self.getOffsetOnSegment(ws, worldPos.x, worldPos.y);
                const newWidth = newEnd - op.distanceFromStart;
                const maxOffset = getSegmentLength(ws);
                const minWidth = 0.5 * FOOT;
                const maxWidth = 12 * FOOT;
                if (newWidth >= minWidth && newWidth <= maxWidth && newEnd <= maxOffset) {
                    op.width = newWidth;
                    // Keep handle at pointer position along wall
                    const newEndPos = self.getPositionOnSegment(ws, op.distanceFromStart + op.width);
                    this.x(newEndPos.x);
                    this.y(newEndPos.y);
                }
            });
            rightHandle.on('dragend', () => { self.stage.draggable(true); App.saveState(); App.render(); });
        }
    },

    renderMEP(mep, doc) {
        const ws = doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
        if (!ws) return;

        const isSelected = this.selection.type === 'mep' && this.selection.id === mep.id;
        const color = isSelected ? '#3b82f6' : (mep.label.startsWith('GAS') ? '#f97316' : mep.label.startsWith('POE') ? '#ef4444' : '#22c55e');

        // Use free x,y position if available, otherwise calculate from wall
        let posX, posY;
        if (mep.x !== undefined && mep.y !== undefined) {
            posX = mep.x;
            posY = mep.y;
        } else {
            // Legacy: calculate from wall position
            const wallPos = this.getPositionOnSegment(ws, mep.distanceFromStart || 0);
            posX = wallPos.x;
            posY = wallPos.y;
        }

        if (mep.label.startsWith('PIPE')) {
            const shape = new Konva.Circle({ x: posX, y: posY, radius: 8, stroke: color, strokeWidth: 2, fill: '#fff', draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('GAS')) {
            const shape = new Konva.Circle({ x: posX, y: posY, radius: 8, fill: color, draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('POE')) {
            // POE follows its anchor door if one exists
            let poeX = posX, poeY = posY;
            if (mep.anchorDoorId) {
                const anchorDoor = doc.doors.find(d => d.id === mep.anchorDoorId);
                if (anchorDoor) {
                    const doorWs = doc.wallSegments.find(s => s.id === anchorDoor.parentWallSegmentId);
                    if (doorWs) {
                        const doorPos = this.getPositionOnSegment(doorWs, anchorDoor.distanceFromStart + anchorDoor.width / 2);
                        poeX = doorPos.x;
                        poeY = doorPos.y;
                        // Update the mep position to stay synced with door
                        mep.x = poeX;
                        mep.y = poeY;
                    }
                }
            }
            const shape = new Konva.RegularPolygon({ x: poeX, y: poeY, sides: 3, radius: 12, fill: color, rotation: 0, draggable: isSelected });
            shape.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            if (isSelected) this.addMEPDragHandlers(shape, mep, ws);
            this.layers.mep.add(shape);
        } else if (mep.label.startsWith('RAD')) {
            // Radiators use free positioning
            const centerX = posX;
            const centerY = posY;
            const self = this;
            const radGroup = new Konva.Group({
                x: centerX,
                y: centerY,
                rotation: mep.rotation || 0,
                draggable: isSelected
            });

            // Draw radiator centered at origin (0,0) so rotation works correctly
            const halfW = mep.width / 2;
            const halfH = mep.height / 2;

            // Main housing
            radGroup.add(new Konva.Rect({
                x: -halfW, y: -halfH, width: mep.width, height: mep.height,
                fill: '#f9fafb', stroke: color, strokeWidth: 2, cornerRadius: 3
            }));

            // Vertical fins (radiator style)
            const finCount = Math.max(3, Math.floor(mep.width / 12));
            const finSpacing = mep.width / (finCount + 1);
            const finPadding = 4;
            for (let i = 1; i <= finCount; i++) {
                radGroup.add(new Konva.Line({
                    points: [-halfW + i * finSpacing, -halfH + finPadding, -halfW + i * finSpacing, halfH - finPadding],
                    stroke: color, strokeWidth: 1.5, opacity: 0.7
                }));
            }

            // Top and bottom horizontal pipes
            radGroup.add(new Konva.Line({
                points: [-halfW + 4, -halfH + 6, halfW - 4, -halfH + 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));
            radGroup.add(new Konva.Line({
                points: [-halfW + 4, halfH - 6, halfW - 4, halfH - 6],
                stroke: color, strokeWidth: 2, lineCap: 'round'
            }));

            radGroup.on('tap click', (e) => {
                e.cancelBubble = true;
                App.onObjectTap('mep', mep.id);
            });

            // Prevent stage panning when interacting with radiator
            radGroup.on('mousedown touchstart', (e) => {
                e.cancelBubble = true;
            });

            // Drag handling for radiator - free positioning
            if (isSelected) {
                radGroup.on('dragstart', function(e) {
                    e.cancelBubble = true;
                    self.stage.draggable(false);
                });

                radGroup.on('dragmove', function(e) {
                    e.cancelBubble = true;
                });

                radGroup.on('dragend', function(e) {
                    self.stage.draggable(true);
                    // Save free x,y position (wall registration stays the same)
                    mep.x = this.x();
                    mep.y = this.y();
                    App.saveState();
                    App.render();
                });
            }

            this.layers.mep.add(radGroup);
        } else if (mep.label.startsWith('PRSR')) {
            // Pipe Riser - uses free positioning
            const self = this;
            const riserGroup = new Konva.Group({
                x: posX,
                y: posY,
                draggable: isSelected
            });

            // Outer circle
            riserGroup.add(new Konva.Circle({
                x: 0, y: 0, radius: 12,
                fill: '#f3f4f6', stroke: color, strokeWidth: 2
            }));
            // Inner circle (pipe)
            riserGroup.add(new Konva.Circle({
                x: 0, y: 0, radius: 6,
                fill: '#e5e7eb', stroke: color, strokeWidth: 1
            }));

            riserGroup.on('tap click', (e) => { e.cancelBubble = true; App.onObjectTap('mep', mep.id); });
            riserGroup.on('mousedown touchstart', (e) => { e.cancelBubble = true; });

            if (isSelected) {
                riserGroup.on('dragstart', function(e) { e.cancelBubble = true; self.stage.draggable(false); });
                riserGroup.on('dragmove', function(e) { e.cancelBubble = true; });
                riserGroup.on('dragend', function(e) {
                    self.stage.draggable(true);
                    mep.x = this.x();
                    mep.y = this.y();
                    App.saveState();
                    App.render();
                });
            }
            this.layers.mep.add(riserGroup);
        }

        // Label uses the mep's x,y position
        this.layers.labels.add(new Konva.Text({
            x: posX + 14, y: posY - 5,
            text: mep.label, fontSize: 8, fill: color, listening: false
        }));
    },

    // Helper to add drag handlers for simple MEP shapes (PIPE, GAS, POE)
    addMEPDragHandlers(shape, mep, ws) {
        const self = this;
        shape.on('mousedown touchstart', (e) => { e.cancelBubble = true; });
        shape.on('dragstart', function(e) { e.cancelBubble = true; self.stage.draggable(false); });
        shape.on('dragmove', function(e) { e.cancelBubble = true; });
        shape.on('dragend', function(e) {
            self.stage.draggable(true);
            mep.x = this.x();
            mep.y = this.y();
            App.saveState();
            App.render();
        });
    },

    // Render dust wipe sample marker (X indicator)
    renderDustWipe(dw, doc) {
        const isSelected = this.selection.type === 'dustwipe' && this.selection.id === dw.id;
        const color = isSelected ? '#3b82f6' : '#ef4444';
        const self = this;

        let posX = dw.x;
        let posY = dw.y;

        // If attached to a window, calculate position from window
        if (dw.parentWindowId) {
            const win = doc.windows.find(w => w.id === dw.parentWindowId);
            if (win) {
                const ws = doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
                if (ws) {
                    const pos = this.getPositionOnSegment(ws, win.distanceFromStart + win.width / 2);
                    posX = pos.x;
                    posY = pos.y - 20; // Offset from window
                }
            }
        }

        // Create X marker group
        const group = new Konva.Group({
            x: posX,
            y: posY,
            draggable: isSelected
        });

        // X shape
        const xSize = 10;
        group.add(new Konva.Line({
            points: [-xSize, -xSize, xSize, xSize],
            stroke: color,
            strokeWidth: 3,
            lineCap: 'round'
        }));
        group.add(new Konva.Line({
            points: [xSize, -xSize, -xSize, xSize],
            stroke: color,
            strokeWidth: 3,
            lineCap: 'round'
        }));

        // Circle background for better visibility
        group.add(new Konva.Circle({
            x: 0, y: 0,
            radius: xSize + 4,
            stroke: color,
            strokeWidth: 1.5,
            fill: 'rgba(255,255,255,0.8)'
        }));

        // Re-add X on top
        group.add(new Konva.Line({
            points: [-xSize, -xSize, xSize, xSize],
            stroke: color,
            strokeWidth: 3,
            lineCap: 'round'
        }));
        group.add(new Konva.Line({
            points: [xSize, -xSize, -xSize, xSize],
            stroke: color,
            strokeWidth: 3,
            lineCap: 'round'
        }));

        group.on('tap click', (e) => {
            e.cancelBubble = true;
            App.onObjectTap('dustwipe', dw.id);
        });

        group.on('mousedown touchstart', (e) => { e.cancelBubble = true; });

        if (isSelected) {
            group.on('dragstart', function(e) { e.cancelBubble = true; self.stage.draggable(false); });
            group.on('dragmove', function(e) { e.cancelBubble = true; });
            group.on('dragend', function(e) {
                self.stage.draggable(true);
                dw.x = this.x();
                dw.y = this.y();
                App.saveState();
                App.render();
            });
        }

        this.layers.mep.add(group);

        // Label with sample number
        const labelText = dw.label + (dw.locationType ? ` (${dw.locationType})` : '');
        this.layers.labels.add(new Konva.Text({
            x: posX + 18, y: posY - 6,
            text: labelText, fontSize: 8, fill: color, listening: false
        }));
    },

    getPositionOnSegment(seg, distFromStart) {
        const len = getSegmentLength(seg);
        const t = Math.min(distFromStart / len, 1);
        return {
            x: seg.x1 + t * (seg.x2 - seg.x1),
            y: seg.y1 + t * (seg.y2 - seg.y1)
        };
    },

    // Convert a point (x,y) to an offset along a wall segment
    getOffsetOnSegment(seg, px, py) {
        const dx = seg.x2 - seg.x1;
        const dy = seg.y2 - seg.y1;
        const len = getSegmentLength(seg);
        if (len === 0) return 0;

        // Project point onto line segment
        const t = Math.max(0, Math.min(1, ((px - seg.x1) * dx + (py - seg.y1) * dy) / (len * len)));
        return t * len;
    },

    getInteriorOffset(ws, doc) {
        let room = doc.rooms.find(r => r.id === ws.roomId);
        if (!room) room = doc.closets.find(c => c.id === ws.roomId);
        if (!room) return { x: 0, y: 0 };
        const mid = getSegmentMidpoint(ws);
        const g = room.geometry;
        const cx = g.x + g.width / 2;
        const cy = g.y + g.height / 2;
        const dx = cx - mid.x;
        const dy = cy - mid.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        return { x: (dx / dist) * 30, y: (dy / dist) * 30 };
    },

    renderDimension(dim) {
        const layer = this.layers.dims;
        const isVert = dim.vertical;
        // Overall building dimensions use exterior (blue) color
        const dimLineColor = DIM_COLOR_EXTERIOR;

        // Main dimension line
        layer.add(new Konva.Line({ points: [dim.x1, dim.y1, dim.x2, dim.y2], stroke: dimLineColor, strokeWidth: 1.5, listening: false }));

        // Extension lines (ticks)
        if (isVert) {
            layer.add(new Konva.Line({ points: [dim.x1 - 4, dim.y1, dim.x1 + 4, dim.y1], stroke: dimLineColor, strokeWidth: 1, listening: false }));
            layer.add(new Konva.Line({ points: [dim.x2 - 4, dim.y2, dim.x2 + 4, dim.y2], stroke: dimLineColor, strokeWidth: 1, listening: false }));
        } else {
            layer.add(new Konva.Line({ points: [dim.x1, dim.y1 - 4, dim.x1, dim.y1 + 4], stroke: dimLineColor, strokeWidth: 1, listening: false }));
            layer.add(new Konva.Line({ points: [dim.x2, dim.y2 - 4, dim.x2, dim.y2 + 4], stroke: dimLineColor, strokeWidth: 1, listening: false }));
        }

        const midX = (dim.x1 + dim.x2) / 2, midY = (dim.y1 + dim.y2) / 2;
        layer.add(new Konva.Text({
            x: isVert ? midX - 28 : midX - 18, y: isVert ? midY - 5 : midY - 12,
            text: dim.label, fontSize: 9, fill: dimLineColor, listening: false
        }));
    },

    // Render chain dimensions showing all room boundaries
    renderChainDimensions(doc) {
        const layer = this.layers.dims;
        const dimColor = DIM_COLOR_EXTERIOR;
        const dimOffset = 25;    // Distance for dimensions from edge
        const tickLen = 4;       // Tick mark length

        // Collect all unique X and Y coordinates from room boundaries
        const xCoords = new Set();
        const yCoords = new Set();
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        doc.rooms.forEach(room => {
            // Ensure geometry exists (compute from vertices if needed)
            let g = room.geometry;
            if (!g && room.vertices) {
                g = getGeometryFromVertices(room.vertices);
                room.geometry = g;
            }
            if (!g) return;
            xCoords.add(g.x);
            xCoords.add(g.x + g.width);
            yCoords.add(g.y);
            yCoords.add(g.y + g.height);
            minX = Math.min(minX, g.x);
            minY = Math.min(minY, g.y);
            maxX = Math.max(maxX, g.x + g.width);
            maxY = Math.max(maxY, g.y + g.height);
        });

        if (minX === Infinity) return; // No rooms

        // Sort coordinates
        const sortedX = Array.from(xCoords).sort((a, b) => a - b);
        const sortedY = Array.from(yCoords).sort((a, b) => a - b);

        // Format dimension text (feet and inches)
        const formatDim = (pixels) => {
            const totalInches = pixels / INCH;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        };

        // Helper to check if a point is inside any room
        const isInsideBuilding = (x, y) => {
            return doc.rooms.some(r => {
                const g = r.geometry;
                return x >= g.x && x <= g.x + g.width && y >= g.y && y <= g.y + g.height;
            });
        };

        // Trace the exterior outline and collect all edges
        // We'll trace clockwise starting from top-left corner
        const outline = [];

        // For each Y level, find the leftmost and rightmost X that's part of the building
        const leftEdgeByY = new Map();  // Y -> leftmost X
        const rightEdgeByY = new Map(); // Y -> rightmost X

        sortedY.forEach(y => {
            const midY = y + 0.5; // Check just below this Y line
            let leftX = Infinity, rightX = -Infinity;
            doc.rooms.forEach(r => {
                const g = r.geometry;
                if (g.y <= midY && g.y + g.height > midY) {
                    leftX = Math.min(leftX, g.x);
                    rightX = Math.max(rightX, g.x + g.width);
                }
            });
            if (leftX !== Infinity) {
                leftEdgeByY.set(y, leftX);
                rightEdgeByY.set(y, rightX);
            }
        });

        // For each X level, find the topmost and bottommost Y that's part of the building
        const topEdgeByX = new Map();    // X -> topmost Y
        const bottomEdgeByX = new Map(); // X -> bottommost Y

        sortedX.forEach(x => {
            const midX = x + 0.5; // Check just right of this X line
            let topY = Infinity, bottomY = -Infinity;
            doc.rooms.forEach(r => {
                const g = r.geometry;
                if (g.x <= midX && g.x + g.width > midX) {
                    topY = Math.min(topY, g.y);
                    bottomY = Math.max(bottomY, g.y + g.height);
                }
            });
            if (topY !== Infinity) {
                topEdgeByX.set(x, topY);
                bottomEdgeByX.set(x, bottomY);
            }
        });

        // Draw dimension for a horizontal edge
        const drawHorizDim = (x1, x2, y, side) => {
            const width = Math.abs(x2 - x1);
            if (width < FOOT / 4) return; // Skip very small segments

            const dimY = side === 'top' ? y - dimOffset : y + dimOffset;
            const midX = (x1 + x2) / 2;
            const labelY = side === 'top' ? dimY - 10 : dimY + 4;

            // Dimension line
            layer.add(new Konva.Line({
                points: [x1, dimY, x2, dimY],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Tick marks
            layer.add(new Konva.Line({
                points: [x1, dimY - tickLen, x1, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            layer.add(new Konva.Line({
                points: [x2, dimY - tickLen, x2, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Extension lines
            layer.add(new Konva.Line({
                points: [x1, y, x1, dimY],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            layer.add(new Konva.Line({
                points: [x2, y, x2, dimY],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            // Label
            if (width >= FOOT / 2) {
                layer.add(new Konva.Text({
                    x: midX - 12, y: labelY,
                    text: formatDim(width), fontSize: 8, fill: dimColor, listening: false
                }));
            }
        };

        // Draw dimension for a vertical edge
        const drawVertDim = (y1, y2, x, side) => {
            const height = Math.abs(y2 - y1);
            if (height < FOOT / 4) return; // Skip very small segments

            const dimX = side === 'left' ? x - dimOffset : x + dimOffset;
            const midY = (y1 + y2) / 2;
            const labelX = side === 'left' ? dimX - 26 : dimX + 4;

            // Dimension line
            layer.add(new Konva.Line({
                points: [dimX, y1, dimX, y2],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Tick marks
            layer.add(new Konva.Line({
                points: [dimX - tickLen, y1, dimX + tickLen, y1],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            layer.add(new Konva.Line({
                points: [dimX - tickLen, y2, dimX + tickLen, y2],
                stroke: dimColor, strokeWidth: 1, listening: false
            }));
            // Extension lines
            layer.add(new Konva.Line({
                points: [x, y1, dimX, y1],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            layer.add(new Konva.Line({
                points: [x, y2, dimX, y2],
                stroke: dimColor, strokeWidth: 0.5, dash: [2, 2], listening: false
            }));
            // Label
            if (height >= FOOT / 2) {
                layer.add(new Konva.Text({
                    x: labelX, y: midY - 4,
                    text: formatDim(height), fontSize: 8, fill: dimColor, listening: false
                }));
            }
        };

        // === TOP EDGE: trace from left to right along the top ===
        let prevTopY = null;
        let prevX = null;
        sortedX.forEach((x, i) => {
            const topY = topEdgeByX.get(x);
            if (topY !== undefined) {
                if (prevTopY !== null && prevX !== null) {
                    // Horizontal segment
                    if (prevTopY === topY) {
                        drawHorizDim(prevX, x, topY, 'top');
                    } else {
                        // There's a step - draw horizontal to the step, then vertical step
                        drawHorizDim(prevX, x, Math.min(prevTopY, topY), 'top');
                        // Draw the vertical step dimension
                        const stepHeight = Math.abs(topY - prevTopY);
                        if (stepHeight >= FOOT / 4) {
                            drawVertDim(Math.min(prevTopY, topY), Math.max(prevTopY, topY), x, 'left');
                        }
                    }
                }
                prevTopY = topY;
                prevX = x;
            }
        });

        // === BOTTOM EDGE: trace from left to right along the bottom ===
        let prevBottomY = null;
        prevX = null;
        sortedX.forEach((x, i) => {
            const bottomY = bottomEdgeByX.get(x);
            if (bottomY !== undefined) {
                if (prevBottomY !== null && prevX !== null) {
                    // Horizontal segment
                    if (prevBottomY === bottomY) {
                        drawHorizDim(prevX, x, bottomY, 'bottom');
                    } else {
                        // There's a step
                        drawHorizDim(prevX, x, Math.max(prevBottomY, bottomY), 'bottom');
                        // Draw the vertical step dimension
                        const stepHeight = Math.abs(bottomY - prevBottomY);
                        if (stepHeight >= FOOT / 4) {
                            drawVertDim(Math.min(prevBottomY, bottomY), Math.max(prevBottomY, bottomY), x, 'right');
                        }
                    }
                }
                prevBottomY = bottomY;
                prevX = x;
            }
        });

        // === LEFT EDGE: trace from top to bottom along the left ===
        let prevLeftX = null;
        let prevY = null;
        sortedY.forEach((y, i) => {
            const leftX = leftEdgeByY.get(y);
            if (leftX !== undefined) {
                if (prevLeftX !== null && prevY !== null) {
                    // Vertical segment
                    if (prevLeftX === leftX) {
                        drawVertDim(prevY, y, leftX, 'left');
                    } else {
                        // There's a step
                        drawVertDim(prevY, y, Math.min(prevLeftX, leftX), 'left');
                        // Draw the horizontal step dimension
                        const stepWidth = Math.abs(leftX - prevLeftX);
                        if (stepWidth >= FOOT / 4) {
                            drawHorizDim(Math.min(prevLeftX, leftX), Math.max(prevLeftX, leftX), y, 'top');
                        }
                    }
                }
                prevLeftX = leftX;
                prevY = y;
            }
        });

        // === RIGHT EDGE: trace from top to bottom along the right ===
        let prevRightX = null;
        prevY = null;
        sortedY.forEach((y, i) => {
            const rightX = rightEdgeByY.get(y);
            if (rightX !== undefined) {
                if (prevRightX !== null && prevY !== null) {
                    // Vertical segment
                    if (prevRightX === rightX) {
                        drawVertDim(prevY, y, rightX, 'right');
                    } else {
                        // There's a step
                        drawVertDim(prevY, y, Math.max(prevRightX, rightX), 'right');
                        // Draw the horizontal step dimension
                        const stepWidth = Math.abs(rightX - prevRightX);
                        if (stepWidth >= FOOT / 4) {
                            drawHorizDim(Math.min(prevRightX, rightX), Math.max(prevRightX, rightX), y, 'bottom');
                        }
                    }
                }
                prevRightX = rightX;
                prevY = y;
            }
        });

        // === TOTAL DIMENSIONS (outer ring) ===
        const totalOffset = 50;
        const totalW = maxX - minX;
        const totalH = maxY - minY;

        // Total width top
        layer.add(new Konva.Line({
            points: [minX, minY - totalOffset, maxX, minY - totalOffset],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX, minY - totalOffset - tickLen, minX, minY - totalOffset + tickLen],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [maxX, minY - totalOffset - tickLen, maxX, minY - totalOffset + tickLen],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Text({
            x: (minX + maxX) / 2 - 18, y: minY - totalOffset - 14,
            text: formatDim(totalW), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
        }));

        // Total height left
        layer.add(new Konva.Line({
            points: [minX - totalOffset, minY, minX - totalOffset, maxY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX - totalOffset - tickLen, minY, minX - totalOffset + tickLen, minY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Line({
            points: [minX - totalOffset - tickLen, maxY, minX - totalOffset + tickLen, maxY],
            stroke: dimColor, strokeWidth: 1.5, listening: false
        }));
        layer.add(new Konva.Text({
            x: minX - totalOffset - 36, y: (minY + maxY) / 2 - 5,
            text: formatDim(totalH), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
        }));

    },

    // Render interior room dimensions (width and height inside each room)
    renderInteriorDimensions(doc) {
        const layer = this.layers.dims;
        const dimColor = DIM_COLOR_INTERIOR;
        const dimOffset = 35;    // Distance from wall for dimension line
        const tickLen = 5;       // Tick mark length

        // Format dimension text (feet and inches)
        const formatDim = (pixels) => {
            const totalInches = pixels / INCH;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        };

        doc.rooms.forEach(room => {
            // Ensure geometry exists (compute from vertices if needed)
            let g = room.geometry;
            if (!g && room.vertices) {
                g = getGeometryFromVertices(room.vertices);
                room.geometry = g;
            }
            if (!g) return;

            // For L-shaped or complex rooms (more than 4 vertices), render wall-based dimensions
            if (room.vertices && room.vertices.length > 4) {
                this.renderComplexRoomDimensions(room, layer, dimColor, formatDim);
                return;
            }

            const w = g.width;
            const h = g.height;

            // Skip very small rooms
            if (w < FOOT * 3 || h < FOOT * 3) return;

            // === WIDTH dimension (horizontal, near bottom) ===
            const widthY = g.y + g.height - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [g.x + dimOffset, widthY, g.x + g.width - dimOffset, widthY],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Left tick
            layer.add(new Konva.Line({
                points: [g.x + dimOffset, widthY - tickLen, g.x + dimOffset, widthY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Right tick
            layer.add(new Konva.Line({
                points: [g.x + g.width - dimOffset, widthY - tickLen, g.x + g.width - dimOffset, widthY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Width label
            layer.add(new Konva.Text({
                x: g.x + g.width / 2 - 20, y: widthY - 14,
                text: formatDim(w), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
            }));

            // === HEIGHT dimension (vertical, near right) ===
            const heightX = g.x + g.width - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [heightX, g.y + dimOffset, heightX, g.y + g.height - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Top tick
            layer.add(new Konva.Line({
                points: [heightX - tickLen, g.y + dimOffset, heightX + tickLen, g.y + dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Bottom tick
            layer.add(new Konva.Line({
                points: [heightX - tickLen, g.y + g.height - dimOffset, heightX + tickLen, g.y + g.height - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Height label (rotated for vertical reading)
            layer.add(new Konva.Text({
                x: heightX - 10, y: g.y + g.height / 2 - 20,
                text: formatDim(h), fontSize: 10, fontStyle: 'bold', fill: dimColor, rotation: -90, listening: false
            }));
        });

        // Also do closets
        doc.closets.forEach(closet => {
            const g = closet.geometry;
            const w = g.width;
            const h = g.height;

            // Skip very small closets
            if (w < FOOT * 2 || h < FOOT * 2) return;

            // === WIDTH dimension (horizontal, near bottom) ===
            const widthY = g.y + g.height - 10;

            layer.add(new Konva.Line({
                points: [g.x + 8, widthY, g.x + g.width - 8, widthY],
                stroke: dimColor, strokeWidth: 0.75, listening: false, dash: [2, 2]
            }));
            layer.add(new Konva.Text({
                x: g.x + g.width / 2 - 14, y: widthY - 10,
                text: formatDim(w), fontSize: 7, fill: dimColor, listening: false
            }));

            // === HEIGHT dimension (vertical, near right) ===
            const heightX = g.x + g.width - 10;

            layer.add(new Konva.Line({
                points: [heightX, g.y + 8, heightX, g.y + g.height - 8],
                stroke: dimColor, strokeWidth: 0.75, listening: false, dash: [2, 2]
            }));
            layer.add(new Konva.Text({
                x: heightX - 6, y: g.y + g.height / 2 - 14,
                text: formatDim(h), fontSize: 7, fill: dimColor, rotation: -90, listening: false
            }));
        });
    },

    // Render dimensions for L-shaped or complex rooms (more than 4 vertices)
    renderComplexRoomDimensions(room, layer, dimColor, formatDim) {
        const vertices = room.vertices;
        if (!vertices || vertices.length < 5) return;

        const dimOffset = 15;
        const tickLen = 4;

        // Find all horizontal and vertical wall segments
        const horizontalSegments = [];
        const verticalSegments = [];

        for (let i = 0; i < vertices.length; i++) {
            const v1 = vertices[i];
            const v2 = vertices[(i + 1) % vertices.length];
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const length = Math.hypot(dx, dy);

            if (length < FOOT) continue; // Skip very short segments

            if (Math.abs(dy) < 1) {
                // Horizontal segment
                horizontalSegments.push({
                    y: v1.y,
                    x1: Math.min(v1.x, v2.x),
                    x2: Math.max(v1.x, v2.x),
                    length: Math.abs(dx)
                });
            } else if (Math.abs(dx) < 1) {
                // Vertical segment
                verticalSegments.push({
                    x: v1.x,
                    y1: Math.min(v1.y, v2.y),
                    y2: Math.max(v1.y, v2.y),
                    length: Math.abs(dy)
                });
            }
        }

        // Get bounding box for reference
        const minX = Math.min(...vertices.map(v => v.x));
        const maxX = Math.max(...vertices.map(v => v.x));
        const minY = Math.min(...vertices.map(v => v.y));
        const maxY = Math.max(...vertices.map(v => v.y));

        // Find the longest horizontal segment at or near the bottom for width display
        const bottomHorizontals = horizontalSegments
            .filter(s => Math.abs(s.y - maxY) < FOOT)
            .sort((a, b) => b.length - a.length);

        if (bottomHorizontals.length > 0) {
            const seg = bottomHorizontals[0];
            const dimY = seg.y - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [seg.x1 + dimOffset, dimY, seg.x2 - dimOffset, dimY],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Left tick
            layer.add(new Konva.Line({
                points: [seg.x1 + dimOffset, dimY - tickLen, seg.x1 + dimOffset, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Right tick
            layer.add(new Konva.Line({
                points: [seg.x2 - dimOffset, dimY - tickLen, seg.x2 - dimOffset, dimY + tickLen],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Width label
            const labelX = (seg.x1 + seg.x2) / 2 - 20;
            layer.add(new Konva.Text({
                x: labelX, y: dimY - 14,
                text: formatDim(seg.length), fontSize: 10, fontStyle: 'bold', fill: dimColor, listening: false
            }));
        }

        // Find the longest vertical segment at or near the right side for height display
        // But avoid segments that border cut-out areas
        const rightVerticals = verticalSegments
            .filter(s => Math.abs(s.x - maxX) < FOOT)
            .sort((a, b) => b.length - a.length);

        if (rightVerticals.length > 0) {
            const seg = rightVerticals[0];
            const dimX = seg.x - dimOffset;

            // Dimension line
            layer.add(new Konva.Line({
                points: [dimX, seg.y1 + dimOffset, dimX, seg.y2 - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Top tick
            layer.add(new Konva.Line({
                points: [dimX - tickLen, seg.y1 + dimOffset, dimX + tickLen, seg.y1 + dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Bottom tick
            layer.add(new Konva.Line({
                points: [dimX - tickLen, seg.y2 - dimOffset, dimX + tickLen, seg.y2 - dimOffset],
                stroke: dimColor, strokeWidth: 1.5, listening: false
            }));
            // Height label
            const labelY = (seg.y1 + seg.y2) / 2 - 20;
            layer.add(new Konva.Text({
                x: dimX - 10, y: labelY,
                text: formatDim(seg.length), fontSize: 10, fontStyle: 'bold', fill: dimColor, rotation: -90, listening: false
            }));
        }

        // For L-shaped rooms, also show the "notch" dimensions if they exist
        // Find horizontal segments NOT at top or bottom (internal ledges)
        const internalHorizontals = horizontalSegments
            .filter(s => Math.abs(s.y - minY) > FOOT && Math.abs(s.y - maxY) > FOOT)
            .sort((a, b) => b.length - a.length);

        if (internalHorizontals.length > 0 && internalHorizontals[0].length >= FOOT * 2) {
            const seg = internalHorizontals[0];
            const dimY = seg.y + dimOffset;

            // Dimension line (smaller, for the notch)
            layer.add(new Konva.Line({
                points: [seg.x1 + 5, dimY, seg.x2 - 5, dimY],
                stroke: dimColor, strokeWidth: 1, dash: [3, 2], listening: false
            }));
            // Label
            layer.add(new Konva.Text({
                x: (seg.x1 + seg.x2) / 2 - 14, y: dimY - 10,
                text: formatDim(seg.length), fontSize: 8, fill: dimColor, listening: false
            }));
        }

        // Find vertical segments NOT at left or right (internal ledges)
        const internalVerticals = verticalSegments
            .filter(s => Math.abs(s.x - minX) > FOOT && Math.abs(s.x - maxX) > FOOT)
            .sort((a, b) => b.length - a.length);

        if (internalVerticals.length > 0 && internalVerticals[0].length >= FOOT * 2) {
            const seg = internalVerticals[0];
            const dimX = seg.x + dimOffset;

            // Dimension line (smaller, for the notch)
            layer.add(new Konva.Line({
                points: [dimX, seg.y1 + 5, dimX, seg.y2 - 5],
                stroke: dimColor, strokeWidth: 1, dash: [3, 2], listening: false
            }));
            // Label
            layer.add(new Konva.Text({
                x: dimX - 6, y: (seg.y1 + seg.y2) / 2 - 14,
                text: formatDim(seg.length), fontSize: 8, fill: dimColor, rotation: -90, listening: false
            }));
        }
    },

    // Render dimension on each individual wall segment
    renderWallSegmentDimensions(doc) {
        const layer = this.layers.dims;
        const dimColor = '#059669'; // Green for wall segment dimensions

        // Format dimension text (feet and inches)
        const formatDim = (pixels) => {
            const totalInches = pixels / INCH;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        };

        doc.wallSegments.forEach(ws => {
            // Calculate wall length
            const length = Math.hypot(ws.x2 - ws.x1, ws.y2 - ws.y1);

            // Skip very short walls (less than 1 foot)
            if (length < FOOT) return;

            // Get midpoint
            const midX = (ws.x1 + ws.x2) / 2;
            const midY = (ws.y1 + ws.y2) / 2;

            // Determine if wall is more horizontal or vertical
            const dx = ws.x2 - ws.x1;
            const dy = ws.y2 - ws.y1;
            const isHorizontal = Math.abs(dx) > Math.abs(dy);

            // Position label outside the wall (away from room center)
            let labelX, labelY, rotation = 0;
            const offset = 14;

            // Find room center to determine which side is "outside"
            const room = doc.rooms.find(r => r.id === ws.roomId) || doc.closets.find(c => c.id === ws.roomId);
            const roomCenterY = room ? room.geometry.y + room.geometry.height / 2 : midY;
            const roomCenterX = room ? room.geometry.x + room.geometry.width / 2 : midX;

            if (isHorizontal) {
                // Horizontal wall - place label outside (away from room center)
                labelX = midX - 18;
                labelY = midY + (midY > roomCenterY ? offset : -offset - 8);
            } else {
                // Vertical wall - place label outside (away from room center)
                labelX = midX + (midX > roomCenterX ? offset : -offset - 8);
                labelY = midY + 18;
                rotation = -90;
            }

            // Background rect for readability
            const text = formatDim(length);
            const textWidth = text.length * 5;

            layer.add(new Konva.Rect({
                x: rotation === -90 ? labelX - 3 : labelX - 2,
                y: rotation === -90 ? labelY - textWidth - 2 : labelY - 2,
                width: rotation === -90 ? 12 : textWidth + 4,
                height: rotation === -90 ? textWidth + 4 : 12,
                fill: 'rgba(255,255,255,0.85)',
                cornerRadius: 2,
                listening: false
            }));

            // Dimension text
            layer.add(new Konva.Text({
                x: labelX,
                y: labelY,
                text: text,
                fontSize: 9,
                fontStyle: 'bold',
                fill: dimColor,
                rotation: rotation,
                listening: false
            }));
        });
    },

    select(type, id) {
        this.selection = { type, id };
        this.multiSelection = []; // Clear multi-selection when single selecting
    },

    deselect() {
        this.selection = { type: null, id: null };
        this.multiSelection = [];
        // Exit Add Point mode when deselecting
        if (App.addPointMode) {
            App.exitAddPointMode();
        }
    },

    // Add to multi-selection
    addToSelection(type, id) {
        if (!this.isInMultiSelection(type, id)) {
            this.multiSelection.push({ type, id });
        }
    },

    // Remove from multi-selection
    removeFromSelection(type, id) {
        this.multiSelection = this.multiSelection.filter(s => !(s.type === type && s.id === id));
    },

    // Check if object is in multi-selection
    isInMultiSelection(type, id) {
        return this.multiSelection.some(s => s.type === type && s.id === id);
    },

    // Check if object is selected (single or multi)
    isSelected(type, id) {
        return (this.selection.type === type && this.selection.id === id) ||
               this.isInMultiSelection(type, id);
    },

    // Select all rooms
    selectAllRooms(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = doc.rooms.map(r => ({ type: 'room', id: r.id }));
    },

    // Select all objects
    selectAll(doc) {
        this.selection = { type: null, id: null };
        this.multiSelection = [
            ...doc.rooms.map(r => ({ type: 'room', id: r.id })),
            ...doc.closets.map(c => ({ type: 'closet', id: c.id }))
        ];
    },

    getImage() { return this.stage ? this.stage.toDataURL({ pixelRatio: 2 }) : null; }
};

// ========== QA VALIDATION ==========
function runQA(doc) {
    const results = [];
    const dustWipes = doc.dustWipes || [];

    // ========== FLOOR PLAN COMPLETENESS ==========

    // All rooms labeled
    results.push({ rule: 'All rooms labeled', pass: doc.rooms.every(r => r.label), detail: 'OK' });

    // All wall segments have W1=SOUTH
    const badWalls = doc.rooms.filter(r => {
        const segs = doc.wallSegments.filter(ws => ws.roomId === r.id);
        if (segs.length < 4) return true;
        const w1 = segs.find(ws => ws.label === 'W1');
        return !w1;
    });
    results.push({ rule: 'Wall IDs (W1 exists)', pass: badWalls.length === 0, detail: badWalls.length > 0 ? `${badWalls.length} rooms` : 'OK' });

    // Closets - now a soft warning, not required
    const hasClosets = doc.closets.length > 0;
    results.push({ rule: 'Closets present', pass: hasClosets, detail: `${doc.closets.length} closet(s)`, warn: !hasClosets });

    // Doors attached to walls
    const unattachedDoors = doc.doors.filter(d => !d.parentWallSegmentId);
    results.push({ rule: 'Doors attached to walls', pass: unattachedDoors.length === 0, detail: unattachedDoors.length > 0 ? `${unattachedDoors.length} floating` : 'OK' });

    // Windows attached to walls
    const unattachedWindows = doc.windows.filter(w => !w.parentWallSegmentId);
    results.push({ rule: 'Windows attached to walls', pass: unattachedWindows.length === 0, detail: unattachedWindows.length > 0 ? `${unattachedWindows.length} floating` : 'OK' });

    // Windows must be on exterior walls only
    const windowsOnInterior = doc.windows.filter(w => {
        const ws = doc.wallSegments.find(seg => seg.id === w.parentWallSegmentId);
        return ws && ws.type !== 'exterior';
    });
    results.push({ rule: 'Windows on exterior walls', pass: windowsOnInterior.length === 0, detail: windowsOnInterior.length > 0 ? `${windowsOnInterior.length} on interior` : 'OK' });

    // MEP attached (except free-placed)
    const unattachedMEP = doc.mep.filter(m => !m.parentWallSegmentId && !m.freePlaced);
    results.push({ rule: 'MEP attached to walls', pass: unattachedMEP.length === 0, detail: unattachedMEP.length > 0 ? `${unattachedMEP.length} floating` : 'OK' });

    // ========== ENTRY & POE VALIDATION ==========

    // Entry door designated
    const entryDoor = doc.doors.find(d => d.type === 'entry');
    results.push({ rule: 'Entry door designated', pass: !!entryDoor, detail: entryDoor ? `${entryDoor.label}` : 'Mark a door as entry type' });

    // POE marker present
    const poe = doc.mep.find(m => m.label && m.label.startsWith('POE'));
    results.push({ rule: 'POE marker present', pass: !!poe, detail: poe ? 'OK' : 'Add POE marker' });

    // POE anchored to entry door
    const poeAnchored = poe && entryDoor && poe.anchorDoorId === entryDoor.id;
    results.push({ rule: 'POE anchored to entry', pass: poeAnchored || !poe, detail: !poe ? 'N/A' : (poeAnchored ? 'OK' : 'Anchor POE to entry door') });

    // ========== ROOM TYPE COVERAGE (Lead Assessment) ==========

    const roomTypes = doc.rooms.map(r => (r.type || '').toLowerCase());
    const hasKitchen = roomTypes.some(t => t.includes('kitchen'));
    const hasBathroom = roomTypes.some(t => t.includes('bath'));
    const hasBedroom = roomTypes.some(t => t.includes('bed'));

    results.push({ rule: 'Kitchen identified', pass: hasKitchen, detail: hasKitchen ? 'OK' : 'Label a room as Kitchen', warn: !hasKitchen });
    results.push({ rule: 'Bathroom identified', pass: hasBathroom, detail: hasBathroom ? 'OK' : 'Label a room as Bathroom', warn: !hasBathroom });
    results.push({ rule: 'Bedroom identified', pass: hasBedroom, detail: hasBedroom ? 'OK' : 'Label at least one Bedroom', warn: !hasBedroom });

    // Rooms with type assigned
    const roomsWithType = doc.rooms.filter(r => r.type && r.type !== 'Room');
    const unlabeledRooms = doc.rooms.length - roomsWithType.length;
    results.push({ rule: 'All rooms have type', pass: unlabeledRooms === 0, detail: unlabeledRooms === 0 ? 'OK' : `${unlabeledRooms} need type`, warn: unlabeledRooms > 0 });

    // ========== DUST WIPE SAMPLING (EPA Compliance) ==========

    // Floor sample per room
    const roomsWithFloorSamples = new Set();
    dustWipes.forEach(dw => {
        if (dw.locationType === 'floor' || dw.locationType === 'entryway') {
            if (dw.parentRoomId) roomsWithFloorSamples.add(dw.parentRoomId);
        }
    });
    const roomsMissingFloor = doc.rooms.filter(r => !roomsWithFloorSamples.has(r.id)).length;
    results.push({
        rule: 'Floor sample per room (EPA)',
        pass: roomsMissingFloor === 0 || doc.rooms.length === 0,
        detail: roomsMissingFloor === 0 ? 'OK' : `${roomsMissingFloor} rooms need floor samples`
    });

    // Window trough samples (EPA requirement)
    const windowsWithTrough = new Set();
    dustWipes.forEach(dw => {
        if (dw.locationType === 'trough' && dw.parentWindowId) {
            windowsWithTrough.add(dw.parentWindowId);
        }
    });
    const windowsMissingTrough = doc.windows.filter(w => !windowsWithTrough.has(w.id)).length;
    results.push({
        rule: 'Window trough samples (EPA)',
        pass: windowsMissingTrough === 0 || doc.windows.length === 0,
        detail: doc.windows.length === 0 ? 'No windows' : (windowsMissingTrough === 0 ? 'OK' : `${windowsMissingTrough} windows need trough samples`)
    });

    // Entry floor sample
    const hasEntrySample = dustWipes.some(dw => dw.locationType === 'entryway');
    results.push({
        rule: 'Entry floor sample (EPA)',
        pass: hasEntrySample || !entryDoor,
        detail: !entryDoor ? 'No entry door' : (hasEntrySample ? 'OK' : 'Add entryway floor sample near POE')
    });

    // Total sample count
    const minSamples = Math.max(4, doc.rooms.length + doc.windows.length);
    const totalSamples = dustWipes.length;
    results.push({
        rule: 'Adequate sample count',
        pass: totalSamples >= minSamples,
        detail: `${totalSamples} samples (min ${minSamples})`,
        warn: totalSamples < minSamples
    });

    // ========== SAMPLE NUMBERING ==========

    // Extract sample numbers and check for duplicates
    const sampleLabels = dustWipes.map(dw => dw.label);
    const duplicateLabels = sampleLabels.filter((label, idx) => sampleLabels.indexOf(label) !== idx);
    results.push({
        rule: 'No duplicate sample numbers',
        pass: duplicateLabels.length === 0,
        detail: duplicateLabels.length === 0 ? 'OK' : `Duplicates: ${[...new Set(duplicateLabels)].join(', ')}`
    });

    // Sample sheet number set
    const hasSheetNumber = doc.sampleSheetNumber && doc.sampleSheetNumber !== 'XXXXX';
    results.push({
        rule: 'Sample sheet number set',
        pass: hasSheetNumber || dustWipes.length === 0,
        detail: hasSheetNumber ? doc.sampleSheetNumber : 'Not set',
        warn: !hasSheetNumber && dustWipes.length > 0
    });

    // ========== DIMENSIONS ==========

    // Dimensions present
    const hasDimensions = doc.dimensions && doc.dimensions.length > 0;
    results.push({ rule: 'Dimensions present', pass: hasDimensions, detail: hasDimensions ? `${doc.dimensions.length}` : 'Add dimensions', warn: !hasDimensions });

    return results;
}

// ========== APP ==========
const App = {
    doc: null,
    currentTool: 'select',
    showGrid: true,
    showWallIds: true,
    showDims: true,
    undoStack: [],
    redoStack: [],
    maxHistory: 50,
    isDrawingRoom: false,
    roomDrawStart: null,
    roomPreview: null,
    isDrawingWall: false,
    wallDrawStart: null,
    wallPreview: null,
    clipboard: [],  // For copy/paste
    addPointMode: false,  // Mode to add points to room edges
    addPointRoomId: null,  // ID of room to add points to
    // Cased opening drag-to-draw
    isDrawingCased: false,
    casedDrawWall: null,
    casedDrawStart: 0,
    casedPreview: null,
    pushableSegment: null, // Legacy - kept for compatibility
    newVertexInfo: null,   // Tracks newly added vertex {roomId, vertexIdx} for special rendering
    // Partition tool state
    isDrawingPartition: false,
    partitionStart: null,      // {roomId, wallSegmentId, x, y, edge, t}
    partitionPreview: null,    // Konva Line for preview
    partitionSnapIndicator: null, // Konva Circle for snap feedback
    // Multi-floor support
    floors: {},           // Stores all floor documents: { floor1: doc, floor2: doc, ... }
    currentFloor: 'floor1',  // Currently active floor
    floorList: ['floor1'],   // Ordered list of floor IDs
    floorLabels: {
        floor1: 'Floor 1'
    },
    floorListPage: 0,        // Current page for floor dropdown pagination
    floorsPerPage: 6,        // Number of floors to show per page

    init() {
        if (!Render.init('stage')) { alert('Init failed'); return; }

        
        // Check for embedded project data (standalone HTML)
        if (window.EMBEDDED_PROJECT_DATA) {
            const data = window.EMBEDDED_PROJECT_DATA;
            this.floors = data.floors || {};
            this.floorList = data.floorList || ['floor1'];
            this.floorLabels = data.floorLabels || { floor1: 'Floor 1' };
            this.currentFloor = data.currentFloor || 'floor1';
            if (this.floors[this.currentFloor]) {
                this.doc = JSON.parse(JSON.stringify(this.floors[this.currentFloor]));
            } else {
                this.doc = Doc.create();
            }
            this.updateFloorBadge();
        } else {
            // Load saved floors from localStorage
            this.loadAllFloors();
        }

        // Load current floor or create default
        if (this.floors[this.currentFloor]) {
            this.doc = JSON.parse(JSON.stringify(this.floors[this.currentFloor]));
        } else {
            this.doc = generate2BR1BA();
            this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));
        }

        this.saveState(); // Save initial state
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateUndoRedoButtons();
        this.updateFloorBadge();
        this.setupKeyboardShortcuts();
        this.setupRoomDrawing();
        this.setupWallDrawing();
        this.setupPartitionDrawing();
        this.setupMarqueeSelection();
        this.setupFloorDropdownClose();
        console.log('App ready - tap walls to select');

        // Show sample sheet modal on startup for dust wipe labeling
        this.updateSampleSheetDisplay();
        setTimeout(() => this.showSampleSheetModal(), 500);
    },

    setupFloorDropdownClose() {
        // Close floor dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const badge = $('#floorBadge');
            const dropdown = $('#floorDropdown');
            if (badge && dropdown && !badge.contains(e.target) && !dropdown.contains(e.target)) {
                this.hideFloorDropdown();
            }
        });
    },

    updateSampleSheetDisplay() {
        const display = $('#sampleSheetDisplay');
        if (display) {
            display.textContent = this.doc.sampleSheetNumber || 'Not Set';
        }
    },

    // Convert screen position to world/canvas position (accounting for pan/zoom)
    getWorldPosition(stage) {
        const pointer = stage.getPointerPosition();
        if (!pointer) return null;
        const transform = stage.getAbsoluteTransform().copy().invert();
        return transform.point(pointer);
    },

    setupRoomDrawing() {
        const stage = Render.stage;
        const self = this;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'room') return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            this.isDrawingRoom = true;
            this.roomDrawStart = { x: snappedX, y: snappedY };

            // Create preview rectangle
            this.roomPreview = new Konva.Rect({
                x: snappedX,
                y: snappedY,
                width: 0,
                height: 0,
                fill: 'rgba(59, 130, 246, 0.1)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [5, 5]
            });
            Render.layers.openings.add(this.roomPreview);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.roomDrawStart;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            // Calculate dimensions
            const x = Math.min(start.x, snappedX);
            const y = Math.min(start.y, snappedY);
            const width = Math.abs(snappedX - start.x);
            const height = Math.abs(snappedY - start.y);

            this.roomPreview.x(x);
            this.roomPreview.y(y);
            this.roomPreview.width(width);
            this.roomPreview.height(height);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingRoom || !this.roomPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.roomDrawStart;

            // Snap to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            // Calculate final dimensions
            const x = Math.min(start.x, snappedX);
            const y = Math.min(start.y, snappedY);
            const width = Math.abs(snappedX - start.x);
            const height = Math.abs(snappedY - start.y);

            // Remove preview
            this.roomPreview.destroy();
            this.roomPreview = null;
            this.isDrawingRoom = false;

            // Check if drawing is inside an existing room (create closet) or outside (create room)
            const parentRoom = this.doc.rooms.find(room => {
                const g = room.geometry;
                // Check if the drawn rectangle is mostly inside this room
                const overlapX = Math.max(0, Math.min(x + width, g.x + g.width) - Math.max(x, g.x));
                const overlapY = Math.max(0, Math.min(y + height, g.y + g.height) - Math.max(y, g.y));
                const overlapArea = overlapX * overlapY;
                const drawnArea = width * height;
                return overlapArea > drawnArea * 0.5; // More than 50% inside room
            });

            // Different minimum sizes for closets vs rooms
            const minSize = parentRoom ? 1.5 * FOOT : 4 * FOOT;  // Closets: 1.5', Rooms: 4'
            if (width < minSize || height < minSize) {
                Render.layers.openings.batchDraw();
                return;
            }

            if (parentRoom) {
                // Create a closet by partitioning the parent room
                // This modifies the parent room's geometry to exclude the closet area
                const closetGeom = { x, y, width, height };
                const result = this.createClosetWithPartition(parentRoom, closetGeom);

                if (result.success) {
                    Render.select('closet', result.closetId);
                } else {
                    console.warn('Failed to create closet:', result.error);
                }
            } else {
                // Create a new room
                if (width < 4 * FOOT || height < 4 * FOOT) {
                    // Room needs to be at least 4x4
                    Render.layers.openings.batchDraw();
                    return;
                }
                const room = {
                    id: Doc.uid(),
                    label: Doc.label(this.doc, 'room'),
                    type: 'Room',
                    isExterior: true,
                    geometry: { x, y, width, height },
                    vertices: [  // Polygon vertices (clockwise from top-left)
                        { x: x, y: y },
                        { x: x + width, y: y },
                        { x: x + width, y: y + height },
                        { x: x, y: y + height }
                    ]
                };
                createWallSegments(room, this.doc);
                this.doc.rooms.push(room);
                markExteriorWalls(this.doc);
            }

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            this.updateInspector();
            this.setTool('select');
        });
    },

    setupWallDrawing() {
        const stage = Render.stage;
        const self = this;

        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'wall') return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Snap start point to grid
            const snappedX = snapToGrid(pos.x);
            const snappedY = snapToGrid(pos.y);

            this.isDrawingWall = true;
            this.wallDrawStart = { x: snappedX, y: snappedY };

            // Create preview line
            this.wallPreview = new Konva.Line({
                points: [snappedX, snappedY, snappedX, snappedY],
                stroke: '#2d3748',
                strokeWidth: 4,
                lineCap: 'round',
                dash: [8, 4]
            });
            Render.layers.openings.add(this.wallPreview);

            // Add start point indicator
            this.wallStartPoint = new Konva.Circle({
                x: snappedX,
                y: snappedY,
                radius: 6,
                fill: '#3b82f6'
            });
            Render.layers.openings.add(this.wallStartPoint);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.wallDrawStart;

            // Snap end point to grid
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical (whichever is dominant)
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y; // Horizontal line
            } else {
                endX = start.x; // Vertical line
            }

            this.wallPreview.points([start.x, start.y, endX, endY]);
            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingWall || !this.wallPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            const start = this.wallDrawStart;

            // Snap end point
            let endX = snapToGrid(pos.x);
            let endY = snapToGrid(pos.y);

            // Constrain to horizontal or vertical
            const dx = Math.abs(endX - start.x);
            const dy = Math.abs(endY - start.y);
            if (dx > dy) {
                endY = start.y;
            } else {
                endX = start.x;
            }

            // Remove preview
            this.wallPreview.destroy();
            this.wallPreview = null;
            if (this.wallStartPoint) {
                this.wallStartPoint.destroy();
                this.wallStartPoint = null;
            }
            this.isDrawingWall = false;

            // Minimum length check (at least 1 foot)
            const length = Math.sqrt(Math.pow(endX - start.x, 2) + Math.pow(endY - start.y, 2));
            if (length < FOOT) {
                Render.layers.openings.batchDraw();
                return;
            }

            // Create standalone wall segment
            const isHorizontal = Math.abs(endY - start.y) < 2;
            const ws = {
                id: Doc.uid(),
                roomId: null,  // Standalone wall
                roomLabel: null,
                index: 0,
                label: 'W-' + (this.doc.wallSegments.filter(w => !w.roomId).length + 1),
                side: isHorizontal ? (start.y < 400 ? 'north' : 'south') : (start.x < 400 ? 'west' : 'east'),
                x1: start.x, y1: start.y,
                x2: endX, y2: endY,
                thickness: WALL_EXT,
                type: 'exterior',
                attachedObjects: []
            };
            this.doc.wallSegments.push(ws);

            this.saveState();
            this.render();
            this.updateTree();
            this.updateQABadge();
            Render.select('wall', ws.id);
            this.updateInspector();
        });
    },

    // Marquee selection - Shift+drag to select multiple objects
    setupMarqueeSelection() {
        const self = this;
        let isSelecting = false;
        let selectionRect = null;
        let startPos = null;

        const container = document.getElementById('stage');
        if (!container) return;

        // Convert screen coords to world coords
        const screenToWorld = (clientX, clientY) => {
            const stage = Render.stage;
            const rect = container.getBoundingClientRect();
            const scaleX = stage.scaleX();
            const stageX = stage.x();
            const stageY = stage.y();
            return {
                x: (clientX - rect.left - stageX) / scaleX,
                y: (clientY - rect.top - stageY) / scaleX
            };
        };

        container.addEventListener('mousedown', (e) => {
            // Only activate with Shift key
            if (!e.shiftKey) return;
            if (this.currentTool === 'room' || this.currentTool === 'wall') return;

            e.preventDefault();
            e.stopPropagation();

            Render.stage.draggable(false);
            const pos = screenToWorld(e.clientX, e.clientY);
            isSelecting = true;
            startPos = pos;

            selectionRect = new Konva.Rect({
                x: pos.x, y: pos.y,
                width: 0, height: 0,
                fill: 'rgba(59, 130, 246, 0.2)',
                stroke: '#3b82f6',
                strokeWidth: 2,
                dash: [6, 4]
            });
            Render.layers.openings.add(selectionRect);
            Render.layers.openings.batchDraw();
        }, true);

        document.addEventListener('mousemove', (e) => {
            if (!isSelecting || !selectionRect) return;
            const pos = screenToWorld(e.clientX, e.clientY);

            const x = Math.min(startPos.x, pos.x);
            const y = Math.min(startPos.y, pos.y);
            selectionRect.x(x);
            selectionRect.y(y);
            selectionRect.width(Math.abs(pos.x - startPos.x));
            selectionRect.height(Math.abs(pos.y - startPos.y));
            Render.layers.openings.batchDraw();
        });

        document.addEventListener('mouseup', (e) => {
            if (!isSelecting || !selectionRect) return;

            const pos = screenToWorld(e.clientX, e.clientY);
            const x1 = Math.min(startPos.x, pos.x);
            const y1 = Math.min(startPos.y, pos.y);
            const x2 = Math.max(startPos.x, pos.x);
            const y2 = Math.max(startPos.y, pos.y);

            selectionRect.destroy();
            selectionRect = null;
            isSelecting = false;
            startPos = null;
            Render.stage.draggable(true);
            Render.layers.openings.batchDraw();

            // Minimum drag size
            if (x2 - x1 < 20 && y2 - y1 < 20) return;

            // Find objects in selection
            const selected = [];

            this.doc.rooms.forEach(room => {
                const g = room.geometry;
                if (this.rectIntersects(x1, y1, x2, y2, g.x, g.y, g.x + g.width, g.y + g.height)) {
                    selected.push({ type: 'room', id: room.id });
                }
            });

            this.doc.closets.forEach(closet => {
                const g = closet.geometry;
                if (this.rectIntersects(x1, y1, x2, y2, g.x, g.y, g.x + g.width, g.y + g.height)) {
                    selected.push({ type: 'closet', id: closet.id });
                }
            });

            this.doc.doors.forEach(door => {
                const ws = this.doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, door.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'door', id: door.id });
                    }
                }
            });

            this.doc.windows.forEach(win => {
                const ws = this.doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, win.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'window', id: win.id });
                    }
                }
            });

            this.doc.mep.forEach(mep => {
                const ws = this.doc.wallSegments.find(s => s.id === mep.parentWallSegmentId);
                if (ws) {
                    const p = Render.getPositionOnSegment(ws, mep.distanceFromStart);
                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                        selected.push({ type: 'mep', id: mep.id });
                    }
                }
            });

            if (selected.length > 0) {
                Render.selection = { type: null, id: null };
                Render.multiSelection = selected;
                this.render();
                console.log('Selected ' + selected.length + ' objects');
            }
        });
    },

    // Helper: check if two rectangles intersect
    rectIntersects(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
        return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
    },

    setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Undo: Ctrl+Z or Cmd+Z
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
            }
            // Redo: Ctrl+Y or Cmd+Y or Ctrl+Shift+Z
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                this.redo();
            }
            // Select All: Ctrl+A or Cmd+A
            if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                e.preventDefault();
                this.selectAll();
            }
            // Copy: Ctrl+C or Cmd+C
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                e.preventDefault();
                this.copySelected();
            }
            // Paste: Ctrl+V or Cmd+V
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                this.paste();
            }
        });
    },

    // Render preview while drawing cased opening
    renderCasedPreview() {
        if (!this.casedPreview) return;
        const preview = this.casedPreview;
        const ws = preview.ws;
        const pos = Render.getPositionOnSegment(ws, preview.start);
        const endPos = Render.getPositionOnSegment(ws, preview.start + preview.width);

        // Clear previous preview
        if (this._casedPreviewGroup) {
            this._casedPreviewGroup.destroy();
        }

        // Create preview group
        this._casedPreviewGroup = new Konva.Group();

        // Gap/clear area on wall (the empty space)
        const angle = getSegmentAngle(ws);
        const clearRect = new Konva.Rect({
            x: pos.x - 2,
            y: pos.y - 10,
            width: preview.width + 4,
            height: 20,
            fill: '#f0f7ff',
            stroke: '#06b6d4',
            strokeWidth: 2,
            dash: [4, 4],
            rotation: angle * 180 / Math.PI,
            offsetX: -2,
            offsetY: 10
        });
        // Simpler approach - just show the gap
        const previewLine = new Konva.Line({
            points: [pos.x, pos.y, endPos.x, endPos.y],
            stroke: '#06b6d4',
            strokeWidth: 4,
            dash: [8, 4],
            lineCap: 'round'
        });
        this._casedPreviewGroup.add(previewLine);

        // Width label
        const midX = (pos.x + endPos.x) / 2;
        const midY = (pos.y + endPos.y) / 2;
        const widthInches = preview.width / INCH;
        const feet = Math.floor(widthInches / 12);
        const inches = Math.round(widthInches % 12);
        const label = feet > 0 ? `${feet}'-${inches}"` : `${inches}"`;
        const widthLabel = new Konva.Text({
            x: midX - 15,
            y: midY - 20,
            text: label,
            fontSize: 12,
            fontStyle: 'bold',
            fill: '#06b6d4'
        });
        this._casedPreviewGroup.add(widthLabel);

        Render.layers.openings.add(this._casedPreviewGroup);
        Render.layers.openings.batchDraw();
    },

    saveState() {
        // Deep clone current document state
        const state = JSON.stringify(this.doc);
        this.undoStack.push(state);
        // Limit history size
        if (this.undoStack.length > this.maxHistory) {
            this.undoStack.shift();
        }
        // Clear redo stack when new action is performed
        this.redoStack = [];
        this.updateUndoRedoButtons();

        // Save all floors to localStorage
        this.saveAllFloors();
    },

    undo() {
        if (this.undoStack.length <= 1) return; // Keep at least initial state
        // Move current state to redo stack
        const currentState = this.undoStack.pop();
        this.redoStack.push(currentState);
        // Restore previous state
        const prevState = this.undoStack[this.undoStack.length - 1];
        this.doc = JSON.parse(prevState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    redo() {
        if (this.redoStack.length === 0) return;
        // Pop from redo and push to undo
        const nextState = this.redoStack.pop();
        this.undoStack.push(nextState);
        // Restore the state
        this.doc = JSON.parse(nextState);
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateInspector();
        this.updateQABadge();
        this.updateUndoRedoButtons();
    },

    updateUndoRedoButtons() {
        const undoBtn = $('#btnUndo');
        const redoBtn = $('#btnRedo');
        if (undoBtn) {
            undoBtn.disabled = this.undoStack.length <= 1;
            undoBtn.style.opacity = this.undoStack.length <= 1 ? '0.4' : '1';
        }
        if (redoBtn) {
            redoBtn.disabled = this.redoStack.length === 0;
            redoBtn.style.opacity = this.redoStack.length === 0 ? '0.4' : '1';
        }
    },

    newDoc() {
        // Create an empty document for current floor
        this.doc = Doc.create();
        this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    newAllFloors() {
        // Reset all floors - start completely fresh
        this.floors = {};
        this.currentFloor = 'floor1';
        this.doc = Doc.create();
        this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
        this.updateFloorBadge();
    },

    loadDemo() {
        // Load the 2BR/1BA demo layout
        this.doc = generate2BR1BA();
        this.undoStack = [];
        this.redoStack = [];
        this.saveState();
        Render.deselect();
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateInspector();
        this.updateUndoRedoButtons();
    },

    render() {
        Render.render(this.doc, { showWallIds: this.showWallIds, showDims: this.showDims });
    },

    onWallTap(wallSegmentId, clickPos) {
        const ws = this.doc.wallSegments.find(s => s.id === wallSegmentId);
        if (!ws) return;

        // Add Point mode - add a pushable segment to the room or closet
        if (this.addPointMode && this.addPointRoomId) {
            // Check both rooms and closets
            let item = this.doc.rooms.find(r => r.id === this.addPointRoomId);
            if (!item) {
                item = this.doc.closets.find(c => c.id === this.addPointRoomId);
            }
            if (item && ws.roomId === item.id) {
                // Find which edge this wall corresponds to
                const edges = getWallEdgesFromVertices(item);
                const edge = edges.find(e => e.label === ws.label);

                if (edge && clickPos) {
                    // Add a pushable segment (2 vertices) centered on click position
                    this.addPushableSegment(item, edge, clickPos);
                    // Exit add point mode after adding
                    this.exitAddPointMode();
                    return;
                }
            }
        }

        if (this.currentTool === 'select') {
            Render.select('wall', wallSegmentId);
            this.render();
            this.updateInspector();
            this.highlightTreeItem('wall', wallSegmentId);
        } else if (['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe', 'wallbreak'].includes(this.currentTool)) {
            this.placeOnWall(ws, this.currentTool, clickPos);
        } else if (this.currentTool === 'dustwipe') {
            this.placeDustWipe(ws, clickPos);
        }
        // Note: partition tool is handled via mousedown in setupPartitionDrawing
    },

    onObjectTap(type, id) {
        // Toggle selection: deselect if already selected
        if (Render.selection.type === type && Render.selection.id === id) {
            Render.deselect();
        } else {
            Render.select(type, id);
        }
        this.render();
        this.updateInspector();
        this.highlightTreeItem(type, id);
    },

    onRoomTap(roomId, clickPos) {
        if (this.currentTool === 'select') {
            // Exit Add Point mode if selecting a different room
            if (this.addPointMode && this.addPointRoomId !== roomId) {
                this.exitAddPointMode();
            }
            Render.select('room', roomId);
            this.render();
            this.updateInspector();
        } else if (this.currentTool === 'dustwipe' && clickPos) {
            // Place floor sample at click position
            this.showFloorSampleModal(clickPos.x, clickPos.y, roomId);
        }
    },

    placeOnWall(ws, toolType, clickPos) {
        // Find parent room OR closet (closets are rooms too)
        let room = this.doc.rooms.find(r => r.id === ws.roomId);
        if (!room) {
            room = this.doc.closets.find(c => c.id === ws.roomId);
        }
        const segLen = getSegmentLength(ws);
        const defaultOffset = segLen * 0.3;

        let obj;
        switch (toolType) {
            case 'door':
                // Use selected door type from the selector
                const doorType = this.selectedDoorType || 'regular';
                const doorConfigs = {
                    'regular':       { width: 2.67 * FOOT, swing: 'in', swingDir: 'left' },
                    'double':        { width: 5 * FOOT, swing: 'in', swingDir: 'both' },
                    'sliding':       { width: 6 * FOOT, swing: 'none', swingDir: 'none' },
                    'bifold':        { width: 3 * FOOT, swing: 'none', swingDir: 'none' },
                    'bifold-double': { width: 6 * FOOT, swing: 'none', swingDir: 'none' },
                    'pocket':        { width: 3 * FOOT, swing: 'none', swingDir: 'left' },
                    'overhead':      { width: 8 * FOOT, swing: 'none', swingDir: 'none' },
                    'elevator':      { width: 4 * FOOT, swing: 'none', swingDir: 'none' },
                    'revolving':     { width: 6 * FOOT, swing: 'none', swingDir: 'none' }
                };
                const config = doorConfigs[doorType] || doorConfigs['regular'];
                // Use click position if available
                var doorOffset = defaultOffset;
                if (clickPos) {
                    doorOffset = Render.getOffsetOnSegment(ws, clickPos.x, clickPos.y);
                }
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'door'), type: doorType,
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: doorOffset, width: config.width,
                    swing: config.swing, swingDir: config.swingDir
                };
                this.doc.doors.push(obj);
                break;
            case 'window':
                // Use click position if available
                var winOffset = defaultOffset;
                if (clickPos) {
                    winOffset = Render.getOffsetOnSegment(ws, clickPos.x, clickPos.y);
                }
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'window'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    distanceFromStart: winOffset, width: 4 * FOOT, sillHeight: 36 * INCH
                };
                this.doc.windows.push(obj);
                break;
            case 'cased':
                // Start drag-to-draw mode for cased opening
                if (clickPos) {
                    this.isDrawingCased = true;
                    this.casedDrawWall = ws;
                    this.casedDrawStart = Render.getOffsetOnSegment(ws, clickPos.x, clickPos.y);
                    // Create preview
                    this.casedPreview = { ws: ws, start: this.casedDrawStart, width: 0 };
                    Render.stage.draggable(false);
                }
                return; // Don't place yet, wait for drag
            case 'wallbreak':
                // Add bendable vertex segment (no gap, just a pushable point)
                if (room && clickPos) {
                    const edges = getWallEdgesFromVertices(room);
                    const edge = edges.find(e => e.label === ws.label);
                    if (edge) {
                        this.addPushableSegment(room, edge, clickPos);
                    }
                }
                // No object created, just vertices added
                this.saveState();
                this.render();
                this.updateTree();
                this.setTool('select');
                return;  // Early return since no obj to process
            case 'pipe':
                // Calculate initial position with interior offset
                var pipePos = Render.getPositionOnSegment(ws, defaultOffset);
                var pipeOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'pipe'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: pipePos.x + pipeOffset.x * 0.5,
                    y: pipePos.y + pipeOffset.y * 0.5
                };
                this.doc.mep.push(obj);
                break;
            case 'gas':
                var gasPos = Render.getPositionOnSegment(ws, defaultOffset);
                var gasOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'gas'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: gasPos.x + gasOffset.x * 0.5,
                    y: gasPos.y + gasOffset.y * 0.5
                };
                this.doc.mep.push(obj);
                break;
            case 'radiator':
                var radPos = Render.getPositionOnSegment(ws, defaultOffset);
                var radOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'radiator'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: radPos.x + radOffset.x * 0.5,
                    y: radPos.y + radOffset.y * 0.5,
                    width: 4 * FOOT, height: 1 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'riser':
                var riserPos = Render.getPositionOnSegment(ws, defaultOffset);
                var riserOffset = Render.getInteriorOffset(ws, this.doc);
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'riser'),
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    x: riserPos.x + riserOffset.x * 0.5,
                    y: riserPos.y + riserOffset.y * 0.5,
                    width: 0.5 * FOOT, height: 0.5 * FOOT, side: 'interior'
                };
                this.doc.mep.push(obj);
                break;
            case 'poe':
                // Find any door on this wall to anchor POE to
                var anchorDoor = this.doc.doors.find(d => d.parentWallSegmentId === ws.id);
                var poePos;
                if (anchorDoor) {
                    // Position POE at the anchor door
                    poePos = Render.getPositionOnSegment(ws, anchorDoor.distanceFromStart + anchorDoor.width / 2);
                } else {
                    poePos = Render.getPositionOnSegment(ws, defaultOffset);
                }
                obj = {
                    id: Doc.uid(), label: Doc.label(this.doc, 'poe'), type: 'entry',
                    parentWallSegmentId: ws.id, parentRoomId: ws.roomId,
                    anchorDoorId: anchorDoor ? anchorDoor.id : null,
                    x: poePos.x,
                    y: poePos.y
                };
                this.doc.mep.push(obj);
                break;
        }

        if (obj) {
            ws.attachedObjects.push({ type: toolType, id: obj.id, label: obj.label });
            Render.select(toolType === 'door' || toolType === 'window' || toolType === 'cased' ? toolType : 'mep', obj.id);
            this.saveState();
            this.render();
            this.updateTree();
            this.updateInspector();
            this.updateQABadge();
            this.setTool('select');
        }
    },

    // Check if stage should be draggable based on current tool
    shouldStageBeDraggable() {
        const drawingTools = ['room', 'wall'];
        return !drawingTools.includes(this.currentTool);
    },

    // Restore stage draggable state based on current tool (call after drag operations)
    restoreStageDraggable() {
        if (Render.stage) {
            Render.stage.draggable(this.shouldStageBeDraggable());
        }
    },

    setTool(tool) {
        this.currentTool = tool;
        $$('.tool-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.tool-btn[onclick*="'${tool}'"]`);
        if (btn) btn.classList.add('active');
        $('#btnSelect').classList.toggle('active', tool === 'select');

        // Update stage dragging based on tool
        this.restoreStageDraggable();

        // Show hint for placement tools
        const hint = $('#toolHint');
        const placementTools = ['door', 'window', 'cased', 'pipe', 'gas', 'radiator', 'riser', 'poe'];
        if (tool === 'room') {
            hint.textContent = 'Drag to draw room (outside) or closet (inside room)';
            hint.classList.add('show');
        } else if (tool === 'wall') {
            hint.textContent = 'Click and drag to draw wall (snaps to grid)';
            hint.classList.add('show');
        } else if (tool === 'door') {
            // Door type is set via selector, show selected type
            const typeNames = {
                'regular': 'REGULAR DOOR', 'double': 'DOUBLE DOOR', 'sliding': 'SLIDING DOOR',
                'bifold': 'BIFOLD DOOR', 'bifold-double': 'DOUBLE BIFOLD', 'pocket': 'POCKET DOOR',
                'overhead': 'OVERHEAD DOOR', 'elevator': 'ELEVATOR DOOR', 'revolving': 'REVOLVING DOOR'
            };
            hint.textContent = `Tap a wall to place ${typeNames[this.selectedDoorType] || 'DOOR'}`;
            hint.classList.add('show');
        } else if (placementTools.includes(tool)) {
            const toolNames = {
                'window': 'WINDOW', 'cased': 'CASED OPENING', 'pipe': 'PIPE',
                'gas': 'GAS LINE', 'radiator': 'RADIATOR', 'riser': 'PIPE RISER', 'poe': 'POINT OF ENTRY'
            };
            hint.textContent = `Tap a wall to place ${toolNames[tool] || tool.toUpperCase()}`;
            hint.classList.add('show');
        } else if (tool === 'dustwipe') {
            hint.textContent = 'Tap floor, wall, door, or window to place SAMPLE marker';
            hint.classList.add('show');
        } else if (tool === 'wallbreak') {
            hint.textContent = 'Tap a wall to create a break/gap';
            hint.classList.add('show');
        } else if (tool === 'partition') {
            hint.textContent = 'Click a wall to start partition, drag to opposite wall';
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }
    },

    updateInspector() {
        // Update delete button state based on selection
        const sel = Render.selection;
        const deleteBtn = $('#deleteBtn');
        const deletableTypes = ['room', 'door', 'window', 'cased', 'closet', 'mep', 'dustwipe'];

        // Also allow deleting standalone walls (walls without roomId)
        let canDelete = sel.type && sel.id && deletableTypes.includes(sel.type);
        if (sel.type === 'wall' && sel.id) {
            const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
            if (wall && !wall.roomId) {
                canDelete = true;  // Standalone wall can be deleted
            }
        }

        if (deleteBtn) {
            deleteBtn.disabled = !canDelete;
            deleteBtn.style.opacity = canDelete ? '1' : '0.4';
            deleteBtn.style.background = canDelete ? 'var(--accent-red)' : '';
            deleteBtn.style.color = canDelete ? 'white' : '';
        }

        // Update straighten button - enabled when a wall is selected and room has >4 vertices
        const straightenBtn = $('#straightenBtn');
        let canStraighten = false;
        if (sel.type === 'wall' && sel.id) {
            const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
            if (wall && wall.roomId) {
                const room = this.doc.rooms.find(r => r.id === wall.roomId) ||
                             this.doc.closets.find(c => c.id === wall.roomId);
                if (room && room.vertices && room.vertices.length > 4) {
                    canStraighten = true;
                }
            }
        }
        if (straightenBtn) {
            straightenBtn.disabled = !canStraighten;
            straightenBtn.style.opacity = canStraighten ? '1' : '0.4';
            straightenBtn.style.background = canStraighten ? 'var(--accent-blue)' : '';
            straightenBtn.style.color = canStraighten ? 'white' : '';
        }

        // Show/hide room type section based on room OR closet selection
        const roomTypeSection = $('#roomTypeSection');
        const roomTypeSelect = $('#roomTypeSelect');
        const wallStartSelect = $('#wallStartSelect');
        if (roomTypeSection && roomTypeSelect) {
            // Check for room or closet selection
            let selectedItem = null;
            if (sel.type === 'room' && sel.id) {
                selectedItem = this.doc.rooms.find(r => r.id === sel.id);
            } else if (sel.type === 'closet' && sel.id) {
                selectedItem = this.doc.closets.find(c => c.id === sel.id);
            }

            if (selectedItem) {
                roomTypeSection.style.display = 'block';
                roomTypeSelect.value = selectedItem.type || 'Room';

                // Populate wall dropdown with walls for this room/closet
                if (wallStartSelect) {
                    const walls = this.doc.wallSegments
                        .filter(ws => ws.roomId === selectedItem.id)
                        .sort((a, b) => a.index - b.index);

                    wallStartSelect.innerHTML = '<option value="">-- Select wall --</option>';
                    walls.forEach(w => {
                        const opt = document.createElement('option');
                        opt.value = w.label;
                        opt.textContent = w.label + ' (' + w.side + ')';
                        wallStartSelect.appendChild(opt);
                    });
                }
            } else {
                roomTypeSection.style.display = 'none';
            }
        }

        // Show/hide wall section based on wall selection
        const wallSection = $('#wallSection');
        const selectedWallLabel = $('#selectedWallLabel');
        if (wallSection) {
            if (sel.type === 'wall' && sel.id) {
                const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
                if (wall && wall.roomId) {
                    wallSection.style.display = 'block';
                    if (selectedWallLabel) {
                        selectedWallLabel.textContent = wall.label;
                    }
                } else {
                    wallSection.style.display = 'none';
                }
            } else {
                wallSection.style.display = 'none';
            }
        }
    },

    deleteSelected() {
        const sel = Render.selection;
        if (sel.type && sel.id) {
            this.deleteObject(sel.id, sel.type);
        }
    },

    // Straighten a wall by removing intermediate vertices
    straightenWall() {
        const sel = Render.selection;
        if (sel.type !== 'wall' || !sel.id) return;

        const wall = this.doc.wallSegments.find(ws => ws.id === sel.id);
        if (!wall || !wall.roomId) return;

        // Find the room or closet
        let room = this.doc.rooms.find(r => r.id === wall.roomId);
        if (!room) room = this.doc.closets.find(c => c.id === wall.roomId);
        if (!room || !room.vertices || room.vertices.length <= 4) return;

        // Find the edge index of the selected wall
        const edges = getWallEdgesFromVertices(room);
        let selectedEdgeIdx = -1;
        for (let i = 0; i < edges.length; i++) {
            const e = edges[i];
            if (Math.abs(e.start.x - wall.x1) < 1 && Math.abs(e.start.y - wall.y1) < 1 &&
                Math.abs(e.end.x - wall.x2) < 1 && Math.abs(e.end.y - wall.y2) < 1) {
                selectedEdgeIdx = i;
                break;
            }
        }
        if (selectedEdgeIdx === -1) return;

        // Find contiguous run of edges that form a bent wall
        // Walk backwards and forwards to find edges that share vertices
        const n = edges.length;
        let startIdx = selectedEdgeIdx;
        let endIdx = selectedEdgeIdx;

        // Walk backwards - find where the wall run starts
        while (true) {
            const prevIdx = (startIdx - 1 + n) % n;
            if (prevIdx === endIdx) break; // Full loop
            const prevEdge = edges[prevIdx];
            const currEdge = edges[startIdx];
            // Check if they're part of a jog (short perpendicular segment)
            const prevLen = Math.hypot(prevEdge.end.x - prevEdge.start.x, prevEdge.end.y - prevEdge.start.y);
            if (prevLen < 100 && prevEdge.side !== currEdge.side) { // Short perpendicular jog
                startIdx = prevIdx;
            } else {
                break;
            }
        }

        // Walk forwards - find where the wall run ends
        while (true) {
            const nextIdx = (endIdx + 1) % n;
            if (nextIdx === startIdx) break; // Full loop
            const nextEdge = edges[nextIdx];
            const currEdge = edges[endIdx];
            // Check if they're part of a jog
            const nextLen = Math.hypot(nextEdge.end.x - nextEdge.start.x, nextEdge.end.y - nextEdge.start.y);
            if (nextLen < 100 && nextEdge.side !== currEdge.side) { // Short perpendicular jog
                endIdx = nextIdx;
            } else {
                break;
            }
        }

        // Collect vertex indices to keep (first and last of the run)
        // The run goes from edges[startIdx].start to edges[endIdx].end
        const startVertex = edges[startIdx].start;
        const endVertex = edges[endIdx].end;

        // Find all intermediate vertex indices to remove
        const indicesToRemove = [];
        let idx = startIdx;
        while (idx !== endIdx) {
            const nextIdx = (idx + 1) % n;
            // The end vertex of edge[idx] is an intermediate vertex
            for (let i = 0; i < room.vertices.length; i++) {
                const v = room.vertices[i];
                if (Math.abs(v.x - edges[idx].end.x) < 1 && Math.abs(v.y - edges[idx].end.y) < 1) {
                    if (!indicesToRemove.includes(i)) indicesToRemove.push(i);
                    break;
                }
            }
            idx = nextIdx;
        }

        if (indicesToRemove.length === 0) return;

        // Remove vertices (sort descending to preserve indices)
        indicesToRemove.sort((a, b) => b - a);
        indicesToRemove.forEach(i => {
            room.vertices.splice(i, 1);
        });

        // Update geometry and regenerate walls
        room.geometry = getGeometryFromVertices(room.vertices);
        regenerateWallSegments(room, this.doc);
        markExteriorWalls(this.doc);

        this.saveState();
        this.render();
        this.updateTree();
        Render.deselect();
    },

    // Rotate selected object by 90 degrees (rooms and radiators only)
    rotateSelected() {
        const sel = Render.selection;
        if (!sel.type || !sel.id) return;

        if (sel.type === 'room') {
            // Rooms: rotate 90 degrees (swap width/height)
            const room = this.doc.rooms.find(r => r.id === sel.id);
            if (room) {
                const g = room.geometry;
                const oldW = g.width;
                const oldH = g.height;
                // Swap dimensions
                g.width = oldH;
                g.height = oldW;
                // Recreate wall segments for new dimensions
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    if (ws.label === 'W1') { ws.x1 = g.x; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y + g.height; }
                    if (ws.label === 'W2') { ws.x1 = g.x + g.width; ws.y1 = g.y + g.height; ws.x2 = g.x + g.width; ws.y2 = g.y; }
                    if (ws.label === 'W3') { ws.x1 = g.x + g.width; ws.y1 = g.y; ws.x2 = g.x; ws.y2 = g.y; }
                    if (ws.label === 'W4') { ws.x1 = g.x; ws.y1 = g.y; ws.x2 = g.x; ws.y2 = g.y + g.height; }
                });
                this.saveState();
                this.render();
                this.updateTree();
            }
        } else if (sel.type === 'mep') {
            // Only radiators can rotate
            const mep = this.doc.mep.find(m => m.id === sel.id);
            if (mep && mep.label.startsWith('RAD')) {
                mep.rotation = ((mep.rotation || 0) + 90) % 360;
                this.saveState();
                this.render();
            }
        }
    },

    // Flip selected object horizontally (mirror left/right)
    flipHorizontal() {
        const sel = Render.selection;
        if (!sel.type || !sel.id) return;

        if (sel.type === 'door') {
            // Doors: flip swing direction (left <-> right)
            const door = this.doc.doors.find(d => d.id === sel.id);
            if (door) {
                door.swingDir = door.swingDir === 'left' ? 'right' : 'left';
                this.saveState();
                this.render();
            }
        } else if (sel.type === 'room' || sel.type === 'closet') {
            // Rooms/Closets: mirror vertices horizontally around center
            let item = this.doc.rooms.find(r => r.id === sel.id);
            if (!item) item = this.doc.closets.find(c => c.id === sel.id);
            if (item && item.vertices) {
                const g = item.geometry;
                const centerX = g.x + g.width / 2;
                // Mirror each vertex around center X
                item.vertices = item.vertices.map(v => ({
                    x: centerX + (centerX - v.x),
                    y: v.y
                }));
                // Regenerate wall segments
                regenerateWallSegments(item, this.doc);
                this.saveState();
                this.render();
                this.updateTree();
            }
        } else if (sel.type === 'mep') {
            // Radiators: flip rotation horizontally
            const mep = this.doc.mep.find(m => m.id === sel.id);
            if (mep && mep.label.startsWith('RAD')) {
                // Flip by mirroring rotation angle
                mep.rotation = (360 - (mep.rotation || 0)) % 360;
                this.saveState();
                this.render();
            }
        }
    },

    // Flip selected object vertically (mirror up/down)
    flipVertical() {
        const sel = Render.selection;
        if (!sel.type || !sel.id) return;

        if (sel.type === 'door') {
            // Doors: flip swing in/out
            const door = this.doc.doors.find(d => d.id === sel.id);
            if (door) {
                door.swing = door.swing === 'in' ? 'out' : 'in';
                this.saveState();
                this.render();
            }
        } else if (sel.type === 'room' || sel.type === 'closet') {
            // Rooms/Closets: mirror vertices vertically around center
            let item = this.doc.rooms.find(r => r.id === sel.id);
            if (!item) item = this.doc.closets.find(c => c.id === sel.id);
            if (item && item.vertices) {
                const g = item.geometry;
                const centerY = g.y + g.height / 2;
                // Mirror each vertex around center Y
                item.vertices = item.vertices.map(v => ({
                    x: v.x,
                    y: centerY + (centerY - v.y)
                }));
                // Regenerate wall segments
                regenerateWallSegments(item, this.doc);
                this.saveState();
                this.render();
                this.updateTree();
            }
        } else if (sel.type === 'mep') {
            // Radiators: flip rotation vertically
            const mep = this.doc.mep.find(m => m.id === sel.id);
            if (mep && mep.label.startsWith('RAD')) {
                // Flip by mirroring rotation angle vertically
                mep.rotation = (180 - (mep.rotation || 0) + 360) % 360;
                this.saveState();
                this.render();
            }
        }
    },

    // Change room type (works for both rooms and closets)
    changeRoomType(newType) {
        const sel = Render.selection;
        if ((sel.type !== 'room' && sel.type !== 'closet') || !sel.id) return;

        // Find in rooms or closets
        let item = this.doc.rooms.find(r => r.id === sel.id);
        if (!item) {
            item = this.doc.closets.find(c => c.id === sel.id);
        }
        if (!item) return;

        item.type = newType;
        this.saveState();
        this.render();
        this.updateTree();
    },

    // Toggle Edit Path mode for vertex editing (works for rooms and closets)
    toggleEditPath() {
        const sel = Render.selection;
        if ((sel.type !== 'room' && sel.type !== 'closet') || !sel.id) {
            return;
        }

        this.addPointMode = !this.addPointMode;
        this.addPointRoomId = this.addPointMode ? sel.id : null;

        // Update button state
        const btn = $('#addPointBtn');
        const label = $('#addPointLabel');
        if (btn) {
            btn.classList.toggle('active', this.addPointMode);
        }
        if (label) {
            label.textContent = this.addPointMode ? 'Click Wall' : 'Add Point';
        }

        // Show hint
        const hint = $('#toolHint');
        if (this.addPointMode) {
            hint.textContent = 'Click on any wall to add a point. Then drag the point to reshape.';
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }

        this.render();
    },

    // Toggle Add Point mode (alias for toggleEditPath for button compatibility)
    toggleAddPointMode() {
        this.toggleEditPath();
    },

    // Toggle Add Joint mode - click on a wall to add a draggable joint
    toggleAddJointMode() {
        const sel = Render.selection;
        if ((sel.type !== 'room' && sel.type !== 'closet') || !sel.id) {
            const hint = $('#toolHint');
            hint.textContent = 'Select a room or closet first, then click Add Joint';
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 2000);
            return;
        }

        this.addPointMode = !this.addPointMode;
        this.addPointRoomId = this.addPointMode ? sel.id : null;

        // Update button state
        const btn = $('#addJointBtn');
        const label = $('#addJointLabel');
        if (btn) {
            btn.classList.toggle('active', this.addPointMode);
            btn.style.background = this.addPointMode ? '#22c55e' : '';
            btn.style.color = this.addPointMode ? 'white' : '';
        }
        if (label) {
            label.textContent = this.addPointMode ? 'Click a Wall' : 'Add Joint';
        }

        // Show hint
        const hint = $('#toolHint');
        if (this.addPointMode) {
            hint.textContent = 'Click on any wall to add a joint. Then drag to create an indent or pocket.';
            hint.classList.add('show');
        } else {
            hint.classList.remove('show');
        }

        this.render();
    },

    // Exit Add Point/Joint mode
    exitAddPointMode() {
        if (this.addPointMode) {
            this.addPointMode = false;
            this.addPointRoomId = null;
            // Handle both old and new button IDs
            const btn = $('#addPointBtn') || $('#addJointBtn');
            const label = $('#addPointLabel') || $('#addJointLabel');
            const jointBtn = $('#addJointBtn');
            const jointLabel = $('#addJointLabel');
            if (btn) btn.classList.remove('active');
            if (label) label.textContent = 'Add Point';
            if (jointBtn) {
                jointBtn.classList.remove('active');
                jointBtn.style.background = '';
                jointBtn.style.color = '';
            }
            if (jointLabel) jointLabel.textContent = 'Add Joint';
            $('#toolHint').classList.remove('show');
        }
    },

    // Sync geometry from vertices (after vertex editing)
    syncGeometryFromVertices(room) {
        const g = getGeometryFromVertices(room.vertices);
        if (g) room.geometry = g;
    },

    // Create notch on edge when mid-edge handle is dragged
    createNotchOnEdge(room, edgeIdx, dragDx, dragDy) {
        const verts = room.vertices;
        const n = verts.length;
        const v1 = verts[edgeIdx];
        const v2 = verts[(edgeIdx + 1) % n];

        // Determine edge direction
        const edgeDx = v2.x - v1.x;
        const edgeDy = v2.y - v1.y;
        const isHorizontal = Math.abs(edgeDx) > Math.abs(edgeDy);

        // Calculate perpendicular offset (snapped to grid)
        let offset;
        if (isHorizontal) {
            offset = snapToGrid(dragDy);
            if (Math.abs(offset) < FOOT) return; // Minimum 1 foot notch
        } else {
            offset = snapToGrid(dragDx);
            if (Math.abs(offset) < FOOT) return;
        }

        // Points at 1/4 and 3/4 along edge (wider notch - easier to make H shapes)
        const p1 = { x: v1.x + edgeDx * 0.25, y: v1.y + edgeDy * 0.25 };
        const p2 = { x: v1.x + edgeDx * 0.75, y: v1.y + edgeDy * 0.75 };

        // Create 4 new vertices for the notch
        let newP1, newP1Offset, newP2Offset, newP2;
        if (isHorizontal) {
            newP1 = { x: snapToGrid(p1.x), y: v1.y };
            newP1Offset = { x: snapToGrid(p1.x), y: snapToGrid(v1.y + offset) };
            newP2Offset = { x: snapToGrid(p2.x), y: snapToGrid(v1.y + offset) };
            newP2 = { x: snapToGrid(p2.x), y: v1.y };
        } else {
            newP1 = { x: v1.x, y: snapToGrid(p1.y) };
            newP1Offset = { x: snapToGrid(v1.x + offset), y: snapToGrid(p1.y) };
            newP2Offset = { x: snapToGrid(v1.x + offset), y: snapToGrid(p2.y) };
            newP2 = { x: v1.x, y: snapToGrid(p2.y) };
        }

        // Insert vertices to create notch
        const newVerts = [];
        for (let i = 0; i < n; i++) {
            newVerts.push(verts[i]);
            if (i === edgeIdx) {
                newVerts.push(newP1, newP1Offset, newP2Offset, newP2);
            }
        }

        // Check for self-intersection before applying
        if (!polygonSelfIntersects(newVerts)) {
            room.vertices = newVerts;
            this.syncGeometryFromVertices(room);
            regenerateWallSegments(room, this.doc);
            markExteriorWalls(this.doc);
            this.saveState();
        }
    },

    // Add a vertex on an edge at the specified position (double-tap on edge)
    addVertexOnEdge(room, edgeIdx, t) {
        const verts = room.vertices;
        const n = verts.length;
        const v1 = verts[edgeIdx];
        const v2 = verts[(edgeIdx + 1) % n];

        // Calculate new vertex position
        const newVertex = {
            x: snapToGrid(v1.x + (v2.x - v1.x) * t),
            y: snapToGrid(v1.y + (v2.y - v1.y) * t)
        };

        // Insert the new vertex
        const newVerts = [];
        for (let i = 0; i < n; i++) {
            newVerts.push(verts[i]);
            if (i === edgeIdx) {
                newVerts.push(newVertex);
            }
        }

        room.vertices = newVerts;
        this.syncGeometryFromVertices(room);
        regenerateWallSegments(room, this.doc);
        markExteriorWalls(this.doc);
        this.saveState();
        this.render();
    },

    // Add a resize segment - adds 2 vertices forming a moveable segment for L/T/H shapes
    addPushableSegment(room, edge, clickPos) {
        const verts = room.vertices;
        const n = verts.length;

        // Find the actual vertex index by matching the edge start position
        let actualVertexIdx = -1;
        for (let i = 0; i < n; i++) {
            if (Math.abs(verts[i].x - edge.start.x) < 1 && Math.abs(verts[i].y - edge.start.y) < 1) {
                actualVertexIdx = i;
                break;
            }
        }

        if (actualVertexIdx < 0) {
            console.error('Could not find matching vertex for edge');
            return;
        }

        const v1 = verts[actualVertexIdx];
        const v2 = verts[(actualVertexIdx + 1) % n];

        // Calculate edge properties
        const edgeDx = v2.x - v1.x;
        const edgeDy = v2.y - v1.y;
        const edgeLen = Math.sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
        const isHorizontal = Math.abs(edgeDx) > Math.abs(edgeDy);

        // Calculate t position of click along edge
        const t = getTOnEdge({ start: v1, end: v2 }, clickPos.x, clickPos.y);

        // Create TWO vertices for a moveable segment (3 feet wide minimum)
        const segmentWidth = Math.min(3 * FOOT, edgeLen / 4);
        const halfWidth = segmentWidth / 2;
        const t1 = Math.max(0.05, t - halfWidth / edgeLen);
        const t2 = Math.min(0.95, t + halfWidth / edgeLen);

        // IMPORTANT: Only snap the coordinate that changes along the wall
        // Keep the other coordinate EXACTLY on the wall line to prevent bending
        let newV1, newV2;
        if (isHorizontal) {
            // Horizontal wall: snap X only, keep Y exactly on line
            newV1 = {
                x: snapToGrid(v1.x + edgeDx * t1),
                y: v1.y  // Keep Y exactly on line
            };
            newV2 = {
                x: snapToGrid(v1.x + edgeDx * t2),
                y: v1.y  // Keep Y exactly on line
            };
        } else {
            // Vertical wall: snap Y only, keep X exactly on line
            newV1 = {
                x: v1.x,  // Keep X exactly on line
                y: snapToGrid(v1.y + edgeDy * t1)
            };
            newV2 = {
                x: v1.x,  // Keep X exactly on line
                y: snapToGrid(v1.y + edgeDy * t2)
            };
        }

        // Insert the two new vertices after actualVertexIdx
        const newVerts = [];
        for (let i = 0; i < n; i++) {
            newVerts.push(verts[i]);
            if (i === actualVertexIdx) {
                newVerts.push(newV1, newV2);
            }
        }

        room.vertices = newVerts;

        // Track this new segment for rendering (both vertices move together)
        this.newVertexInfo = {
            roomId: room.id,
            vertexIdx1: actualVertexIdx + 1,
            vertexIdx2: actualVertexIdx + 2,
            isHorizontal: isHorizontal
        };

        this.syncGeometryFromVertices(room);
        regenerateWallSegments(room, this.doc);
        markExteriorWalls(this.doc);
        this.saveState();
        this.render();

        // Show hint about dragging
        const hint = $('#toolHint');
        hint.textContent = isHorizontal
            ? 'Drag the green handle UP or DOWN to create L/T/H shape.'
            : 'Drag the green handle LEFT or RIGHT to create L/T/H shape.';
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 4000);
    },

    // ========== PARTITION TOOL ==========
    // Find wall segment at a given point
    findWallAtPoint(pos) {
        const THRESHOLD = 15;
        let bestWall = null;
        let bestDist = THRESHOLD;

        for (const ws of this.doc.wallSegments) {
            if (!ws.roomId) continue; // Skip standalone walls

            const edge = { start: { x: ws.x1, y: ws.y1 }, end: { x: ws.x2, y: ws.y2 } };
            const t = getTOnEdge(edge, pos.x, pos.y);

            if (t < 0 || t > 1) continue;

            const proj = getPositionOnEdge(edge, t);
            const dist = Math.sqrt(Math.pow(pos.x - proj.x, 2) + Math.pow(pos.y - proj.y, 2));

            if (dist < bestDist) {
                bestDist = dist;
                bestWall = { ws, t, proj };
            }
        }

        return bestWall;
    },

    // Start drawing a partition from a wall (called from mousedown)
    startPartitionFromPoint(ws, clickPos) {
        const room = this.doc.rooms.find(r => r.id === ws.roomId);
        if (!room) {
            console.warn('Partition: No room found for wall');
            return;
        }

        // Find the edge for this wall segment
        const edges = getWallEdgesFromVertices(room);
        const edge = edges.find(e => {
            const wsForEdge = this.doc.wallSegments.find(w =>
                w.roomId === room.id &&
                Math.abs(w.x1 - e.start.x) < 1 && Math.abs(w.y1 - e.start.y) < 1 &&
                Math.abs(w.x2 - e.end.x) < 1 && Math.abs(w.y2 - e.end.y) < 1
            );
            return wsForEdge && wsForEdge.id === ws.id;
        });

        if (!edge) {
            // Fallback: create edge from wall segment coords
            const fallbackEdge = {
                start: { x: ws.x1, y: ws.y1 },
                end: { x: ws.x2, y: ws.y2 }
            };
            const t = getTOnEdge(fallbackEdge, clickPos.x, clickPos.y);
            const startPoint = getPositionOnEdge(fallbackEdge, t);

            this.partitionStart = {
                roomId: room.id,
                wallSegmentId: ws.id,
                x: startPoint.x,
                y: startPoint.y,
                edge: fallbackEdge,
                t: t
            };
        } else {
            const t = getTOnEdge(edge, clickPos.x, clickPos.y);
            const startPoint = getPositionOnEdge(edge, t);

            this.partitionStart = {
                roomId: room.id,
                wallSegmentId: ws.id,
                x: startPoint.x,
                y: startPoint.y,
                edge: edge,
                t: t
            };
        }

        this.isDrawingPartition = true;

        // Disable stage dragging during partition drawing
        Render.stage.draggable(false);

        // Create preview line
        this.partitionPreview = new Konva.Line({
            points: [this.partitionStart.x, this.partitionStart.y, this.partitionStart.x, this.partitionStart.y],
            stroke: '#22c55e',
            strokeWidth: 3,
            dash: [8, 4],
            lineCap: 'round'
        });
        Render.layers.openings.add(this.partitionPreview);

        // Create snap indicator
        this.partitionSnapIndicator = new Konva.Circle({
            x: this.partitionStart.x,
            y: this.partitionStart.y,
            radius: 8,
            fill: '#22c55e',
            stroke: 'white',
            strokeWidth: 2
        });
        Render.layers.openings.add(this.partitionSnapIndicator);
        Render.layers.openings.batchDraw();

        // Update hint
        const hint = $('#toolHint');
        hint.textContent = 'Drag to opposite wall to divide room';
        hint.classList.add('show');
    },

    // Setup partition drawing events
    setupPartitionDrawing() {
        const stage = Render.stage;
        const self = this;

        // Handle mousedown/touchstart for partition tool
        stage.on('mousedown touchstart', (e) => {
            if (this.currentTool !== 'partition') return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Find wall under cursor
            const wallInfo = this.findWallAtPoint(pos);
            if (!wallInfo) return;

            // Start partition from this wall
            e.cancelBubble = true;
            this.startPartitionFromPoint(wallInfo.ws, pos);
        });

        stage.on('mousemove touchmove', (e) => {
            if (!this.isDrawingPartition || !this.partitionPreview) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Find snap target on opposite walls
            const snapTarget = this.findPartitionSnapTarget(pos);

            if (snapTarget) {
                // Update preview to snap point
                this.partitionPreview.points([
                    this.partitionStart.x, this.partitionStart.y,
                    snapTarget.x, snapTarget.y
                ]);
                this.partitionSnapIndicator.x(snapTarget.x);
                this.partitionSnapIndicator.y(snapTarget.y);
                this.partitionSnapIndicator.fill('#22c55e');
                this.partitionSnapIndicator.visible(true);
            } else {
                // Update preview to mouse position
                this.partitionPreview.points([
                    this.partitionStart.x, this.partitionStart.y,
                    pos.x, pos.y
                ]);
                this.partitionSnapIndicator.x(pos.x);
                this.partitionSnapIndicator.y(pos.y);
                this.partitionSnapIndicator.fill('#ef4444');
                this.partitionSnapIndicator.visible(true);
            }

            Render.layers.openings.batchDraw();
        });

        stage.on('mouseup touchend', (e) => {
            if (!this.isDrawingPartition) return;

            const pos = self.getWorldPosition(stage);
            if (!pos) return;

            // Find snap target
            const snapTarget = this.findPartitionSnapTarget(pos);

            // Clean up preview
            if (this.partitionPreview) {
                this.partitionPreview.destroy();
                this.partitionPreview = null;
            }
            if (this.partitionSnapIndicator) {
                this.partitionSnapIndicator.destroy();
                this.partitionSnapIndicator = null;
            }

            this.isDrawingPartition = false;

            // Restore stage dragging
            this.restoreStageDraggable();

            if (snapTarget && snapTarget.wallSegmentId !== this.partitionStart.wallSegmentId) {
                // Execute partition
                this.executePartition(this.partitionStart, snapTarget);
            } else {
                // Invalid partition
                const hint = $('#toolHint');
                hint.textContent = 'Partition must end on a different wall of the same room';
                hint.classList.add('show');
                setTimeout(() => hint.classList.remove('show'), 2000);
            }

            this.partitionStart = null;
            Render.layers.openings.batchDraw();
        });
    },

    // Find snap target for partition end point
    findPartitionSnapTarget(pos) {
        if (!this.partitionStart) return null;

        const room = this.doc.rooms.find(r => r.id === this.partitionStart.roomId);
        if (!room) return null;

        const SNAP_THRESHOLD = 20;
        let bestSnap = null;
        let bestDist = SNAP_THRESHOLD;

        // Check all walls of the same room (except the starting wall)
        const roomWalls = this.doc.wallSegments.filter(ws =>
            ws.roomId === this.partitionStart.roomId &&
            ws.id !== this.partitionStart.wallSegmentId
        );

        for (const ws of roomWalls) {
            const edge = { start: { x: ws.x1, y: ws.y1 }, end: { x: ws.x2, y: ws.y2 } };

            // Project point onto edge
            const edgeLen = getEdgeLength(edge);
            if (edgeLen < 1) continue;

            const t = getTOnEdge(edge, pos.x, pos.y);

            // Only snap if within the edge (not at endpoints to avoid corner issues)
            if (t < 0.05 || t > 0.95) continue;

            const projPoint = getPositionOnEdge(edge, t);
            const dist = Math.sqrt(Math.pow(pos.x - projPoint.x, 2) + Math.pow(pos.y - projPoint.y, 2));

            if (dist < bestDist) {
                bestDist = dist;
                bestSnap = {
                    wallSegmentId: ws.id,
                    roomId: ws.roomId,
                    x: projPoint.x,
                    y: projPoint.y,
                    edge: edge,
                    t: t
                };
            }
        }

        return bestSnap;
    },

    // Execute the partition - split room into two
    executePartition(startPoint, endPoint) {
        const room = this.doc.rooms.find(r => r.id === startPoint.roomId);
        if (!room || !room.vertices) {
            console.error('Partition: Room not found or has no vertices');
            return;
        }

        const verts = room.vertices;
        const n = verts.length;

        // Find which edge indices the partition intersects
        let startEdgeIdx = -1;
        let endEdgeIdx = -1;

        for (let i = 0; i < n; i++) {
            const v1 = verts[i];
            const v2 = verts[(i + 1) % n];

            // Check if start point is on this edge
            if (this.isPointOnEdge(startPoint, v1, v2)) {
                startEdgeIdx = i;
            }
            // Check if end point is on this edge
            if (this.isPointOnEdge(endPoint, v1, v2)) {
                endEdgeIdx = i;
            }
        }

        if (startEdgeIdx === -1 || endEdgeIdx === -1 || startEdgeIdx === endEdgeIdx) {
            console.error('Partition: Could not find valid edge indices', startEdgeIdx, endEdgeIdx);
            return;
        }

        // Create two new rooms from the split
        const newVerts1 = [];
        const newVerts2 = [];

        // Snap partition points to grid
        const partStart = { x: snapToGrid(startPoint.x), y: snapToGrid(startPoint.y) };
        const partEnd = { x: snapToGrid(endPoint.x), y: snapToGrid(endPoint.y) };

        // Ensure consistent ordering (startEdgeIdx < endEdgeIdx)
        if (startEdgeIdx > endEdgeIdx) {
            [startEdgeIdx, endEdgeIdx] = [endEdgeIdx, startEdgeIdx];
            [partStart.x, partStart.y, partEnd.x, partEnd.y] = [partEnd.x, partEnd.y, partStart.x, partStart.y];
        }

        // Build first polygon: from start of startEdge, through partition, to end
        // Vertices from 0 to startEdgeIdx, then partition start, partition end, then from endEdgeIdx+1 to end
        for (let i = 0; i <= startEdgeIdx; i++) {
            newVerts1.push({ ...verts[i] });
        }
        newVerts1.push({ ...partStart });
        newVerts1.push({ ...partEnd });
        for (let i = endEdgeIdx + 1; i < n; i++) {
            newVerts1.push({ ...verts[i] });
        }

        // Build second polygon: from partition end back through to partition start
        newVerts2.push({ ...partEnd });
        newVerts2.push({ ...partStart });
        for (let i = startEdgeIdx + 1; i <= endEdgeIdx; i++) {
            newVerts2.push({ ...verts[i] });
        }

        // Validate polygons have at least 3 vertices
        if (newVerts1.length < 3 || newVerts2.length < 3) {
            console.error('Partition: Invalid polygon sizes', newVerts1.length, newVerts2.length);
            return;
        }

        // Create geometry from vertices
        const geom1 = getGeometryFromVertices(newVerts1);
        const geom2 = getGeometryFromVertices(newVerts2);

        // Minimum area check
        const MIN_AREA = 2 * FOOT * 2 * FOOT;
        if (geom1.width * geom1.height < MIN_AREA || geom2.width * geom2.height < MIN_AREA) {
            const hint = $('#toolHint');
            hint.textContent = 'Partition would create room too small (min 2\'x2\')';
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 2000);
            return;
        }

        // Remove old room's wall segments
        this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== room.id);

        // Create first new room (keeps original label with 'a' suffix)
        const room1 = {
            id: Doc.uid(),
            label: room.label + 'a',
            type: room.type || 'room',
            vertices: newVerts1,
            geometry: geom1,
            isExterior: room.isExterior
        };

        // Create second new room (original label with 'b' suffix)
        const room2 = {
            id: Doc.uid(),
            label: room.label + 'b',
            type: room.type || 'room',
            vertices: newVerts2,
            geometry: geom2,
            isExterior: false // Interior partition creates interior room
        };

        // Remove old room and add new rooms
        const roomIdx = this.doc.rooms.findIndex(r => r.id === room.id);
        this.doc.rooms.splice(roomIdx, 1, room1, room2);

        // Create wall segments for new rooms
        createWallSegments(room1, this.doc);
        createWallSegments(room2, this.doc);

        // Reassign attached objects to new rooms
        this.reassignObjectsAfterPartition(room.id, room1, room2);

        // Mark exterior walls
        markExteriorWalls(this.doc);

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        const hint = $('#toolHint');
        hint.textContent = `Room divided into ${room1.label} and ${room2.label}`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 3000);

        // Return to select tool
        this.setTool('select');
    },

    // Check if a point is on an edge (within tolerance)
    isPointOnEdge(point, v1, v2, tolerance = 5) {
        const edge = { start: v1, end: v2 };
        const t = getTOnEdge(edge, point.x, point.y);
        if (t < 0 || t > 1) return false;

        const proj = getPositionOnEdge(edge, t);
        const dist = Math.sqrt(Math.pow(point.x - proj.x, 2) + Math.pow(point.y - proj.y, 2));
        return dist < tolerance;
    },

    // Reassign doors, windows, etc. to new rooms after partition
    reassignObjectsAfterPartition(oldRoomId, room1, room2) {
        // Helper to find which room a point belongs to
        const findContainingRoom = (x, y) => {
            // Check room1
            if (this.isPointInPolygon({ x, y }, room1.vertices)) {
                return room1;
            }
            // Check room2
            if (this.isPointInPolygon({ x, y }, room2.vertices)) {
                return room2;
            }
            // Fallback: check which room center is closer
            const c1 = this.getPolygonCentroid(room1.vertices);
            const c2 = this.getPolygonCentroid(room2.vertices);
            const d1 = Math.pow(x - c1.x, 2) + Math.pow(y - c1.y, 2);
            const d2 = Math.pow(x - c2.x, 2) + Math.pow(y - c2.y, 2);
            return d1 < d2 ? room1 : room2;
        };

        // Helper to find wall segment in new room that contains a point
        const findWallForPoint = (x, y, newRoom) => {
            const roomWalls = this.doc.wallSegments.filter(ws => ws.roomId === newRoom.id);
            let bestWall = null;
            let bestDist = Infinity;

            for (const ws of roomWalls) {
                const edge = { start: { x: ws.x1, y: ws.y1 }, end: { x: ws.x2, y: ws.y2 } };
                const t = getTOnEdge(edge, x, y);
                const proj = getPositionOnEdge(edge, Math.max(0, Math.min(1, t)));
                const dist = Math.sqrt(Math.pow(x - proj.x, 2) + Math.pow(y - proj.y, 2));

                if (dist < bestDist) {
                    bestDist = dist;
                    bestWall = ws;
                }
            }
            return bestWall;
        };

        // Reassign doors
        this.doc.doors.forEach(door => {
            if (door.parentRoomId === oldRoomId) {
                const newRoom = findContainingRoom(door.x || 0, door.y || 0);
                const newWall = findWallForPoint(door.x || 0, door.y || 0, newRoom);
                if (newWall) {
                    door.parentRoomId = newRoom.id;
                    door.parentWallSegmentId = newWall.id;
                }
            }
        });

        // Reassign windows
        this.doc.windows.forEach(win => {
            if (win.parentRoomId === oldRoomId) {
                const newRoom = findContainingRoom(win.x || 0, win.y || 0);
                const newWall = findWallForPoint(win.x || 0, win.y || 0, newRoom);
                if (newWall) {
                    win.parentRoomId = newRoom.id;
                    win.parentWallSegmentId = newWall.id;
                }
            }
        });

        // Reassign cased openings
        this.doc.casedOpenings.forEach(cased => {
            if (cased.parentRoomId === oldRoomId) {
                const newRoom = findContainingRoom(cased.x || 0, cased.y || 0);
                const newWall = findWallForPoint(cased.x || 0, cased.y || 0, newRoom);
                if (newWall) {
                    cased.parentRoomId = newRoom.id;
                    cased.parentWallSegmentId = newWall.id;
                }
            }
        });

        // Reassign MEP (uses x, y coordinates)
        this.doc.mep.forEach(mep => {
            if (mep.parentRoomId === oldRoomId) {
                const newRoom = findContainingRoom(mep.x, mep.y);
                mep.parentRoomId = newRoom.id;
                // Update wall if attached
                if (mep.parentWallSegmentId) {
                    const newWall = findWallForPoint(mep.x, mep.y, newRoom);
                    if (newWall) {
                        mep.parentWallSegmentId = newWall.id;
                    }
                }
            }
        });

        // Reassign dust wipes
        this.doc.dustWipes.forEach(dw => {
            if (dw.parentRoomId === oldRoomId) {
                const newRoom = findContainingRoom(dw.x, dw.y);
                dw.parentRoomId = newRoom.id;
            }
        });
    },

    // Point in polygon test (ray casting)
    isPointInPolygon(point, vertices) {
        let inside = false;
        const n = vertices.length;

        for (let i = 0, j = n - 1; i < n; j = i++) {
            const xi = vertices[i].x, yi = vertices[i].y;
            const xj = vertices[j].x, yj = vertices[j].y;

            if (((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }

        return inside;
    },

    // Get polygon centroid
    getPolygonCentroid(vertices) {
        let cx = 0, cy = 0;
        const n = vertices.length;
        for (let i = 0; i < n; i++) {
            cx += vertices[i].x;
            cy += vertices[i].y;
        }
        return { x: cx / n, y: cy / n };
    },

    // Create a closet by partitioning the parent room
    // This modifies the parent room to exclude the closet area
    createClosetWithPartition(parentRoom, closetGeom) {
        const { x, y, width, height } = closetGeom;
        const pg = parentRoom.geometry;

        // Snap closet to grid
        const cx = snapToGrid(x);
        const cy = snapToGrid(y);
        const cw = snapToGrid(width);
        const ch = snapToGrid(height);

        // Determine which edge(s) the closet touches
        const TOLERANCE = 5;
        const touchesTop = Math.abs(cy - pg.y) < TOLERANCE;
        const touchesBottom = Math.abs((cy + ch) - (pg.y + pg.height)) < TOLERANCE;
        const touchesLeft = Math.abs(cx - pg.x) < TOLERANCE;
        const touchesRight = Math.abs((cx + cw) - (pg.x + pg.width)) < TOLERANCE;

        // Count how many edges it touches
        const touchCount = [touchesTop, touchesBottom, touchesLeft, touchesRight].filter(Boolean).length;

        // For now, handle the case where closet touches exactly one or two edges (corner)
        if (touchCount === 0) {
            // Closet is floating in the middle - not supported for partitioning
            // Fall back to old behavior (overlay)
            return this.createClosetOverlay(parentRoom, closetGeom);
        }

        // Remove old wall segments for parent room
        this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== parentRoom.id);

        // Create new vertices for parent room (L-shape or similar)
        let newParentVerts = [];

        if (touchesTop && touchesLeft) {
            // Closet in top-left corner - parent becomes L-shape
            newParentVerts = [
                { x: cx + cw, y: pg.y },           // Start at closet's right edge, top
                { x: pg.x + pg.width, y: pg.y },   // Top-right of room
                { x: pg.x + pg.width, y: pg.y + pg.height }, // Bottom-right
                { x: pg.x, y: pg.y + pg.height },  // Bottom-left
                { x: pg.x, y: cy + ch },           // Up to closet's bottom
                { x: cx + cw, y: cy + ch }         // Closet's bottom-right corner
            ];
        } else if (touchesTop && touchesRight) {
            // Closet in top-right corner
            newParentVerts = [
                { x: pg.x, y: pg.y },              // Top-left
                { x: cx, y: pg.y },                // To closet's left edge
                { x: cx, y: cy + ch },             // Down to closet's bottom
                { x: pg.x + pg.width, y: cy + ch }, // Closet's bottom-right
                { x: pg.x + pg.width, y: pg.y + pg.height }, // Bottom-right
                { x: pg.x, y: pg.y + pg.height }   // Bottom-left
            ];
        } else if (touchesBottom && touchesLeft) {
            // Closet in bottom-left corner
            newParentVerts = [
                { x: pg.x, y: pg.y },              // Top-left
                { x: pg.x + pg.width, y: pg.y },   // Top-right
                { x: pg.x + pg.width, y: pg.y + pg.height }, // Bottom-right
                { x: cx + cw, y: pg.y + pg.height }, // To closet's right edge
                { x: cx + cw, y: cy },             // Up to closet's top
                { x: pg.x, y: cy }                 // Closet's top-left
            ];
        } else if (touchesBottom && touchesRight) {
            // Closet in bottom-right corner
            newParentVerts = [
                { x: pg.x, y: pg.y },              // Top-left
                { x: pg.x + pg.width, y: pg.y },   // Top-right
                { x: pg.x + pg.width, y: cy },     // Down to closet's top
                { x: cx, y: cy },                  // Closet's top-left
                { x: cx, y: pg.y + pg.height },    // Down to bottom
                { x: pg.x, y: pg.y + pg.height }   // Bottom-left
            ];
        } else if (touchesTop && !touchesLeft && !touchesRight) {
            // Closet on top edge (not corner) - creates U-shape notch
            newParentVerts = [
                { x: pg.x, y: pg.y },
                { x: cx, y: pg.y },
                { x: cx, y: cy + ch },
                { x: cx + cw, y: cy + ch },
                { x: cx + cw, y: pg.y },
                { x: pg.x + pg.width, y: pg.y },
                { x: pg.x + pg.width, y: pg.y + pg.height },
                { x: pg.x, y: pg.y + pg.height }
            ];
        } else if (touchesBottom && !touchesLeft && !touchesRight) {
            // Closet on bottom edge
            newParentVerts = [
                { x: pg.x, y: pg.y },
                { x: pg.x + pg.width, y: pg.y },
                { x: pg.x + pg.width, y: pg.y + pg.height },
                { x: cx + cw, y: pg.y + pg.height },
                { x: cx + cw, y: cy },
                { x: cx, y: cy },
                { x: cx, y: pg.y + pg.height },
                { x: pg.x, y: pg.y + pg.height }
            ];
        } else if (touchesLeft && !touchesTop && !touchesBottom) {
            // Closet on left edge
            newParentVerts = [
                { x: pg.x, y: pg.y },
                { x: pg.x + pg.width, y: pg.y },
                { x: pg.x + pg.width, y: pg.y + pg.height },
                { x: pg.x, y: pg.y + pg.height },
                { x: pg.x, y: cy + ch },
                { x: cx + cw, y: cy + ch },
                { x: cx + cw, y: cy },
                { x: pg.x, y: cy }
            ];
        } else if (touchesRight && !touchesTop && !touchesBottom) {
            // Closet on right edge
            newParentVerts = [
                { x: pg.x, y: pg.y },
                { x: pg.x + pg.width, y: pg.y },
                { x: pg.x + pg.width, y: cy },
                { x: cx, y: cy },
                { x: cx, y: cy + ch },
                { x: pg.x + pg.width, y: cy + ch },
                { x: pg.x + pg.width, y: pg.y + pg.height },
                { x: pg.x, y: pg.y + pg.height }
            ];
        } else {
            // Complex case - fall back to overlay
            return this.createClosetOverlay(parentRoom, closetGeom);
        }

        // Update parent room vertices and geometry
        parentRoom.vertices = newParentVerts;
        parentRoom.geometry = getGeometryFromVertices(newParentVerts);

        // Create wall segments for updated parent room
        createWallSegments(parentRoom, this.doc);

        // Create the closet as a separate room (not in closets array, but in rooms)
        const closetRoom = {
            id: Doc.uid(),
            label: Doc.label(this.doc, 'closet'),
            type: 'Closet',
            roomType: 'Closet',
            parentRoomId: parentRoom.id,
            parentRoomLabel: parentRoom.label,
            isExterior: false,
            geometry: { x: cx, y: cy, width: cw, height: ch },
            vertices: [
                { x: cx, y: cy },
                { x: cx + cw, y: cy },
                { x: cx + cw, y: cy + ch },
                { x: cx, y: cy + ch }
            ]
        };

        // Add closet to rooms array (not closets) so it gets proper dimensions
        this.doc.rooms.push(closetRoom);
        createWallSegments(closetRoom, this.doc);

        // Mark exterior walls
        markExteriorWalls(this.doc);

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        return { success: true, closetId: closetRoom.id };
    },

    // Fallback: create closet as overlay (old behavior)
    createClosetOverlay(parentRoom, closetGeom) {
        const { x, y, width, height } = closetGeom;

        const closet = {
            id: Doc.uid(),
            label: Doc.label(this.doc, 'closet'),
            type: 'Closet',
            roomType: 'Closet',
            parentRoomId: parentRoom.id,
            parentRoomLabel: parentRoom.label,
            isExterior: false,
            geometry: { x, y, width, height },
            vertices: [
                { x: x, y: y },
                { x: x + width, y: y },
                { x: x + width, y: y + height },
                { x: x, y: y + height }
            ]
        };

        createWallSegments(closet, this.doc);
        this.doc.closets.push(closet);

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        return { success: true, closetId: closet.id };
    },

    // Delete a vertex (double-tap on vertex, if more than 4 remain)
    deleteVertex(room, vertexIdx) {
        if (room.vertices.length <= 4) {
            const hint = $('#toolHint');
            hint.textContent = 'Cannot delete - room needs at least 4 corners';
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 2000);
            return;
        }

        room.vertices.splice(vertexIdx, 1);
        this.syncGeometryFromVertices(room);
        regenerateWallSegments(room, this.doc);
        markExteriorWalls(this.doc);
        this.saveState();
        this.render();
    },

    // Set selected wall as W1, renumber others clockwise
    setAsW1() {
        const sel = Render.selection;

        if (sel.type !== 'wall' || !sel.id) {
            alert('Please select a wall first');
            return;
        }

        const selectedWall = this.doc.wallSegments.find(ws => ws.id === sel.id);
        if (!selectedWall || !selectedWall.roomId) {
            alert('Selected wall not found');
            return;
        }

        // Get all walls for this room
        const roomWalls = this.doc.wallSegments.filter(ws => ws.roomId === selectedWall.roomId);
        if (roomWalls.length === 0) return;

        // Remember the old label for feedback
        const oldLabel = selectedWall.label;

        // Find the current index of the selected wall
        const currentIndex = selectedWall.index;

        // Renumber walls: selected becomes W1, then clockwise
        roomWalls.forEach(wall => {
            // Calculate new index: offset from selected wall's position
            let newIndex = wall.index - currentIndex + 1;
            if (newIndex <= 0) newIndex += roomWalls.length;

            wall.index = newIndex;
            wall.label = 'W' + newIndex;
        });

        // Sort walls by new index to ensure consistent order
        roomWalls.sort((a, b) => a.index - b.index);

        // Keep the wall selected after render
        const wallId = sel.id;

        this.saveState();
        this.render();

        // Re-select the wall (now W1)
        Render.select('wall', wallId);

        this.updateTree();
        this.updateInspector();
    },

    // Set wall as W1 from room/closet selection (by wall label)
    setWallAsW1(wallLabel) {
        if (!wallLabel) return;

        const sel = Render.selection;
        if ((sel.type !== 'room' && sel.type !== 'closet') || !sel.id) {
            alert('Please select a room or closet first');
            return;
        }

        // Find in rooms or closets
        let room = this.doc.rooms.find(r => r.id === sel.id);
        if (!room) {
            room = this.doc.closets.find(c => c.id === sel.id);
        }
        if (!room) return;

        // Get all walls for this room
        const roomWalls = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
        if (roomWalls.length === 0) return;

        // Find the wall by label
        const selectedWall = roomWalls.find(w => w.label === wallLabel);
        if (!selectedWall) return;

        // Find the current index of the selected wall
        const currentIndex = selectedWall.index;

        // Renumber walls: selected becomes W1, then clockwise
        roomWalls.forEach(wall => {
            let newIndex = wall.index - currentIndex + 1;
            if (newIndex <= 0) newIndex += roomWalls.length;

            wall.index = newIndex;
            wall.label = 'W' + newIndex;
        });

        // Sort walls by new index
        roomWalls.sort((a, b) => a.index - b.index);

        // Keep the room selected
        const roomId = sel.id;

        this.saveState();
        this.render();

        // Re-select the room
        Render.select('room', roomId);

        this.updateTree();
        this.updateInspector();

        // Reset the dropdown
        const wallStartSelect = $('#wallStartSelect');
        if (wallStartSelect) wallStartSelect.value = '';
    },

    deleteObject(objId, objType) {
        // Handle standalone wall deletion
        if (objType === 'wall') {
            const wall = this.doc.wallSegments.find(ws => ws.id === objId);
            if (wall && !wall.roomId) {
                // Only delete standalone walls (not part of a room)
                const index = this.doc.wallSegments.findIndex(ws => ws.id === objId);
                if (index !== -1) {
                    this.doc.wallSegments.splice(index, 1);
                    this.saveState();
                    Render.deselect();
                    this.render();
                    this.updateTree();
                    this.updateInspector();
                    this.updateQABadge();
                }
            }
            return;
        }

        // Handle room deletion
        if (objType === 'room') {
            const roomIndex = this.doc.rooms.findIndex(r => r.id === objId);
            if (roomIndex !== -1) {
                // Get all wall segments for this room
                const roomWallIds = this.doc.wallSegments
                    .filter(ws => ws.roomId === objId)
                    .map(ws => ws.id);

                // Delete all attached objects (doors, windows, cased openings, MEP)
                this.doc.doors = this.doc.doors.filter(d => !roomWallIds.includes(d.parentWallSegmentId));
                this.doc.windows = this.doc.windows.filter(w => !roomWallIds.includes(w.parentWallSegmentId));
                this.doc.casedOpenings = this.doc.casedOpenings.filter(c => !roomWallIds.includes(c.parentWallSegmentId));
                this.doc.mep = this.doc.mep.filter(m => !roomWallIds.includes(m.parentWallSegmentId));

                // Delete closets that belong to this room
                this.doc.closets = this.doc.closets.filter(c => c.parentRoomId !== objId);

                // Delete wall segments
                this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== objId);

                // Delete the room
                this.doc.rooms.splice(roomIndex, 1);

                // Recalculate exterior walls
                markExteriorWalls(this.doc);

                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
            return;
        }

        // Only allow deleting actual objects
        const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep', 'dustwipe'];
        if (!deletableTypes.includes(objType)) {
            return;  // Silently ignore non-deletable types
        }

        let collection, index;
        if (objType === 'door') {
            collection = this.doc.doors;
        } else if (objType === 'window') {
            collection = this.doc.windows;
        } else if (objType === 'cased') {
            collection = this.doc.casedOpenings;
        } else if (objType === 'closet') {
            collection = this.doc.closets;
        } else if (objType === 'mep') {
            collection = this.doc.mep;
        } else if (objType === 'dustwipe') {
            collection = this.doc.dustWipes;
        }

        if (collection) {
            index = collection.findIndex(o => o.id === objId);
            if (index !== -1) {
                const obj = collection[index];
                // Remove from wall's attachedObjects
                if (obj.parentWallSegmentId) {
                    const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
                    if (ws) {
                        ws.attachedObjects = ws.attachedObjects.filter(a => a.id !== objId);
                    }
                }
                // Remove from collection
                collection.splice(index, 1);

                // If deleting a closet, also delete its wall segments
                if (objType === 'closet') {
                    this.doc.wallSegments = this.doc.wallSegments.filter(ws => ws.roomId !== objId);
                }

                // Clear selection and save state
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateInspector();
                this.updateQABadge();
            }
        }
    },

    updateObjectWidth(objId, objType, newWidthFeet) {
        const width = parseFloat(newWidthFeet) * FOOT;
        if (isNaN(width) || width < 1 * FOOT || width > 12 * FOOT) {
            alert('Width must be between 1 and 12 feet');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            obj.width = width;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateObjectOffset(objId, objType, newOffsetFeet) {
        const offset = parseFloat(newOffsetFeet) * FOOT;
        if (isNaN(offset) || offset < 0) {
            alert('Offset must be 0 or greater');
            return;
        }

        let collection;
        if (objType === 'door') collection = this.doc.doors;
        else if (objType === 'window') collection = this.doc.windows;
        else if (objType === 'cased') collection = this.doc.casedOpenings;
        else if (objType === 'mep') collection = this.doc.mep;

        const obj = collection?.find(o => o.id === objId);
        if (obj) {
            // Validate offset doesn't exceed wall length
            const ws = this.doc.wallSegments.find(s => s.id === obj.parentWallSegmentId);
            if (ws) {
                const maxOffset = getSegmentLength(ws) - (obj.width || 0);
                if (offset > maxOffset) {
                    alert(`Offset too large. Max: ${(maxOffset / FOOT).toFixed(1)} ft`);
                    return;
                }
            }
            obj.distanceFromStart = offset;
            this.saveState();
            this.render();
            this.updateQABadge();
        }
    },

    updateTree() {
        const tree = $('#objectTree');
        tree.innerHTML = '';

        const addGroup = (title, items, color, type) => {
            if (items.length === 0) return;
            const grp = document.createElement('div');
            grp.className = 'tree-group';
            grp.innerHTML = `<div class="tree-label">${title} (${items.length})</div>`;
            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'tree-item';
                el.dataset.type = type;
                el.dataset.id = item.id;
                const ws = this.doc.wallSegments.find(s => s.id === item.parentWallSegmentId);
                const wallInfo = ws ? ` → ${ws.label}` : '';
                el.innerHTML = `<div class="tree-dot" style="background:${color}"></div><span>${item.label}${item.type ? ' (' + item.type + ')' : ''}${wallInfo}</span>`;
                el.onclick = () => this.onObjectTap(type, item.id);
                grp.appendChild(el);
            });
            tree.appendChild(grp);
        };

        // Rooms with wall segments and child closets
        if (this.doc.rooms.length > 0) {
            const roomGrp = document.createElement('div');
            roomGrp.className = 'tree-group';
            roomGrp.innerHTML = `<div class="tree-label">ROOMS (${this.doc.rooms.length})</div>`;
            this.doc.rooms.forEach(room => {
                const roomEl = document.createElement('div');
                roomEl.className = 'tree-item';
                roomEl.dataset.type = 'room';
                roomEl.dataset.id = room.id;
                roomEl.innerHTML = `<div class="tree-dot" style="background:#f4d03f"></div><span>${room.type} (${room.label})</span>`;
                roomEl.onclick = () => this.onObjectTap('room', room.id);
                roomGrp.appendChild(roomEl);

                // Wall segments under room
                const segs = this.doc.wallSegments.filter(ws => ws.roomId === room.id);
                segs.forEach(ws => {
                    const wsEl = document.createElement('div');
                    wsEl.className = 'tree-item';
                    wsEl.style.paddingLeft = '20px';
                    wsEl.dataset.type = 'wall';
                    wsEl.dataset.id = ws.id;
                    wsEl.innerHTML = `<div class="tree-dot" style="background:#666;width:6px;height:6px"></div><span>${ws.label} (${ws.side}) [${ws.attachedObjects.length}]</span>`;
                    wsEl.onclick = () => this.onWallTap(ws.id);
                    roomGrp.appendChild(wsEl);
                });

                // Child closets under room
                const childClosets = this.doc.closets.filter(c => c.parentRoomId === room.id);
                childClosets.forEach(closet => {
                    const closetEl = document.createElement('div');
                    closetEl.className = 'tree-item';
                    closetEl.style.paddingLeft = '20px';
                    closetEl.dataset.type = 'closet';
                    closetEl.dataset.id = closet.id;
                    closetEl.innerHTML = `<div class="tree-dot" style="background:#9ca3af"></div><span>↳ ${closet.label} (Closet)</span>`;
                    closetEl.onclick = () => this.onObjectTap('closet', closet.id);
                    roomGrp.appendChild(closetEl);

                    // Closet's wall segments
                    const closetSegs = this.doc.wallSegments.filter(ws => ws.roomId === closet.id);
                    closetSegs.forEach(ws => {
                        const wsEl = document.createElement('div');
                        wsEl.className = 'tree-item';
                        wsEl.style.paddingLeft = '36px';
                        wsEl.dataset.type = 'wall';
                        wsEl.dataset.id = ws.id;
                        wsEl.innerHTML = `<div class="tree-dot" style="background:#aaa;width:5px;height:5px"></div><span>${ws.label} (${ws.side})</span>`;
                        wsEl.onclick = () => this.onWallTap(ws.id);
                        roomGrp.appendChild(wsEl);
                    });
                });
            });
            tree.appendChild(roomGrp);
        }

        // Orphan closets (no parent room)
        const orphanClosets = this.doc.closets.filter(c => !c.parentRoomId || !this.doc.rooms.find(r => r.id === c.parentRoomId));
        if (orphanClosets.length > 0) {
            addGroup('UNLINKED CLOSETS', orphanClosets, '#ef4444', 'closet');
        }

        addGroup('DOORS', this.doc.doors, '#3b82f6', 'door');
        addGroup('WINDOWS', this.doc.windows, '#87ceeb', 'window');
        addGroup('OPENINGS', this.doc.casedOpenings, '#aaa', 'cased');
        addGroup('MEP', this.doc.mep, '#22c55e', 'mep');

        // Update sample list dropdown
        this.updateSampleList();
    },

    highlightTreeItem(type, id) {
        $$('.tree-item').forEach(el => el.classList.remove('selected'));
        const el = document.querySelector(`.tree-item[data-type="${type}"][data-id="${id}"]`);
        if (el) el.classList.add('selected');
    },

    toggle(what) {
        switch (what) {
            case 'grid':
                this.showGrid = !this.showGrid;
                const btnGrid = $('#btnGrid');
                if (btnGrid) btnGrid.classList.toggle('active', this.showGrid);
                // Re-render grid layer
                if (this.showGrid) {
                    Render.renderGrid();
                } else {
                    Render.layers.grid.destroyChildren();
                    Render.layers.grid.batchDraw();
                }
                break;
            case 'wallIds':
                this.showWallIds = !this.showWallIds;
                const btnWallIds = $('#btnWallIds');
                if (btnWallIds) btnWallIds.classList.toggle('active', this.showWallIds);
                this.render();
                break;
            case 'dims':
                this.showDims = !this.showDims;
                const btnDims = $('#btnDims');
                if (btnDims) btnDims.classList.toggle('active', this.showDims);
                this.render();
                break;
        }
        Render.stage.batchDraw();
    },

    toggleSidebar() { $('#sidebarLeft').classList.toggle('collapsed'); },

    northRotation: 0,
    rotateNorth() {
        this.northRotation = (this.northRotation + 45) % 360;
        const arrow = $('#compassArrow');
        if (arrow) {
            arrow.style.transform = `rotate(${this.northRotation}deg)`;
        }
    },

    // Floor management
    toggleFloorDropdown(e) {
        if (e) e.stopPropagation();
        const dropdown = $('#floorDropdown');
        if (dropdown) {
            const isShowing = dropdown.classList.toggle('show');
            if (isShowing) {
                this.floorListPage = 0;
                this.renderFloorList();
            }
        }
    },

    hideFloorDropdown() {
        const dropdown = $('#floorDropdown');
        if (dropdown) {
            dropdown.classList.remove('show');
        }
    },

    renderFloorList() {
        const container = $('#floorDropdownList');
        if (!container) return;

        const start = this.floorListPage * this.floorsPerPage;
        const end = Math.min(start + this.floorsPerPage, this.floorList.length);
        const floorsToShow = this.floorList.slice(start, end);

        container.innerHTML = floorsToShow.map(floorId => {
            const isActive = floorId === this.currentFloor;
            const label = this.floorLabels[floorId] || floorId;
            return `<div class="floor-dropdown-item${isActive ? ' active' : ''}" data-floor="${floorId}" onclick="App.switchFloor('${floorId}', event)">${label}${isActive ? ' <span class="check">✓</span>' : ''}</div>`;
        }).join('');

        // Show/hide navigation
        const nav = $('#floorDropdownNav');
        if (nav) {
            const totalPages = Math.ceil(this.floorList.length / this.floorsPerPage);
            nav.style.display = totalPages > 1 ? 'flex' : 'none';

            const prevBtn = $('#floorPrevBtn');
            const nextBtn = $('#floorNextBtn');
            if (prevBtn) prevBtn.disabled = this.floorListPage === 0;
            if (nextBtn) nextBtn.disabled = this.floorListPage >= totalPages - 1;
        }
    },

    floorListPrev() {
        if (this.floorListPage > 0) {
            this.floorListPage--;
            this.renderFloorList();
        }
    },

    floorListNext() {
        const totalPages = Math.ceil(this.floorList.length / this.floorsPerPage);
        if (this.floorListPage < totalPages - 1) {
            this.floorListPage++;
            this.renderFloorList();
        }
    },

    addNewFloor() {
        // Find next available floor number
        let nextNum = 1;
        while (this.floorLabels['floor' + nextNum]) {
            nextNum++;
        }

        const newFloorId = 'floor' + nextNum;
        const newLabel = 'Floor ' + nextNum;

        // Prompt for custom name
        const customName = prompt('Enter floor name:', newLabel);
        if (customName === null) return; // Cancelled

        const finalLabel = customName.trim() || newLabel;

        // Add to floor list and labels
        this.floorList.push(newFloorId);
        this.floorLabels[newFloorId] = finalLabel;

        // Create empty document for this floor
        this.floors[newFloorId] = Doc.create();
        this.floors[newFloorId].address = finalLabel + ' Blueprint';

        // Jump to page with new floor and switch to it
        this.floorListPage = Math.floor((this.floorList.length - 1) / this.floorsPerPage);
        this.renderFloorList();
        this.switchFloor(newFloorId);

        // Save
        this.saveAllFloors();
    },

    switchFloor(floorId, e) {
        if (e) e.stopPropagation();
        // Save current floor's document
        this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));

        // Switch to new floor
        this.currentFloor = floorId;

        // Load or create floor document
        if (this.floors[floorId]) {
            this.doc = JSON.parse(JSON.stringify(this.floors[floorId]));
        } else {
            // Create fresh document for new floor
            this.doc = Doc.create();
            this.doc.address = this.floorLabels[floorId] + ' Blueprint';
            this.floors[floorId] = JSON.parse(JSON.stringify(this.doc));
        }

        // Update UI
        this.updateFloorBadge();
        this.hideFloorDropdown();

        // Reset undo/redo for this floor
        this.undoStack = [];
        this.redoStack = [];

        // Clear selection
        Render.deselect();

        // Re-render
        this.render();
        this.updateTree();
        this.updateQABadge();
        this.updateSampleSheetDisplay();
    },

    updateFloorBadge() {
        const label = $('#floorLabel');
        if (label) {
            label.textContent = 'Location | ' + (this.floorLabels[this.currentFloor] || this.currentFloor);
        }
        // Re-render floor list if visible
        const dropdown = $('#floorDropdown');
        if (dropdown && dropdown.classList.contains('show')) {
            this.renderFloorList();
        }
    },

    // Save all floors to localStorage
    saveAllFloors() {
        // Make sure current floor is saved
        this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));

        try {
            localStorage.setItem('floorPlanFloors', JSON.stringify(this.floors));
            localStorage.setItem('floorPlanCurrentFloor', this.currentFloor);
            localStorage.setItem('floorPlanFloorList', JSON.stringify(this.floorList));
            localStorage.setItem('floorPlanFloorLabels', JSON.stringify(this.floorLabels));
        } catch (e) {
            console.warn('Could not save floors to localStorage:', e);
        }
    },

    // Load all floors from localStorage
    loadAllFloors() {
        try {
            const savedFloors = localStorage.getItem('floorPlanFloors');
            const savedCurrentFloor = localStorage.getItem('floorPlanCurrentFloor');
            const savedFloorList = localStorage.getItem('floorPlanFloorList');
            const savedFloorLabels = localStorage.getItem('floorPlanFloorLabels');

            if (savedFloors) {
                this.floors = JSON.parse(savedFloors);
            }
            if (savedFloorList) {
                this.floorList = JSON.parse(savedFloorList);
            }
            if (savedFloorLabels) {
                this.floorLabels = JSON.parse(savedFloorLabels);
            }
            if (savedCurrentFloor && this.floorList.includes(savedCurrentFloor)) {
                this.currentFloor = savedCurrentFloor;
            }
            // Ensure at least floor1 exists
            if (this.floorList.length === 0) {
                this.floorList = ['floor1'];
                this.floorLabels = { floor1: 'Floor 1' };
            }
        } catch (e) {
            console.warn('Could not load floors from localStorage:', e);
        }
    },

    toggleObjectPanel() {
        const tree = $('#objectTree');
        const toggle = $('#objectToggle');
        tree.classList.toggle('collapsed');
        toggle.textContent = tree.classList.contains('collapsed') ? '▶' : '▼';
    },

    resetView() {
        Render.stage.scale({ x: 1, y: 1 });
        Render.stage.position({ x: 0, y: 0 });
        Render.stage.batchDraw();
    },

    // Select all rooms and closets
    selectAll() {
        Render.selectAll(this.doc);
        this.render();
        this.updateInspector();
    },

    // Copy selected objects to clipboard
    copySelected() {
        this.clipboard = [];

        // Get all selected items (single or multi)
        const selected = Render.multiSelection.length > 0
            ? Render.multiSelection
            : (Render.selection.type ? [Render.selection] : []);

        if (selected.length === 0) {
            alert('Nothing selected to copy');
            return;
        }

        selected.forEach(sel => {
            if (sel.type === 'room') {
                const room = this.doc.rooms.find(r => r.id === sel.id);
                if (room) {
                    this.clipboard.push({
                        type: 'room',
                        data: JSON.parse(JSON.stringify(room))
                    });
                }
            } else if (sel.type === 'closet') {
                const closet = this.doc.closets.find(c => c.id === sel.id);
                if (closet) {
                    this.clipboard.push({
                        type: 'closet',
                        data: JSON.parse(JSON.stringify(closet))
                    });
                }
            }
        });

        const hint = $('#toolHint');
        hint.textContent = `Copied ${this.clipboard.length} item(s). Press Ctrl+V to paste.`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    // Paste from clipboard
    paste() {
        if (this.clipboard.length === 0) {
            alert('Nothing to paste');
            return;
        }

        const offset = 2 * FOOT; // Offset pasted items

        this.clipboard.forEach(item => {
            if (item.type === 'room') {
                const newRoom = JSON.parse(JSON.stringify(item.data));
                newRoom.id = Doc.uid();
                newRoom.label = Doc.label(this.doc, 'room');
                newRoom.geometry.x += offset;
                newRoom.geometry.y += offset;
                createWallSegments(newRoom, this.doc);
                this.doc.rooms.push(newRoom);
                markExteriorWalls(this.doc);
            } else if (item.type === 'closet') {
                const newCloset = JSON.parse(JSON.stringify(item.data));
                newCloset.id = Doc.uid();
                newCloset.label = Doc.label(this.doc, 'closet');
                newCloset.geometry.x += offset;
                newCloset.geometry.y += offset;
                createWallSegments(newCloset, this.doc);
                this.doc.closets.push(newCloset);
            }
        });

        this.saveState();
        this.render();
        this.updateTree();
        this.updateQABadge();

        const hint = $('#toolHint');
        hint.textContent = `Pasted ${this.clipboard.length} item(s)`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    updateQABadge() {
        const results = runQA(this.doc);
        const errors = results.filter(r => !r.pass && !r.warn).length;
        const warnings = results.filter(r => !r.pass && r.warn).length;
        const badge = $('#qaBadge');
        if (errors > 0) {
            badge.textContent = 'QA: ' + errors + ' error' + (errors > 1 ? 's' : '');
            badge.className = 'qa-badge error';
        } else if (warnings > 0) {
            badge.textContent = 'QA: ' + warnings + ' warning' + (warnings > 1 ? 's' : '');
            badge.className = 'qa-badge warning';
        } else {
            badge.textContent = 'QA: PASS';
            badge.className = 'qa-badge';
        }
    },

    showQA() {
        const results = runQA(this.doc);
        const container = $('#qaContent');
        container.textContent = '';
        results.forEach(r => {
            const item = document.createElement('div');
            item.className = 'qa-item';
            const icon = document.createElement('span');
            icon.className = r.pass ? 'qa-pass' : (r.warn ? 'qa-warn' : 'qa-fail');
            icon.textContent = r.pass ? '\u2713' : (r.warn ? '!' : '\u2717');
            const rule = document.createElement('span');
            rule.textContent = r.rule;
            const detail = document.createElement('span');
            detail.style.cssText = 'color:#888;margin-left:auto';
            detail.textContent = r.detail;
            item.appendChild(icon);
            item.appendChild(rule);
            item.appendChild(detail);
            container.appendChild(item);
        });
        $('#qaModal').classList.add('show');
    },

    hideModal(which) { $(`#${which}Modal`).classList.remove('show'); },

    // ========== DUST WIPE SAMPLE SHEET FUNCTIONS ==========
    showSampleSheetModal() {
        // Clear inputs
        $('#sampleSheetInput1').value = this.doc.sampleSheetNumber || '';
        $('#sampleSheetInput2').value = '';
        $('#sampleSheetError').style.display = 'none';
        $('#sampleSheetModal').classList.add('show');
        // Focus first input
        setTimeout(() => $('#sampleSheetInput1').focus(), 100);
    },

    confirmSampleSheet() {
        const input1 = $('#sampleSheetInput1').value.trim();
        const input2 = $('#sampleSheetInput2').value.trim();
        const errorEl = $('#sampleSheetError');

        // Validate 5-digit number
        if (!/^\d{5}$/.test(input1)) {
            errorEl.textContent = 'Please enter exactly 5 digits';
            errorEl.style.display = 'block';
            return;
        }

        // Check confirmation matches
        if (input1 !== input2) {
            errorEl.textContent = 'Numbers do not match. Please confirm by entering the same number twice.';
            errorEl.style.display = 'block';
            return;
        }

        // Save sample sheet number
        this.doc.sampleSheetNumber = input1;
        $('#sampleSheetDisplay').textContent = input1;
        this.hideModal('sampleSheet');
        this.saveState();

        const hint = $('#toolHint');
        hint.textContent = `Sample sheet ${input1} confirmed`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 2000);
    },

    changeSampleSheet() {
        this.showSampleSheetModal();
    },

    skipSampleSheet() {
        this.hideModal('sampleSheet');
        // Use placeholder if no sample sheet set
        if (!this.doc.sampleSheetNumber) {
            this.doc.sampleSheetNumber = 'XXXXX';
            $('#sampleSheetDisplay').textContent = 'Not Set';
        }
    },

    // Pending dust wipe placement info
    pendingDustWipe: null,

    // Show sample number modal for dust wipe placement
    showSampleNumberModal(placementInfo) {
        this.pendingDustWipe = placementInfo;
        const sheetNum = this.doc.sampleSheetNumber || 'XXXXX';
        $('#sampleNumberPreview').textContent = sheetNum + '-___';
        $('#sampleNumberInput').value = '';
        $('#sampleNumberError').style.display = 'none';
        $('#sampleNumberModal').classList.add('show');
        setTimeout(() => $('#sampleNumberInput').focus(), 100);
    },

    confirmSampleNumber() {
        const input = $('#sampleNumberInput').value.trim();
        const errorEl = $('#sampleNumberError');

        // Validate 3-digit number
        if (!/^\d{3}$/.test(input)) {
            errorEl.textContent = 'Please enter exactly 3 digits';
            errorEl.style.display = 'block';
            return;
        }

        // Check for duplicate sample number
        const sheetNum = this.doc.sampleSheetNumber || 'XXXXX';
        const fullLabel = sheetNum + '-' + input;
        const duplicate = this.doc.dustWipes.find(dw => dw.label === fullLabel);
        if (duplicate) {
            errorEl.textContent = `Sample ${input} already exists`;
            errorEl.style.display = 'block';
            return;
        }

        const pending = this.pendingDustWipe;
        if (!pending) {
            this.hideModal('sampleNumber');
            return;
        }

        // Create dust wipe
        const dw = {
            id: Doc.uid(),
            label: fullLabel,
            x: pending.x,
            y: pending.y,
            parentWallSegmentId: pending.wallSegmentId || null,
            parentWindowId: pending.windowId || null,
            parentDoorId: pending.doorId || null,
            parentRoomId: pending.roomId || null,
            locationType: pending.locationType || null
        };

        this.doc.dustWipes.push(dw);
        this.pendingDustWipe = null;
        this.hideModal('sampleNumber');
        this.saveState();
        this.render();
        this.updateTree();
        this.updateSampleList();

        const hint = $('#toolHint');
        hint.textContent = `Sample ${fullLabel} placed`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 1500);
    },

    cancelSampleNumber() {
        this.pendingDustWipe = null;
        this.hideModal('sampleNumber');
    },

    // Update the sample list dropdown
    updateSampleList() {
        const list = $('#sampleList');
        const container = $('#sampleListContainer');
        if (!list || !container) return;

        const samples = this.doc.dustWipes || [];

        // Show/hide container based on samples
        container.style.display = samples.length > 0 ? 'block' : 'none';

        // Clear and rebuild options
        list.innerHTML = '<option value="">-- Select sample --</option>';

        // Sort samples by label number
        const sorted = [...samples].sort((a, b) => a.label.localeCompare(b.label));

        sorted.forEach(dw => {
            const opt = document.createElement('option');
            opt.value = dw.id;
            // Format: num|location (e.g., "001|wall" or "002|trough")
            const num = dw.label.split('-')[1] || dw.label;
            const loc = dw.locationType || 'unknown';
            opt.textContent = `${num}|${loc}`;
            list.appendChild(opt);
        });
    },

    // Select a sample from the list and highlight it
    selectSampleFromList(sampleId) {
        if (!sampleId) return;

        const dw = this.doc.dustWipes.find(d => d.id === sampleId);
        if (!dw) return;

        // Select the dust wipe
        Render.selection = { type: 'dustwipe', id: sampleId };
        this.render();

        // Pan to center on the sample
        const stage = Render.stage;
        const scale = stage.scaleX();
        const stageWidth = stage.width();
        const stageHeight = stage.height();

        stage.position({
            x: stageWidth / 2 - dw.x * scale,
            y: stageHeight / 2 - dw.y * scale
        });
        stage.batchDraw();
    },

    // Place a dust wipe sample marker on a wall
    placeDustWipe(ws, clickPos) {
        // If no sample sheet, prompt for it
        if (!this.doc.sampleSheetNumber) {
            this.showSampleSheetModal();
            return;
        }

        // Calculate position on wall
        let x, y;
        if (clickPos) {
            x = clickPos.x;
            y = clickPos.y;
        } else {
            // Default to wall midpoint
            x = (ws.x1 + ws.x2) / 2;
            y = (ws.y1 + ws.y2) / 2;
        }

        // Show sample number modal
        this.showSampleNumberModal({
            x: x,
            y: y,
            wallSegmentId: ws.id,
            roomId: ws.roomId,
            locationType: 'wall'
        });
    },

    // Pending window sample placement (stores window id while modal is open)
    pendingWindowSample: null,

    // Show window sample modal when clicking on a window with dust wipe tool
    showWindowSampleModal(windowId) {
        this.pendingWindowSample = windowId;
        $('#windowSampleModal').classList.add('show');
    },

    // Place window sample with specific location type
    placeWindowSample(locationType) {
        // Check if sample sheet is set
        if (!this.doc.sampleSheetNumber) {
            this.hideModal('windowSample');
            this.showSampleSheetModal();
            return;
        }

        const windowId = this.pendingWindowSample;
        if (!windowId) {
            this.hideModal('windowSample');
            return;
        }

        const win = this.doc.windows.find(w => w.id === windowId);
        if (!win) {
            this.hideModal('windowSample');
            return;
        }

        // Get window position
        const ws = this.doc.wallSegments.find(s => s.id === win.parentWallSegmentId);
        let x = 0, y = 0;
        if (ws) {
            const pos = Render.getPositionOnSegment(ws, win.distanceFromStart + win.width / 2);
            x = pos.x;
            y = pos.y - 20; // Offset from window
        }

        this.pendingWindowSample = null;
        this.hideModal('windowSample');

        // Show sample number modal
        this.showSampleNumberModal({
            x: x,
            y: y,
            windowId: windowId,
            roomId: win.parentRoomId,
            locationType: locationType  // trough, stool, or well
        });
    },

    // Pending floor sample placement (stores click position while modal is open)
    pendingFloorSample: null,

    // Show floor sample modal when clicking on floor/empty area with dust wipe tool
    showFloorSampleModal(x, y, roomId) {
        this.pendingFloorSample = { x, y, roomId };
        $('#floorSampleModal').classList.add('show');
    },

    // Place floor sample with specific surface type
    placeFloorSample(surfaceType) {
        // Check if sample sheet is set
        if (!this.doc.sampleSheetNumber) {
            this.hideModal('floorSample');
            this.showSampleSheetModal();
            return;
        }

        const pending = this.pendingFloorSample;
        if (!pending) {
            this.hideModal('floorSample');
            return;
        }

        this.pendingFloorSample = null;
        this.hideModal('floorSample');

        // Show sample number modal
        this.showSampleNumberModal({
            x: pending.x,
            y: pending.y,
            roomId: pending.roomId,
            locationType: surfaceType  // floor, entryway, other
        });
    },

    // Pending door sample placement
    pendingDoorSample: null,

    // Selected door type for placement
    selectedDoorType: 'regular',

    // Show door type selector modal
    showDoorTypeSelector() {
        $('#doorTypeModal').classList.add('show');
    },

    // Select door type and activate door tool
    selectDoorType(doorType) {
        this.selectedDoorType = doorType;
        this.hideModal('doorType');
        this.setTool('door');

        const hint = $('#toolHint');
        const typeNames = {
            'regular': 'REGULAR DOOR',
            'double': 'DOUBLE DOOR',
            'sliding': 'SLIDING DOOR',
            'bifold': 'BIFOLD DOOR',
            'bifold-double': 'DOUBLE BIFOLD DOOR',
            'pocket': 'POCKET DOOR',
            'overhead': 'OVERHEAD DOOR',
            'elevator': 'ELEVATOR DOOR',
            'revolving': 'REVOLVING DOOR'
        };
        hint.textContent = `Tap a wall to place ${typeNames[doorType] || 'DOOR'}`;
        hint.classList.add('show');
    },

    // Show door sample modal when clicking on a door with dust wipe tool
    showDoorSampleModal(doorId) {
        this.pendingDoorSample = doorId;
        $('#doorSampleModal').classList.add('show');
    },

    // Place door sample with specific location type
    placeDoorSample(locationType) {
        // Check if sample sheet is set
        if (!this.doc.sampleSheetNumber) {
            this.hideModal('doorSample');
            this.showSampleSheetModal();
            return;
        }

        const doorId = this.pendingDoorSample;
        if (!doorId) {
            this.hideModal('doorSample');
            return;
        }

        const door = this.doc.doors.find(d => d.id === doorId);
        if (!door) {
            this.hideModal('doorSample');
            return;
        }

        // Get door position
        const ws = this.doc.wallSegments.find(s => s.id === door.parentWallSegmentId);
        let x = 0, y = 0;
        if (ws) {
            const pos = Render.getPositionOnSegment(ws, door.distanceFromStart + door.width / 2);
            x = pos.x;
            y = pos.y;
        }

        this.pendingDoorSample = null;
        this.hideModal('doorSample');

        // Show sample number modal
        this.showSampleNumberModal({
            x: x,
            y: y,
            doorId: doorId,
            roomId: door.parentRoomId,
            locationType: locationType  // door frame, door threshold, door
        });
    },

    // Save project to .fbg file
    saveProject() {
        // Show format selection modal
        $('#saveFormatModal').classList.add('show');
    },

    saveAs(format) {
        // Hide the modal
        this.hideModal('saveFormat');

        // Save current floor first
        this.floors[this.currentFloor] = JSON.parse(JSON.stringify(this.doc));

        // Create project data structure
        const projectData = {
            version: '1.0',
            savedAt: new Date().toISOString(),
            currentFloor: this.currentFloor,
            floorList: this.floorList,
            floorLabels: this.floorLabels,
            floors: this.floors
        };

        // Generate filename from address or date
        const address = this.doc.address || 'floor-plan';
        const safeName = address.replace(/[^a-zA-Z0-9]/g, '-').substring(0, 30);
        const date = new Date().toISOString().split('T')[0];

        let blob, filename, mimeType;

        if (format === 'fbg' || format === 'json') {
            // JSON-based formats
            const jsonStr = JSON.stringify(projectData, null, 2);
            mimeType = 'application/json';
            filename = `${safeName}_${date}.${format}`;
            blob = new Blob([jsonStr], { type: mimeType });
        } else if (format === 'html') {
            // Standalone HTML - embed data in the current page HTML
            const htmlContent = this.generateStandaloneHTML(projectData);
            mimeType = 'text/html';
            filename = `${safeName}_${date}.html`;
            blob = new Blob([htmlContent], { type: mimeType });
        }

        // Download file
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Show confirmation
        const hint = $('#toolHint');
        hint.textContent = `Saved: ${filename}`;
        hint.classList.add('show');
        setTimeout(() => hint.classList.remove('show'), 3000);
    },

    generateStandaloneHTML(projectData) {
        // Get the current page HTML and embed the project data
        const currentHTML = document.documentElement.outerHTML;

        // Create a script that will load the project data on startup
        const dataScript = `
<script>
// Embedded project data - loaded automatically on startup
window.EMBEDDED_PROJECT_DATA = ${JSON.stringify(projectData)};
<\/script>`;

        // Insert the data script before the closing </head> tag
        let modifiedHTML = currentHTML.replace('</head>', dataScript + '\n</head>');

        // Also modify the init function to load embedded data
        // We'll add a check at the start of init()
        const initLoadCode = `
        // Check for embedded project data (standalone HTML)
        if (window.EMBEDDED_PROJECT_DATA) {
            const data = window.EMBEDDED_PROJECT_DATA;
            this.floors = data.floors || {};
            this.floorList = data.floorList || ['floor1'];
            this.floorLabels = data.floorLabels || { floor1: 'Floor 1' };
            this.currentFloor = data.currentFloor || 'floor1';
            if (this.floors[this.currentFloor]) {
                this.doc = JSON.parse(JSON.stringify(this.floors[this.currentFloor]));
            } else {
                this.doc = Doc.create();
            }
            this.updateFloorBadge();
        } else {`;

        // Find and modify the init function to check for embedded data
        modifiedHTML = modifiedHTML.replace(
            "// Load saved floors from localStorage\n        this.loadAllFloors();",
            initLoadCode + "\n            // Load saved floors from localStorage\n            this.loadAllFloors();\n        }"
        );

        return '<!DOCTYPE html>\n<html lang="en">' + modifiedHTML.substring(modifiedHTML.indexOf('<head>'));
    },

    loadFBG(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const data = JSON.parse(e.target.result);

                // Check if this is our new multi-floor project format
                if (data.version && data.floors) {
                    // New project format
                    this.floors = data.floors;
                    this.floorList = data.floorList || Object.keys(data.floors);
                    this.floorLabels = data.floorLabels || {};
                    this.currentFloor = data.currentFloor || this.floorList[0];

                    // Ensure floorLabels has entries for all floors
                    this.floorList.forEach((id, idx) => {
                        if (!this.floorLabels[id]) {
                            this.floorLabels[id] = 'Floor ' + (idx + 1);
                        }
                    });

                    // Load current floor document
                    if (this.floors[this.currentFloor]) {
                        this.doc = JSON.parse(JSON.stringify(this.floors[this.currentFloor]));
                    } else {
                        this.doc = Doc.create();
                    }

                    this.updateFloorBadge();
                } else {
                    // Old FBG format (single level)
                    this.doc = this.importFBG(data);
                    // Reset to single floor
                    this.floors = { floor1: JSON.parse(JSON.stringify(this.doc)) };
                    this.floorList = ['floor1'];
                    this.floorLabels = { floor1: 'Floor 1' };
                    this.currentFloor = 'floor1';
                    this.updateFloorBadge();
                }

                this.undoStack = [];
                this.redoStack = [];
                this.saveState();
                Render.deselect();
                this.render();
                this.updateTree();
                this.updateQABadge();
                this.updateInspector();
                this.updateUndoRedoButtons();
                this.updateSampleSheetDisplay();

                // Show success message
                const hint = $('#toolHint');
                hint.textContent = `Loaded: ${file.name}`;
                hint.classList.add('show');
                setTimeout(() => hint.classList.remove('show'), 2000);
            } catch (err) { alert('Load error: ' + err.message); }
        };
        reader.readAsText(file);
        event.target.value = '';
    },

    importFBG(data) {
        const doc = Doc.create();
        doc.address = data.address || '';
        const level = data.levels?.[data.currentLevelIndex || 0];
        if (!level) return doc;

        const objs = level.canvasObjects || [];
        let minX = Infinity, minY = Infinity;
        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                minX = Math.min(minX, o.startX || 0, o.endX || 0);
                minY = Math.min(minY, o.startY || 0, o.endY || 0);
            }
        });
        const offX = isFinite(minX) ? 60 - minX : 0;
        const offY = isFinite(minY) ? 60 - minY : 0;

        objs.forEach(o => {
            if (o.objectType === 'RoomEquivalent') {
                const rt = o.roomType || {};
                const abbr = rt.abbreviation || 'ROOM';
                const isCloset = abbr === 'CLO';
                const x = Math.min(o.startX, o.endX) + offX;
                const y = Math.min(o.startY, o.endY) + offY;
                const w = Math.abs(o.endX - o.startX);
                const h = Math.abs(o.endY - o.startY);
                if (w < 5 || h < 5) return;

                if (isCloset) {
                    const closet = { id: Doc.uid(), label: Doc.label(doc, 'closet'), fbgName: o.name, type: 'Closet', roomType: 'Closet', isExterior: false, geometry: { x, y, width: w, height: h } };
                    createWallSegments(closet, doc);
                    doc.closets.push(closet);
                } else {
                    const room = { id: Doc.uid(), label: Doc.label(doc, 'room'), type: rt.name || abbr, fbgName: o.name, isExterior: true, geometry: { x, y, width: w, height: h } };
                    createWallSegments(room, doc);
                    doc.rooms.push(room);
                }
            }
        });
        return doc;
    },

    exportPDF() {
        const qa = runQA(this.doc);
        const fails = qa.filter(r => !r.pass).length;
        if (fails > 0 && !confirm(`QA has ${fails} errors. Export anyway?`)) return;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('landscape', 'pt', 'letter');

        pdf.setFontSize(14);
        pdf.text('2BR/1BA Blueprint - Wall Segment Attachments', 40, 30);
        pdf.setFontSize(9);
        pdf.text(`Address: ${this.doc.address}`, 40, 45);
        pdf.text(`Date: ${new Date().toLocaleDateString()}`, 40, 57);
        pdf.text(`Rooms: ${this.doc.rooms.length} | Doors: ${this.doc.doors.length} | Windows: ${this.doc.windows.length}`, 40, 69);
        pdf.text(`QA: ${fails === 0 ? 'PASS' : fails + ' errors'}`, 300, 45);

        const img = Render.getImage();
        if (img) pdf.addImage(img, 'PNG', 40, 85, 700, 420);

        pdf.setFontSize(7);
        pdf.text('Wall IDs: W1=SOUTH, W2=WEST, W3=NORTH, W4=EAST (clockwise from south-most wall)', 40, 520);

        // Attachment summary
        let y = 535;
        pdf.setFontSize(8);
        pdf.text('Attachments:', 40, y);
        y += 10;
        this.doc.wallSegments.forEach(ws => {
            if (ws.attachedObjects.length > 0) {
                let room = this.doc.rooms.find(r => r.id === ws.roomId);
                if (!room) room = this.doc.closets.find(c => c.id === ws.roomId);
                const items = ws.attachedObjects.map(a => a.label).join(', ');
                pdf.text(`${room?.label} ${ws.label}: ${items}`, 50, y);
                y += 9;
                if (y > 580) { y = 535; pdf.addPage(); }
            }
        });

        pdf.save(`Blueprint_WallAttach_${new Date().toISOString().split('T')[0]}.pdf`);
    }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// Keyboard shortcut for delete (objects and standalone walls)
document.addEventListener('keydown', (e) => {
    const deletableTypes = ['door', 'window', 'cased', 'closet', 'mep', 'dustwipe'];
    if ((e.key === 'Delete' || e.key === 'Backspace') && Render.selection.type && Render.selection.id) {
        // Don't delete if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // Check if it's a deletable type or a standalone wall
        let canDelete = deletableTypes.includes(Render.selection.type);
        if (Render.selection.type === 'wall') {
            const wall = App.doc.wallSegments.find(ws => ws.id === Render.selection.id);
            canDelete = wall && !wall.roomId;  // Only standalone walls
        }

        if (!canDelete) return;
        e.preventDefault();
        App.deleteObject(Render.selection.id, Render.selection.type);
    }
});
</script>


</body></html>