<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lead Risk Assessment - Floor Plan Tool</title>
    <!-- Konva.js for canvas drawing -->
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* ========== GLOBAL STYLES & DARK THEME ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #3a3a3a;
            --bg-darker: #2d2d2d;
            --bg-panel: #252525;
            --accent-blue: #e6c84b;
            --accent-cyan: #f4d03f;
            --grid-color: #4a4a4a;
            --text-primary: #e0e0e0;
            --text-secondary: #999;
            --border-color: #444;
            --wall-color: #f4d03f;
            --sketch-yellow: #f4d03f;
            --dimension-red: #ff6b6b;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ========== TOP TOOLBAR ========== */
        .top-toolbar {
            display: flex;
            align-items: center;
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border-color);
            padding: 4px 10px;
            height: 36px;
            gap: 2px;
        }

        .menu-item {
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: var(--accent-blue);
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 8px;
        }

        .toolbar-btn {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .toolbar-btn.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        /* ========== MAIN LAYOUT ========== */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ========== LEFT SIDEBAR ========== */
        .left-sidebar {
            width: 220px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-section {
            border-bottom: 1px solid var(--border-color);
        }

        .section-header {
            padding: 8px 12px;
            background: var(--bg-darker);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent-cyan);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header:hover {
            background: #1e2a4a;
        }

        .section-content {
            padding: 8px;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .tool-icon {
            width: 40px;
            height: 40px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .tool-icon:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .tool-icon.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        .tool-icon svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* Tool Icon Grid with Labels */
        .tool-grid-icons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .tool-icon-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 6px 4px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .tool-icon-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .tool-icon-btn.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        .tool-icon-btn svg {
            width: 22px;
            height: 22px;
            stroke: currentColor;
            fill: none;
            stroke-width: 1.5;
            margin-bottom: 2px;
        }

        .tool-icon-btn span {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Object Tree */
        .object-tree {
            font-size: 12px;
        }

        .tree-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tree-item:hover {
            background: rgba(74, 144, 217, 0.2);
        }

        .tree-icon {
            width: 12px;
            height: 12px;
            background: var(--accent-cyan);
            border-radius: 2px;
        }

        /* Levels */
        .levels-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }

        .level-btn {
            width: 28px;
            height: 28px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .level-btn:hover {
            background: var(--accent-blue);
        }

        .level-display {
            flex: 1;
            text-align: center;
            font-size: 13px;
        }

        /* Wall Types */
        .wall-types {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .wall-type {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
        }

        .wall-type:hover {
            background: rgba(74, 144, 217, 0.2);
        }

        .wall-preview {
            width: 40px;
            height: 8px;
            background: var(--wall-color);
        }

        .wall-type-1 .wall-preview { height: 2px; }
        .wall-type-2 .wall-preview { height: 4px; }
        .wall-type-3 .wall-preview { height: 6px; }
        .wall-type-4 .wall-preview { height: 10px; }

        /* ========== CANVAS CONTAINER ========== */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-dark);
        }

        #blueprint-container {
            width: 100%;
            height: 100%;
        }

        /* ========== RIGHT SIDEBAR (Annotations) ========== */
        .right-sidebar {
            width: 180px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .annotation-tools {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
        }

        .anno-btn {
            padding: 8px 12px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .anno-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .anno-btn.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        .anno-icon {
            width: 20px;
            text-align: center;
        }

        /* Symbol Palette */
        .symbol-palette {
            padding: 8px;
        }

        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .symbol-item {
            width: 48px;
            height: 48px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 10px;
            text-align: center;
            padding: 4px;
            user-select: none;
        }

        .symbol-item:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .symbol-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Room Label Dialog */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
        }

        .modal-dialog h3 {
            margin-bottom: 16px;
            color: var(--accent-cyan);
        }

        .modal-dialog label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .modal-dialog select,
        .modal-dialog input {
            width: 100%;
            padding: 8px;
            margin-bottom: 12px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
        }

        .modal-dialog .btn-row {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }

        .modal-dialog button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .modal-dialog .btn-primary {
            background: var(--accent-cyan);
            color: #000;
        }

        .modal-dialog .btn-secondary {
            background: var(--bg-darker);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-dialog .dimensions-info {
            background: var(--bg-darker);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Snap indicator */
        .snap-indicator {
            position: absolute;
            bottom: 40px;
            right: 200px;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid var(--accent-cyan);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            color: var(--accent-cyan);
            display: none;
        }

        .snap-indicator.active {
            display: block;
        }

        /* ========== ROOM PALETTE (Sims-style) ========== */
        .room-palette {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .room-block {
            background: var(--bg-darker);
            border: 2px solid var(--room-color, #666);
            border-radius: 6px;
            padding: 8px 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            user-select: none;
        }

        .room-block:hover {
            background: color-mix(in srgb, var(--room-color) 30%, var(--bg-darker));
            transform: scale(1.02);
            box-shadow: 0 0 10px var(--room-color);
        }

        .room-block.selected {
            background: color-mix(in srgb, var(--room-color) 40%, var(--bg-darker));
            box-shadow: 0 0 15px var(--room-color);
        }

        .room-block-icon {
            font-size: 20px;
            margin-bottom: 2px;
        }

        .room-block span {
            font-size: 10px;
            color: var(--text-primary);
            display: block;
        }

        /* ========== STATUS BAR ========== */
        .status-bar {
            height: 24px;
            background: var(--bg-darker);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 11px;
            color: var(--text-secondary);
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* ========== SCALE LEGEND ========== */
        .scale-legend {
            position: absolute;
            bottom: 40px;
            left: 240px;
            background: rgba(15, 15, 35, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 11px;
        }

        .scale-bar {
            width: 100px;
            height: 6px;
            background: linear-gradient(90deg, #fff 50%, #000 50%);
            border: 1px solid #fff;
            margin-top: 4px;
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 900px) {
            .left-sidebar { width: 180px; }
            .right-sidebar { width: 140px; }
        }

        @media (max-width: 600px) {
            .left-sidebar, .right-sidebar { display: none; }
        }

        /* ========== ACCORDION SECTIONS ========== */
        .accordion-section {
            border-bottom: 1px solid var(--border-color);
        }

        .accordion-header {
            padding: 10px 12px;
            background: var(--bg-darker);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--accent-cyan);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .accordion-header:hover {
            background: #1e2a4a;
        }

        .accordion-header .toggle-icon {
            transition: transform 0.2s;
        }

        .accordion-section.collapsed .accordion-header .toggle-icon {
            transform: rotate(-90deg);
        }

        .accordion-section.collapsed .accordion-content {
            display: none;
        }

        .accordion-content {
            padding: 8px;
        }

        /* ========== ASSESSMENT TOOLS STYLES ========== */
        .assessment-btn {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .assessment-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .assessment-btn.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: #000;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            background: #ff4444;
            color: white;
            border-radius: 9px;
            font-size: 10px;
            font-weight: bold;
        }

        .badge.warning { background: #ff9800; }
        .badge.success { background: #4caf50; }
        .badge.info { background: #2196f3; }

        /* Condition badges */
        .condition-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .condition-DET { background: #ff4444; color: white; }
        .condition-FRI { background: #ff9800; color: white; }
        .condition-IMP { background: #2196f3; color: white; }
        .condition-WET { background: #9c27b0; color: white; }
        .condition-SUS { background: #607d8b; color: white; }

        .priority-P1 { border-left: 3px solid #ff4444; }
        .priority-P2 { border-left: 3px solid #ff9800; }
        .priority-P3 { border-left: 3px solid #4caf50; }

        /* List items in assessment panels */
        .assessment-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .assessment-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            background: var(--bg-darker);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .assessment-item:hover {
            background: rgba(74, 144, 217, 0.2);
        }

        /* QA Panel */
        .qa-panel {
            background: var(--bg-darker);
            border-radius: 4px;
            padding: 8px;
        }

        .qa-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .qa-flag {
            padding: 4px 8px;
            margin-bottom: 4px;
            background: rgba(255, 68, 68, 0.1);
            border-left: 3px solid #ff4444;
            border-radius: 0 4px 4px 0;
            font-size: 11px;
            cursor: pointer;
        }

        .qa-flag:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        /* Snap toggles */
        .snap-toggles {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .snap-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .snap-toggle input[type="checkbox"] {
            accent-color: var(--accent-cyan);
        }

        /* Layer controls */
        .layer-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 12px;
        }

        .layer-control label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .layer-control .lock-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
        }

        .layer-control .lock-btn:hover {
            color: var(--accent-cyan);
        }

        .layer-control .lock-btn.locked {
            color: #ff4444;
        }

        /* Wall type selector */
        .wall-type-selector {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .wall-type-btn {
            flex: 1;
            padding: 6px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            text-align: center;
        }

        .wall-type-btn:hover {
            background: var(--accent-blue);
        }

        .wall-type-btn.active {
            background: var(--accent-cyan);
            color: #000;
        }

        /* Component tool grid */
        .component-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .component-btn {
            padding: 8px 4px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            text-align: center;
        }

        .component-btn:hover {
            background: var(--accent-blue);
        }

        .component-btn.active {
            background: var(--accent-cyan);
            color: #000;
        }

        /* Right sidebar styling */
        .right-sidebar {
            width: 220px;
        }

        /* Modal improvements */
        .modal-dialog {
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-dialog .form-group {
            margin-bottom: 12px;
        }

        .modal-dialog .form-row {
            display: flex;
            gap: 12px;
        }

        .modal-dialog .form-row > * {
            flex: 1;
        }

        .modal-dialog textarea {
            width: 100%;
            padding: 8px;
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 13px;
            resize: vertical;
            min-height: 60px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- ========== TOP TOOLBAR ========== -->
    <div class="top-toolbar">
        <div class="menu-item">File</div>
        <div class="menu-item" onclick="saveToStorage()">Save</div>
        <div class="menu-item" onclick="loadFromStorage()">Load</div>
        <div class="menu-item" onclick="document.getElementById('fbgFileInput').click()">Load FBG</div>
        <div class="menu-item" onclick="runReconciliation()">Reconcile</div>
        <div class="menu-item" onclick="exportPDF()">Export PDF</div>
        <input type="file" id="fbgFileInput" accept=".fbg" style="display:none" onchange="loadFBGFileWithReconciliation(event)">
        <div class="menu-item">View</div>
        <div class="menu-item">Levels</div>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" onclick="toggleGrid()">Grid</button>
        <button class="toolbar-btn active" id="wallIdsBtn" onclick="toggleWallIds()">Wall IDs</button>
        <button class="toolbar-btn" id="dimsBtn" onclick="toggleDimensions()">Dims</button>
        <button class="toolbar-btn" onclick="zoomIn()">+</button>
        <button class="toolbar-btn" onclick="zoomOut()">-</button>
        <button class="toolbar-btn" onclick="resetView()">Reset</button>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" id="selectBtn" onclick="setTool('select')">Select</button>
        <button class="toolbar-btn" id="roomBtn" onclick="setTool('room')">Room</button>
        <button class="toolbar-btn" id="wallBtn" onclick="setTool('wall')">Wall</button>
        <div class="toolbar-separator"></div>
        <button class="toolbar-btn" style="background: #4caf50; border-color: #4caf50; color: #fff;" onclick="runFullBlueprintTest()">2BR/1BA</button>
    </div>

    <!-- ========== MAIN CONTAINER ========== -->
    <div class="main-container">
        <!-- ========== LEFT SIDEBAR ========== -->
        <div class="left-sidebar">
            <!-- Floor Plan Tree -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Floor Plan</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="object-tree" id="objectTree">
                        <div class="tree-item"><div class="tree-icon"></div>Draw rooms with R key</div>
                    </div>
                </div>
            </div>

            <!-- Levels -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Levels</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="levels-control">
                        <button class="level-btn" onclick="changeLevel(-1)">-</button>
                        <div class="level-display" id="levelDisplay">Level 1 (Ground)</div>
                        <button class="level-btn" onclick="changeLevel(1)">+</button>
                    </div>
                </div>
            </div>

            <!-- WALLS Section -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>WALLS</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="tool-grid-icons">
                        <div class="tool-icon-btn" id="wallToolBtn" title="Draw Wall (W)" onclick="setTool('wall')">
                            <svg viewBox="0 0 24 24"><rect x="2" y="10" width="20" height="4" fill="currentColor"/></svg>
                            <span>Wall</span>
                        </div>
                        <div class="tool-icon-btn" id="wallBreakBtn" title="Wall Break" onclick="setTool('wallbreak')">
                            <svg viewBox="0 0 24 24"><rect x="2" y="10" width="7" height="4" fill="currentColor"/><rect x="15" y="10" width="7" height="4" fill="currentColor"/><path d="M9 12h6" stroke="currentColor" stroke-dasharray="2,1"/></svg>
                            <span>Break</span>
                        </div>
                        <div class="tool-icon-btn" id="roomToolBtn" title="Draw Room (R)" onclick="setTool('room')">
                            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"/><text x="12" y="14" font-size="6" fill="currentColor" text-anchor="middle">Rm</text></svg>
                            <span>Room</span>
                        </div>
                        <div class="tool-icon-btn" id="closetToolBtn" title="Closet (CL)" onclick="setTool('closet')">
                            <svg viewBox="0 0 24 24"><rect x="4" y="6" width="16" height="14" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="6" x2="12" y2="20" stroke="currentColor"/><circle cx="10" cy="13" r="1" fill="currentColor"/><circle cx="14" cy="13" r="1" fill="currentColor"/></svg>
                            <span>Closet</span>
                        </div>
                    </div>
                    <label style="font-size: 10px; color: var(--text-secondary); margin-top: 8px; display: block;">Wall Type</label>
                    <div class="wall-type-selector">
                        <button class="wall-type-btn" id="wallExterior" onclick="setWallCategory('exterior')">Ext 6"</button>
                        <button class="wall-type-btn active" id="wallInterior" onclick="setWallCategory('interior')">Int 4½"</button>
                        <button class="wall-type-btn" id="wallPartition" onclick="setWallCategory('partition')">Part 3½"</button>
                    </div>
                </div>
            </div>

            <!-- OPENINGS Section -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>OPENINGS</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="tool-grid-icons">
                        <div class="tool-icon-btn" id="doorToolBtn" title="Door (D)" onclick="setTool('door')">
                            <svg viewBox="0 0 24 24"><rect x="6" y="4" width="12" height="16" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="15" cy="12" r="1.5" fill="currentColor"/><path d="M6 20 Q2 12 6 4" fill="none" stroke="currentColor" stroke-width="1" stroke-dasharray="2,1"/></svg>
                            <span>Door</span>
                        </div>
                        <div class="tool-icon-btn" id="casedOpeningBtn" title="Cased Opening (OP)" onclick="setTool('casedopening')">
                            <svg viewBox="0 0 24 24"><rect x="2" y="10" width="6" height="4" fill="currentColor"/><rect x="16" y="10" width="6" height="4" fill="currentColor"/><path d="M8 12h8" stroke="currentColor" stroke-width="2" stroke-dasharray="3,2"/></svg>
                            <span>Cased</span>
                        </div>
                        <div class="tool-icon-btn" id="windowToolBtn" title="Window (WIN)" onclick="setTool('window')">
                            <svg viewBox="0 0 24 24"><rect x="4" y="8" width="16" height="8" fill="none" stroke="currentColor" stroke-width="2"/><line x1="12" y1="8" x2="12" y2="16" stroke="currentColor"/><line x1="4" y1="12" x2="20" y2="12" stroke="currentColor"/></svg>
                            <span>Window</span>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 10px; color: var(--text-secondary);">Door Width</label>
                        <select id="doorWidthSelect" style="width: 100%; padding: 4px; margin-top: 4px; background: var(--bg-darker); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                            <option value="28">2'-4"</option>
                            <option value="30">2'-6"</option>
                            <option value="32" selected>2'-8"</option>
                            <option value="36">3'-0"</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- MEP / UTILITIES Section -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>MEP / UTILITIES</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="tool-grid-icons">
                        <div class="tool-icon-btn" id="pipeToolBtn" title="Pipe (hollow dot)" onclick="setTool('pipe')">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Pipe</span>
                        </div>
                        <div class="tool-icon-btn" id="gasToolBtn" title="Gas (filled dot)" onclick="setTool('gas')">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6" fill="currentColor"/></svg>
                            <span>Gas</span>
                        </div>
                        <div class="tool-icon-btn" id="radiatorToolBtn" title="Radiator (RAD)" onclick="setTool('radiator')">
                            <svg viewBox="0 0 24 24"><rect x="4" y="8" width="16" height="10" fill="none" stroke="currentColor" stroke-width="2"/><line x1="7" y1="8" x2="7" y2="18" stroke="currentColor"/><line x1="10" y1="8" x2="10" y2="18" stroke="currentColor"/><line x1="14" y1="8" x2="14" y2="18" stroke="currentColor"/><line x1="17" y1="8" x2="17" y2="18" stroke="currentColor"/></svg>
                            <span>Radiator</span>
                        </div>
                        <div class="tool-icon-btn" id="riserToolBtn" title="Riser (RSR)" onclick="setTool('riser')">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="12" cy="12" r="2" fill="currentColor"/><line x1="12" y1="2" x2="12" y2="7" stroke="currentColor" stroke-width="2"/><line x1="12" y1="17" x2="12" y2="22" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Riser</span>
                        </div>
                        <div class="tool-icon-btn" id="valveToolBtn" title="Valve" onclick="setTool('valve')">
                            <svg viewBox="0 0 24 24"><path d="M6 12h4M14 12h4" stroke="currentColor" stroke-width="2"/><path d="M10 8l4 8M10 16l4-8" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Valve</span>
                        </div>
                        <div class="tool-icon-btn" id="poeToolBtn" title="Point of Entry (POE)" onclick="setTool('poe')">
                            <svg viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"/><path d="M2 12h4M18 12h4M12 2v4M12 18v4" stroke="currentColor" stroke-width="2"/><text x="12" y="14" font-size="5" fill="currentColor" text-anchor="middle">POE</text></svg>
                            <span>POE</span>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 10px; color: var(--text-secondary);">POE Type</label>
                        <select id="poeTypeSelect" style="width: 100%; padding: 4px; margin-top: 4px; background: var(--bg-darker); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="telecom">Telecom</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- LRA MARKERS Section -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>LRA MARKERS</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="tool-grid-icons">
                        <div class="tool-icon-btn" id="obsToolBtn" title="Observation (OBS)" onclick="setTool('observation')">
                            <svg viewBox="0 0 24 24"><polygon points="12,2 22,20 2,20" fill="#ff4444" stroke="#fff" stroke-width="1"/><text x="12" y="16" font-size="10" fill="#fff" text-anchor="middle" font-weight="bold">!</text></svg>
                            <span>OBS</span>
                        </div>
                        <div class="tool-icon-btn" id="sampleToolBtn" title="Sample (S)" onclick="setTool('sample')">
                            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="#e91e63" stroke="#fff" stroke-width="1"/><text x="12" y="16" font-size="10" fill="#fff" text-anchor="middle" font-weight="bold">S</text></svg>
                            <span>Sample</span>
                        </div>
                        <div class="tool-icon-btn" id="photoToolBtn" title="Photo (PH)" onclick="setTool('photo')">
                            <svg viewBox="0 0 24 24"><rect x="4" y="6" width="16" height="12" rx="2" fill="#4caf50" stroke="#fff" stroke-width="1"/><circle cx="12" cy="12" r="3" fill="#2e7d32"/><path d="M12 2v4" stroke="#4caf50" stroke-width="2"/></svg>
                            <span>Photo</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Snap Rules -->
            <div class="accordion-section collapsed">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Snap Rules</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="snap-toggles">
                        <label class="snap-toggle">
                            <input type="checkbox" checked onchange="toggleSnapSetting('endpoints', this.checked)">
                            <span>Endpoints</span>
                        </label>
                        <label class="snap-toggle">
                            <input type="checkbox" checked onchange="toggleSnapSetting('midpoints', this.checked)">
                            <span>Midpoints</span>
                        </label>
                        <label class="snap-toggle">
                            <input type="checkbox" checked onchange="toggleSnapSetting('corners', this.checked)">
                            <span>Corners</span>
                        </label>
                        <label class="snap-toggle">
                            <input type="checkbox" checked onchange="toggleSnapSetting('grid', this.checked)">
                            <span>Grid</span>
                        </label>
                        <label class="snap-toggle">
                            <input type="checkbox" checked id="orthoToggle" onchange="toggleSnapSetting('ortho', this.checked)">
                            <span>Orthogonal</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Layers -->
            <div class="accordion-section collapsed">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Layers</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('basePlan', this.checked)">
                            Base Plan
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('basePlan', this)">L</button>
                    </div>
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('openings', this.checked)">
                            Openings
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('openings', this)">L</button>
                    </div>
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('components', this.checked)">
                            Components
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('components', this)">L</button>
                    </div>
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('observations', this.checked)">
                            Observations
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('observations', this)">L</button>
                    </div>
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('samples', this.checked)">
                            Samples
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('samples', this)">L</button>
                    </div>
                    <div class="layer-control">
                        <label>
                            <input type="checkbox" checked onchange="toggleLayerVisibility('photos', this.checked)">
                            Photos
                        </label>
                        <button class="lock-btn" onclick="toggleLayerLock('photos', this)">L</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========== CANVAS ========== -->
        <div class="canvas-container">
            <div id="blueprint-container"></div>

            <!-- Scale Legend -->
            <div class="scale-legend">
                <div>Scale: 1:50 | 1px = 2.5cm</div>
                <div style="margin-top: 4px;">10 ft / 3.05 m</div>
                <div class="scale-bar"></div>
            </div>
        </div>

        <!-- ========== RIGHT SIDEBAR (Assessment Tools) ========== -->
        <div class="right-sidebar">
            <!-- Observations -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Observations</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <button class="assessment-btn" onclick="setTool('observation')">
                        + Add OBS
                    </button>
                    <div class="assessment-list" id="obsList">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Samples/Tests -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Samples/Tests</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <button class="assessment-btn" onclick="setTool('sample')">
                        + Add Sample
                    </button>
                    <div class="assessment-list" id="sampleList">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Photos -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>Photos</span>
                    <span class="toggle-icon">-</span>
                </div>
                <div class="accordion-content">
                    <button class="assessment-btn" onclick="setTool('photo')">
                        + Add Photo
                    </button>
                    <div class="assessment-list" id="photoList">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- QA Checklist -->
            <div class="accordion-section">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>QA Checklist</span>
                    <span class="badge" id="qaErrorCount">0</span>
                </div>
                <div class="accordion-content">
                    <div class="qa-panel">
                        <div id="qaFlagList">
                            <div style="font-size: 11px; color: var(--text-secondary);">No issues found</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- ========== ROOM LABEL DIALOG ========== -->
    <div class="modal-overlay" id="roomLabelModal">
        <div class="modal-dialog">
            <h3>Edit Room</h3>
            <div class="dimensions-info" id="roomDimensions">
                Size: 0' x 0' (0m x 0m)
            </div>
            <label for="roomTypeSelect">Room Type</label>
            <select id="roomTypeSelect">
                <option value="Bedroom">Bedroom</option>
                <option value="Bathroom">Bathroom</option>
                <option value="Kitchen">Kitchen</option>
                <option value="Living Room">Living Room</option>
                <option value="Dining Room">Dining Room</option>
                <option value="Closet">Closet</option>
                <option value="Laundry">Laundry</option>
                <option value="Garage">Garage</option>
                <option value="Office">Office</option>
                <option value="Hallway">Hallway</option>
                <option value="Custom">Custom</option>
            </select>
            <label for="roomCustomLabel">Custom Label (optional)</label>
            <input type="text" id="roomCustomLabel" placeholder="Enter custom label...">
            <div class="btn-row">
                <button class="btn-secondary" onclick="closeRoomLabelModal()">Cancel</button>
                <button class="btn-primary" onclick="saveRoomLabel()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== OBSERVATION MODAL ========== -->
    <div class="modal-overlay" id="observationModal">
        <div class="modal-dialog">
            <h3>Observation Details</h3>
            <div class="form-group">
                <label>Observation ID</label>
                <input type="text" id="obsId" readonly style="background: #333;">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Condition Code</label>
                    <select id="obsCondition">
                        <option value="">Select...</option>
                        <option value="DET">DET - Deteriorated</option>
                        <option value="FRI">FRI - Friction</option>
                        <option value="IMP">IMP - Impact</option>
                        <option value="WET">WET - Water Damage</option>
                        <option value="SUS">SUS - Suspect</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Priority</label>
                    <select id="obsPriority">
                        <option value="">Select...</option>
                        <option value="P1">P1 - High</option>
                        <option value="P2">P2 - Medium</option>
                        <option value="P3">P3 - Low</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>Room</label>
                <select id="obsRoom">
                    <option value="">Select Room...</option>
                </select>
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="obsDescription" placeholder="Describe the observed condition..."></textarea>
            </div>
            <div class="form-group">
                <label>Linked Photos (required)</label>
                <div class="checkbox-group" id="obsPhotoLinks">
                    <span style="font-size: 11px; color: var(--text-secondary);">No photos available</span>
                </div>
            </div>
            <div class="btn-row">
                <button class="btn-secondary" onclick="closeObservationModal()">Cancel</button>
                <button class="btn-primary" onclick="saveObservation()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== SAMPLE MODAL ========== -->
    <div class="modal-overlay" id="sampleModal">
        <div class="modal-dialog">
            <h3>Sample Details</h3>
            <div class="form-group">
                <label>Sample ID</label>
                <input type="text" id="sampleId" readonly style="background: #333;">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Method</label>
                    <select id="sampleMethod">
                        <option value="">Select...</option>
                        <option value="XRF">XRF</option>
                        <option value="CHIP">Paint Chip</option>
                        <option value="DUST">Dust Wipe</option>
                        <option value="SOIL">Soil</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Result</label>
                    <select id="sampleResult">
                        <option value="">Pending...</option>
                        <option value="POS">Positive</option>
                        <option value="NEG">Negative</option>
                        <option value="INCONCLUSIVE">Inconclusive</option>
                        <option value="NO-ACCESS">No Access</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>Target Component/Location</label>
                <input type="text" id="sampleTarget" placeholder="e.g., WIN-03 sill, Door D-01 trim">
            </div>
            <div class="form-group">
                <label>Notes</label>
                <textarea id="sampleNotes" placeholder="Additional notes..."></textarea>
            </div>
            <div class="btn-row">
                <button class="btn-secondary" onclick="closeSampleModal()">Cancel</button>
                <button class="btn-primary" onclick="saveSample()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== DOOR MODAL ========== -->
    <div class="modal-overlay" id="doorModal">
        <div class="modal-dialog">
            <h3>Door Properties</h3>
            <div class="form-group">
                <label>Door ID</label>
                <input type="text" id="doorId" readonly style="background: #333;">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Width (inches)</label>
                    <input type="number" id="doorWidth" value="32" min="24" max="48">
                </div>
                <div class="form-group">
                    <label>Associated Wall</label>
                    <select id="doorWall">
                        <option value="">Select Wall...</option>
                    </select>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Swing Direction</label>
                    <select id="doorSwingDir">
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Swing In/Out</label>
                    <select id="doorSwingInOut">
                        <option value="in">In</option>
                        <option value="out">Out</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="doorArcVisible" checked>
                    Show swing arc
                </label>
            </div>
            <div class="btn-row">
                <button class="btn-secondary" onclick="closeDoorModal()">Cancel</button>
                <button class="btn-primary" onclick="saveDoor()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== WINDOW MODAL ========== -->
    <div class="modal-overlay" id="windowModal">
        <div class="modal-dialog">
            <h3>Window Properties</h3>
            <div class="form-group">
                <label>Window ID</label>
                <input type="text" id="windowId" readonly style="background: #333;">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Width (inches)</label>
                    <input type="number" id="windowWidth" value="36" min="12" max="96">
                </div>
                <div class="form-group">
                    <label>Sill Height (inches)</label>
                    <input type="number" id="windowSillHeight" value="36" min="0" max="60">
                </div>
            </div>
            <div class="form-group">
                <label>Associated Wall</label>
                <select id="windowWall">
                    <option value="">Select Wall...</option>
                </select>
            </div>
            <div class="form-group">
                <label>Subcomponents</label>
                <div class="checkbox-group">
                    <label><input type="checkbox" id="windowHasStool" checked> Stool</label>
                    <label><input type="checkbox" id="windowHasApron" checked> Apron</label>
                    <label><input type="checkbox" id="windowHasWell"> Well</label>
                </div>
            </div>
            <div class="btn-row">
                <button class="btn-secondary" onclick="closeWindowModal()">Cancel</button>
                <button class="btn-primary" onclick="saveWindow()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== PHOTO MODAL ========== -->
    <div class="modal-overlay" id="photoModal">
        <div class="modal-dialog">
            <h3>Photo Marker</h3>
            <div class="form-group">
                <label>Photo ID</label>
                <input type="text" id="photoId" readonly style="background: #333;">
            </div>
            <div class="form-group">
                <label>Direction (degrees)</label>
                <input type="number" id="photoDirection" value="0" min="0" max="359">
                <span style="font-size: 10px; color: var(--text-secondary);">0 = North, 90 = East</span>
            </div>
            <div class="form-group">
                <label>Caption</label>
                <input type="text" id="photoCaption" placeholder="Photo description...">
            </div>
            <div class="form-group">
                <label>Linked Observations</label>
                <div class="checkbox-group" id="photoObsLinks">
                    <span style="font-size: 11px; color: var(--text-secondary);">No observations available</span>
                </div>
            </div>
            <div class="btn-row">
                <button class="btn-secondary" onclick="closePhotoModal()">Cancel</button>
                <button class="btn-primary" onclick="savePhoto()">Save</button>
            </div>
        </div>
    </div>

    <!-- ========== SNAP INDICATOR ========== -->
    <div class="snap-indicator" id="snapIndicator">SNAP</div>

    <!-- ========== STATUS BAR ========== -->
    <div class="status-bar">
        <div class="status-item">
            <span>Pos:</span>
            <span id="mousePos">X: 0, Y: 0</span>
        </div>
        <div class="status-item">
            <span>Zoom:</span>
            <span id="zoomLevel">100%</span>
        </div>
        <div class="status-item">
            <span>Tool:</span>
            <span id="currentTool">Select</span>
        </div>
        <div class="status-item">
            <span>Objects:</span>
            <span id="objectCount">0</span>
        </div>
    </div>

    <script>
        /* ==========================================================================
           CAD BLUEPRINT FLOOR PLAN - INTERACTIVE DRAWING APPLICATION
           Using Konva.js for canvas rendering
           Version 2.0 - Full CAD Drawing Tool
           ========================================================================== */

        // ========== CENTRALIZED STATE MANAGEMENT ==========
        const CADState = {
            // Canvas & Layers
            stage: null,
            layers: {
                grid: null,
                rooms: null,
                walls: null,
                openings: null,
                components: null,
                observations: null,
                samples: null,
                photos: null,
                dimensions: null,
                furniture: null,
                annotations: null,
                ui: null
            },
            transformer: null,

            // Dynamic collections
            rooms: [],
            walls: [],
            furniture: [],
            openings: [],      // Doors, windows, cased openings
            closets: [],       // Closet modules (CL-##)
            components: [],    // Paint-bearing: baseboard, trim, radiator, riser
            mepNodes: [],      // Pipe nodes, gas nodes, valves
            poeMarkers: [],    // Point of Entry markers
            observations: [],  // OBS hazard callouts
            samples: [],       // XRF, chip, dust, soil samples
            photos: [],        // Photo markers with direction

            // Display toggles
            showWallIds: true,
            showDimensions: true,

            // Tool state
            mode: 'select',
            wallType: 3,
            wallCategory: 'interior', // interior/exterior/partition
            level: 1,

            // Selection
            selection: [],

            // History for undo/redo
            history: {
                undoStack: [],
                redoStack: [],
                maxHistory: 50
            },

            // Settings
            settings: {
                gridSize: 12,           // 6" grid at scale
                majorGridSize: 24,      // 1' major grid at scale
                snapThreshold: 6,
                snapEnabled: true,
                showGrid: true,
                scaleFactor: 2          // 1 inch = 2 pixels (so 1' = 24px)
            },

            // Architectural scale settings
            archScale: {
                pixelsPerInch: 2,       // At 1/4" = 1'-0" scale
                pixelsPerFoot: 24,      // 12 inches * 2 pixels
                exteriorWallThickness: 6,    // 6 inches
                interiorWallThickness: 4.5,  // 4-1/2 inches
                partitionThickness: 3.5      // 3-1/2 inches
            },

            // Snap settings
            snapSettings: {
                endpoints: true,
                midpoints: true,
                corners: true,
                grid: true,
                ortho: true         // Orthogonal constraint (default ON)
            },

            // Layer visibility
            layerVisibility: {
                basePlan: true,
                openings: true,
                closets: true,
                components: true,
                mep: true,
                observations: true,
                samples: true,
                photos: true,
                dimensions: true,
                wallIds: true
            },

            // Layer locks
            layerLocks: {
                basePlan: false,
                openings: false,
                components: false,
                observations: false,
                samples: false,
                photos: false
            },

            // QA validation flags
            qaFlags: [],

            // Drawing state
            drawing: {
                isDrawing: false,
                startPos: null,
                preview: null,
                wallStartPoint: null
            },

            // UI state
            northArrowAngle: 0,
            editingRoom: null,
            editingDoor: null,
            editingWindow: null,
            editingObservation: null,
            editingSample: null,
            selectedRoomType: null,

            // Categorized ID counters
            counters: {
                room: 0,
                wall: {},      // Per-room: { 'Rm-01': 0, 'Rm-02': 0 }
                door: 0,
                window: 0,
                casedOpening: 0,
                closet: 0,
                radiator: 0,
                riser: 0,
                pipe: 0,
                gas: 0,
                valve: 0,
                poe: 0,
                observation: 0,
                sample: 0,
                photo: 0,
                component: 0
            },

            // Generate categorized IDs
            generateRoomId: function() {
                this.counters.room++;
                return `Rm-${String(this.counters.room).padStart(2, '0')}`;
            },
            generateWallId: function(roomId) {
                if (!this.counters.wall[roomId]) {
                    this.counters.wall[roomId] = 0;
                }
                this.counters.wall[roomId]++;
                return `W${this.counters.wall[roomId]}`;
            },
            generateDoorId: function() {
                this.counters.door++;
                return `D-${String(this.counters.door).padStart(2, '0')}`;
            },
            generateWindowId: function() {
                this.counters.window++;
                return `WIN-${String(this.counters.window).padStart(2, '0')}`;
            },
            generateCasedOpeningId: function() {
                this.counters.casedOpening++;
                return `OP-${String(this.counters.casedOpening).padStart(2, '0')}`;
            },
            generateClosetId: function() {
                this.counters.closet++;
                return `CL-${String(this.counters.closet).padStart(2, '0')}`;
            },
            generatePipeId: function() {
                this.counters.pipe++;
                return `PIPE-${String(this.counters.pipe).padStart(2, '0')}`;
            },
            generateGasId: function() {
                this.counters.gas++;
                return `GAS-${String(this.counters.gas).padStart(2, '0')}`;
            },
            generateValveId: function() {
                this.counters.valve++;
                return `VLV-${String(this.counters.valve).padStart(2, '0')}`;
            },
            generatePoeId: function() {
                this.counters.poe++;
                return `POE-${String(this.counters.poe).padStart(2, '0')}`;
            },
            generateObsId: function() {
                this.counters.observation++;
                return `OBS-${String(this.counters.observation).padStart(3, '0')}`;
            },
            generateSampleId: function() {
                this.counters.sample++;
                return `S-${String(this.counters.sample).padStart(3, '0')}`;
            },
            generatePhotoId: function() {
                this.counters.photo++;
                return `PH-${String(this.counters.photo).padStart(3, '0')}`;
            },
            generateComponentId: function(type) {
                this.counters.component++;
                const prefixes = {
                    radiator: 'RAD',
                    riser: 'RSR',
                    baseboard: 'BB',
                    trim: 'TRM',
                    cabinet: 'CAB',
                    stairs: 'STR',
                    railing: 'RLG',
                    chairrail: 'CR',
                    crown: 'CRN'
                };
                const prefix = prefixes[type] || 'CMP';
                return `${prefix}-${String(this.counters.component).padStart(2, '0')}`;
            },

            // Legacy ID generator for backward compatibility
            idCounter: 0,
            generateId: function(prefix) {
                return `${prefix}_${++this.idCounter}`;
            }
        };

        // Room type colors and default sizes (width x height in pixels)
        // Blueprint sketch style - grey fills with yellow outlines
        const ROOM_TYPES = {
            'Bedroom': { color: '#4a4a4a', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 160, h: 140 } },
            'Bathroom': { color: '#454545', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 100, h: 80 } },
            'Kitchen': { color: '#505050', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 140, h: 120 } },
            'Living Room': { color: '#484848', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 200, h: 160 } },
            'Dining Room': { color: '#4c4c4c', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 140, h: 120 } },
            'Closet': { color: '#424242', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 60, h: 80 } },
            'Laundry': { color: '#464646', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 80, h: 80 } },
            'Garage': { color: '#3e3e3e', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 200, h: 200 } },
            'Office': { color: '#4e4e4e', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 120, h: 100 } },
            'Hallway': { color: '#404040', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 160, h: 60 } },
            'Custom': { color: '#4a4a4a', textColor: '#f4d03f', strokeColor: '#f4d03f', defaultSize: { w: 100, h: 100 } }
        };

        // ========== ARCHITECTURAL SCALE CONVERSION ==========
        // Convert feet to pixels at current scale
        function ft(feet) {
            return feet * CADState.archScale.pixelsPerFoot;
        }

        // Convert inches to pixels at current scale
        function inch(inches) {
            return inches * CADState.archScale.pixelsPerInch;
        }

        // Convert feet-inches string (e.g., "3'-6\"") to pixels
        function ftIn(feetInches) {
            const match = feetInches.match(/(\d+)'?\s*-?\s*(\d+)?\"?/);
            if (match) {
                const feet = parseInt(match[1]) || 0;
                const inches = parseInt(match[2]) || 0;
                return ft(feet) + inch(inches);
            }
            return 0;
        }

        // Format pixels back to feet-inches string
        function formatDimension(pixels) {
            const totalInches = pixels / CADState.archScale.pixelsPerInch;
            const feet = Math.floor(totalInches / 12);
            const inches = Math.round(totalInches % 12);
            if (inches === 0) return `${feet}'-0"`;
            return `${feet}'-${inches}"`;
        }

        // ========== ARCHITECTURAL WALL SYSTEM ==========
        // Track architectural walls separately from simple walls
        let archWalls = [];
        let archOpenings = [];
        let archDimensions = [];

        // Create a wall with proper thickness
        function createArchWall(x1, y1, x2, y2, wallType = 'exterior') {
            const thickness = wallType === 'exterior' ?
                inch(CADState.archScale.exteriorWallThickness) :
                inch(CADState.archScale.interiorWallThickness);

            const wallId = CADState.generateId('WALL');
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const wallGroup = new Konva.Group({
                x: x1,
                y: y1,
                rotation: angle,
                name: 'arch-wall',
                id: wallId
            });

            // Main wall body
            const wallRect = new Konva.Rect({
                x: 0,
                y: -thickness / 2,
                width: length,
                height: thickness,
                fill: '#3a3a3a',
                stroke: '#f4d03f',
                strokeWidth: 1,
                name: 'wall-body'
            });

            wallGroup.add(wallRect);

            const wallData = {
                id: wallId,
                type: wallType,
                x1, y1, x2, y2,
                thickness: thickness,
                length: length,
                angle: angle,
                openings: [],
                konvaGroup: wallGroup
            };

            archWalls.push(wallData);
            CADState.layers.walls.add(wallGroup);

            return wallData;
        }

        // Create opening (door/window) in a wall - true wall cut
        function createArchOpening(wallData, offsetFromStart, width, openingType = 'door', options = {}) {
            const openingId = openingType === 'door' ?
                CADState.generateDoorId() : CADState.generateWindowId();

            const thickness = wallData.thickness;
            const offsetPx = inch(offsetFromStart);
            const widthPx = inch(width);

            // Create opening group
            const openingGroup = new Konva.Group({
                x: offsetPx,
                y: -thickness / 2,
                name: 'arch-opening',
                id: openingId
            });

            // Cut out the wall (white rectangle to "erase")
            const cutout = new Konva.Rect({
                x: 0,
                y: 0,
                width: widthPx,
                height: thickness,
                fill: '#3a3a3a', // Match background
                name: 'opening-cutout'
            });
            openingGroup.add(cutout);

            if (openingType === 'door') {
                // Door jamb lines
                openingGroup.add(new Konva.Line({
                    points: [0, 0, 0, thickness],
                    stroke: '#f4d03f',
                    strokeWidth: 2
                }));
                openingGroup.add(new Konva.Line({
                    points: [widthPx, 0, widthPx, thickness],
                    stroke: '#f4d03f',
                    strokeWidth: 2
                }));

                // Door swing arc
                const swingDir = options.swingDirection || 'left';
                const swingIn = options.swingInOut || 'in';
                const arcY = swingIn === 'in' ? thickness : 0;
                const arcDir = swingDir === 'left' ? 1 : -1;
                const arcStartX = swingDir === 'left' ? 0 : widthPx;

                // Door panel line
                const doorLine = new Konva.Line({
                    points: [arcStartX, arcY, arcStartX + (widthPx * arcDir), arcY],
                    stroke: '#f4d03f',
                    strokeWidth: 1,
                    name: 'door-panel'
                });
                openingGroup.add(doorLine);

                // Door arc
                const arc = new Konva.Arc({
                    x: arcStartX,
                    y: arcY,
                    innerRadius: widthPx - 2,
                    outerRadius: widthPx,
                    angle: 90,
                    rotation: swingDir === 'left' ? (swingIn === 'in' ? -90 : 0) : (swingIn === 'in' ? 180 : 90),
                    fill: '#f4d03f',
                    name: 'door-arc'
                });
                openingGroup.add(arc);

            } else if (openingType === 'window') {
                // Window frame lines
                openingGroup.add(new Konva.Line({
                    points: [0, 0, 0, thickness],
                    stroke: '#f4d03f',
                    strokeWidth: 2
                }));
                openingGroup.add(new Konva.Line({
                    points: [widthPx, 0, widthPx, thickness],
                    stroke: '#f4d03f',
                    strokeWidth: 2
                }));
                // Window sill lines (center lines)
                openingGroup.add(new Konva.Line({
                    points: [2, thickness / 2, widthPx - 2, thickness / 2],
                    stroke: '#f4d03f',
                    strokeWidth: 1
                }));
                // Glass indication
                openingGroup.add(new Konva.Line({
                    points: [widthPx / 2, 2, widthPx / 2, thickness - 2],
                    stroke: '#f4d03f',
                    strokeWidth: 1,
                    dash: [4, 2]
                }));
            }

            // Add opening ID label
            const label = new Konva.Text({
                x: widthPx / 2 - 15,
                y: thickness + 4,
                text: openingId,
                fontSize: 8,
                fill: '#f4d03f'
            });
            openingGroup.add(label);

            wallData.konvaGroup.add(openingGroup);

            const openingData = {
                id: openingId,
                type: openingType,
                wallId: wallData.id,
                offset: offsetFromStart,
                width: width,
                options: options,
                konvaGroup: openingGroup
            };

            wallData.openings.push(openingData);
            archOpenings.push(openingData);

            return openingData;
        }

        // Add dimension line
        function addDimensionLine(x1, y1, x2, y2, offset = 30, side = 'top') {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            // Perpendicular offset
            const perpX = -Math.sin(angle) * offset * (side === 'top' ? -1 : 1);
            const perpY = Math.cos(angle) * offset * (side === 'top' ? -1 : 1);

            const dimGroup = new Konva.Group({
                name: 'dimension-line'
            });

            // Start tick
            dimGroup.add(new Konva.Line({
                points: [x1, y1, x1 + perpX, y1 + perpY],
                stroke: '#ff6b6b',
                strokeWidth: 1
            }));

            // End tick
            dimGroup.add(new Konva.Line({
                points: [x2, y2, x2 + perpX, y2 + perpY],
                stroke: '#ff6b6b',
                strokeWidth: 1
            }));

            // Dimension line
            dimGroup.add(new Konva.Line({
                points: [x1 + perpX, y1 + perpY, x2 + perpX, y2 + perpY],
                stroke: '#ff6b6b',
                strokeWidth: 1
            }));

            // Dimension text
            const midX = (x1 + x2) / 2 + perpX;
            const midY = (y1 + y2) / 2 + perpY;
            const dimText = formatDimension(length);

            dimGroup.add(new Konva.Text({
                x: midX - 20,
                y: midY - 6,
                text: dimText,
                fontSize: 10,
                fill: '#ff6b6b',
                fontStyle: 'bold',
                rotation: angle * 180 / Math.PI
            }));

            CADState.layers.dimensions.add(dimGroup);
            archDimensions.push(dimGroup);

            return dimGroup;
        }

        // Add room label (lightweight - just name)
        function addRoomLabel(x, y, width, height, label) {
            const labelGroup = new Konva.Group({
                x: x,
                y: y,
                name: 'room-label-arch'
            });

            labelGroup.add(new Konva.Text({
                x: 0,
                y: 0,
                width: width,
                height: height,
                text: label,
                fontSize: 14,
                fontStyle: 'bold',
                fill: '#f4d03f',
                align: 'center',
                verticalAlign: 'middle'
            }));

            CADState.layers.annotations.add(labelGroup);
            return labelGroup;
        }

        // ========== INITIALIZATION ==========
        function init() {
            const container = document.getElementById('blueprint-container');
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            // Create Konva stage
            CADState.stage = new Konva.Stage({
                container: 'blueprint-container',
                width: width,
                height: height,
                draggable: true
            });

            // Create layers (bottom to top)
            CADState.layers.grid = new Konva.Layer();
            CADState.layers.rooms = new Konva.Layer();
            CADState.layers.walls = new Konva.Layer();
            CADState.layers.openings = new Konva.Layer();
            CADState.layers.components = new Konva.Layer();
            CADState.layers.dimensions = new Konva.Layer();
            CADState.layers.furniture = new Konva.Layer();
            CADState.layers.observations = new Konva.Layer();
            CADState.layers.samples = new Konva.Layer();
            CADState.layers.photos = new Konva.Layer();
            CADState.layers.annotations = new Konva.Layer();
            CADState.layers.ui = new Konva.Layer();

            CADState.stage.add(CADState.layers.grid);
            CADState.stage.add(CADState.layers.rooms);
            CADState.stage.add(CADState.layers.walls);
            CADState.stage.add(CADState.layers.openings);
            CADState.stage.add(CADState.layers.components);
            CADState.stage.add(CADState.layers.dimensions);
            CADState.stage.add(CADState.layers.furniture);
            CADState.stage.add(CADState.layers.observations);
            CADState.stage.add(CADState.layers.samples);
            CADState.stage.add(CADState.layers.photos);
            CADState.stage.add(CADState.layers.annotations);
            CADState.stage.add(CADState.layers.ui);

            // Create transformer for selection
            CADState.transformer = new Konva.Transformer({
                rotateEnabled: false,
                boundBoxFunc: (oldBox, newBox) => {
                    // Minimum size validation
                    if (newBox.width < 20 || newBox.height < 20) {
                        return oldBox;
                    }
                    return newBox;
                }
            });
            CADState.layers.ui.add(CADState.transformer);

            // Draw initial elements
            drawGrid();
            drawNorthArrow();

            // Setup all event handlers
            setupEventHandlers();
            setupKeyboardShortcuts();
            setupFurnitureDragAndDrop();
            setupRoomPalette();

            // Update status
            updateObjectCount();
            updateObjectTree();
            updateAssessmentLists();

            // Try to load saved state
            loadFromStorage(true);

            // Initialize QA validation
            runQAValidation();

            // Save initial state for undo
            saveHistoryState();
        }

        // ========== GRID DRAWING ==========
        function drawGrid() {
            const layer = CADState.layers.grid;
            layer.destroyChildren();

            if (!CADState.settings.showGrid) {
                layer.batchDraw();
                return;
            }

            const gridSize = CADState.settings.gridSize;
            const majorGridSize = CADState.settings.majorGridSize;
            const stage = CADState.stage;
            const width = stage.width() * 3;
            const height = stage.height() * 3;
            const offsetX = -stage.width();
            const offsetY = -stage.height();

            // Background
            layer.add(new Konva.Rect({
                x: offsetX,
                y: offsetY,
                width: width,
                height: height,
                fill: '#3a3a3a'
            }));

            // Minor grid lines
            for (let x = offsetX; x < width + offsetX; x += gridSize) {
                layer.add(new Konva.Line({
                    points: [x, offsetY, x, height + offsetY],
                    stroke: '#4a4a4a',
                    strokeWidth: 0.5
                }));
            }
            for (let y = offsetY; y < height + offsetY; y += gridSize) {
                layer.add(new Konva.Line({
                    points: [offsetX, y, width + offsetX, y],
                    stroke: '#4a4a4a',
                    strokeWidth: 0.5
                }));
            }

            // Major grid lines
            for (let x = offsetX; x < width + offsetX; x += majorGridSize) {
                layer.add(new Konva.Line({
                    points: [x, offsetY, x, height + offsetY],
                    stroke: '#5a5a5a',
                    strokeWidth: 1
                }));
            }
            for (let y = offsetY; y < height + offsetY; y += majorGridSize) {
                layer.add(new Konva.Line({
                    points: [offsetX, y, width + offsetX, y],
                    stroke: '#5a5a5a',
                    strokeWidth: 1
                }));
            }

            layer.batchDraw();
        }

        // ========== SNAP TO GRID ==========
        function snapToGrid(value) {
            if (!CADState.settings.snapEnabled) return value;
            const gridSize = CADState.settings.gridSize;
            return Math.round(value / gridSize) * gridSize;
        }

        function snapPosition(pos) {
            return {
                x: snapToGrid(pos.x),
                y: snapToGrid(pos.y)
            };
        }

        function showSnapIndicator(show) {
            const indicator = document.getElementById('snapIndicator');
            if (show && CADState.settings.snapEnabled) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
        }

        // ========== ROOM CREATION & MANAGEMENT ==========
        function createRoom(x, y, width, height, type = 'Custom', customLabel = '') {
            const roomId = CADState.generateRoomId();
            const colors = ROOM_TYPES[type] || ROOM_TYPES['Custom'];

            // Create a group for the room
            const roomGroup = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'room-group',
                id: roomId
            });

            // Room fill rectangle
            const roomRect = new Konva.Rect({
                x: 0,
                y: 0,
                width: width,
                height: height,
                fill: colors.color,
                opacity: 0.6,
                name: 'room-fill'
            });

            // Wall outlines
            const wallThickness = CADState.wallType * 2;
            const walls = new Konva.Rect({
                x: 0,
                y: 0,
                width: width,
                height: height,
                stroke: colors.strokeColor || '#f4d03f',
                strokeWidth: wallThickness,
                name: 'room-walls'
            });

            // Room ID label
            const idLabel = new Konva.Text({
                x: 0,
                y: height / 2 - 22,
                width: width,
                text: roomId,
                fontSize: 11,
                fontFamily: 'Segoe UI, Roboto, sans-serif',
                fontStyle: 'bold',
                fill: colors.textColor,
                align: 'center',
                name: 'room-id-label'
            });

            // Room type label
            const label = new Konva.Text({
                x: 0,
                y: height / 2 - 8,
                width: width,
                text: type.toUpperCase(),
                fontSize: 12,
                fontFamily: 'Segoe UI, Roboto, sans-serif',
                fill: colors.textColor,
                align: 'center',
                name: 'room-label'
            });

            // Custom sublabel
            const displayLabel = customLabel || '';
            const sublabel = new Konva.Text({
                x: 0,
                y: height / 2 + 6,
                width: width,
                text: displayLabel,
                fontSize: 9,
                fontFamily: 'Segoe UI, Roboto, sans-serif',
                fill: colors.textColor,
                opacity: 0.7,
                align: 'center',
                name: 'room-sublabel'
            });

            roomGroup.add(roomRect);
            roomGroup.add(walls);
            roomGroup.add(idLabel);
            roomGroup.add(label);
            roomGroup.add(sublabel);

            // Store room data
            const roomData = {
                id: roomId,
                type: type,
                customLabel: customLabel,
                konvaGroup: roomGroup
            };
            CADState.rooms.push(roomData);

            // Add to layer
            CADState.layers.rooms.add(roomGroup);

            // Setup room interactions
            setupRoomInteractions(roomGroup, roomData);

            CADState.layers.rooms.batchDraw();
            updateObjectCount();
            updateObjectTree();

            return roomData;
        }

        function setupRoomInteractions(group, roomData) {
            // Double-click to edit label
            group.on('dblclick dbltap', () => {
                openRoomLabelModal(roomData);
            });

            // Drag with snap
            group.on('dragmove', () => {
                if (CADState.settings.snapEnabled) {
                    const snappedPos = snapPosition({ x: group.x(), y: group.y() });
                    group.position(snappedPos);
                    showSnapIndicator(true);
                }
            });

            group.on('dragend', () => {
                showSnapIndicator(false);
                saveHistoryState();
            });

            // Click to select
            group.on('click tap', (e) => {
                if (CADState.mode === 'select') {
                    e.cancelBubble = true;
                    selectObjects([group], e.evt.shiftKey);
                }
            });

            // Handle transformer resize
            group.on('transform', () => {
                // Update internal rect size
                const scaleX = group.scaleX();
                const scaleY = group.scaleY();
                const roomRect = group.findOne('.room-fill');
                const walls = group.findOne('.room-walls');
                const label = group.findOne('.room-label');
                const sublabel = group.findOne('.room-sublabel');

                const newWidth = roomRect.width() * scaleX;
                const newHeight = roomRect.height() * scaleY;

                // Reset scale and update dimensions
                group.scaleX(1);
                group.scaleY(1);

                roomRect.width(newWidth);
                roomRect.height(newHeight);
                walls.width(newWidth);
                walls.height(newHeight);

                // Update label positions
                const idLabel = group.findOne('.room-id-label');
                if (idLabel) {
                    idLabel.width(newWidth);
                    idLabel.y(newHeight / 2 - 22);
                }
                label.width(newWidth);
                label.y(newHeight / 2 - 8);
                sublabel.width(newWidth);
                sublabel.y(newHeight / 2 + 6);

                // Snap position
                if (CADState.settings.snapEnabled) {
                    const snappedPos = snapPosition({ x: group.x(), y: group.y() });
                    group.position(snappedPos);
                }
            });

            group.on('transformend', () => {
                saveHistoryState();
            });
        }

        function updateRoomLabel(roomData, newType, newCustomLabel) {
            const colors = ROOM_TYPES[newType] || ROOM_TYPES['Custom'];
            const group = roomData.konvaGroup;

            // Update stored data
            roomData.type = newType;
            roomData.customLabel = newCustomLabel;

            // Update visuals
            const roomRect = group.findOne('.room-fill');
            const label = group.findOne('.room-label');
            const sublabel = group.findOne('.room-sublabel');

            roomRect.fill(colors.color);
            label.fill(colors.textColor);
            label.text(newType.toUpperCase());
            sublabel.fill(colors.textColor);
            sublabel.text(newCustomLabel || newType);

            CADState.layers.rooms.batchDraw();
            updateObjectTree();
            saveHistoryState();
        }

        // ========== ROOM LABEL MODAL ==========
        function openRoomLabelModal(roomData) {
            CADState.editingRoom = roomData;
            const modal = document.getElementById('roomLabelModal');
            const modalTitle = modal.querySelector('h3');
            const typeSelect = document.getElementById('roomTypeSelect');
            const customInput = document.getElementById('roomCustomLabel');
            const dimInfo = document.getElementById('roomDimensions');

            // Update title based on whether this is a new room or editing
            const isNewRoom = roomData.type === 'Custom' && !roomData.customLabel;
            modalTitle.textContent = isNewRoom ? 'What type of room is this?' : 'Edit Room';

            // Set current values - default to Bedroom for new rooms
            typeSelect.value = isNewRoom ? 'Bedroom' : roomData.type;
            customInput.value = roomData.customLabel || '';

            // Calculate dimensions
            const roomRect = roomData.konvaGroup.findOne('.room-fill');
            const widthFt = (roomRect.width() / CADState.settings.scaleFactor).toFixed(1);
            const heightFt = (roomRect.height() / CADState.settings.scaleFactor).toFixed(1);
            const widthM = (widthFt * 0.3048).toFixed(2);
            const heightM = (heightFt * 0.3048).toFixed(2);
            dimInfo.textContent = `Size: ${widthFt}' x ${heightFt}' (${widthM}m x ${heightM}m)`;

            modal.classList.add('active');

            // Focus on the type select for quick selection
            setTimeout(() => typeSelect.focus(), 100);
        }

        function closeRoomLabelModal() {
            document.getElementById('roomLabelModal').classList.remove('active');
            CADState.editingRoom = null;
        }

        function saveRoomLabel() {
            if (!CADState.editingRoom) return;

            const newType = document.getElementById('roomTypeSelect').value;
            const newCustomLabel = document.getElementById('roomCustomLabel').value;

            updateRoomLabel(CADState.editingRoom, newType, newCustomLabel);
            closeRoomLabelModal();
        }

        // ========== WALL DRAWING ==========
        function createWall(x1, y1, x2, y2) {
            const wallId = CADState.generateId('wall');
            const wallThickness = CADState.wallType * 2;

            const wall = new Konva.Line({
                points: [x1, y1, x2, y2],
                stroke: '#f4d03f',
                strokeWidth: wallThickness,
                lineCap: 'round',
                lineJoin: 'round',
                name: 'wall',
                id: wallId,
                draggable: true
            });

            // Store wall data
            const wallData = {
                id: wallId,
                points: [x1, y1, x2, y2],
                thickness: wallThickness,
                konvaLine: wall
            };
            CADState.walls.push(wallData);

            // Add to layer
            CADState.layers.walls.add(wall);

            // Setup wall interactions
            setupWallInteractions(wall, wallData);

            CADState.layers.walls.batchDraw();
            updateObjectCount();
            updateObjectTree();

            return wallData;
        }

        function setupWallInteractions(wall, wallData) {
            wall.on('click tap', (e) => {
                if (CADState.mode === 'select') {
                    e.cancelBubble = true;
                    selectObjects([wall], e.evt.shiftKey);
                }
            });

            wall.on('dragmove', () => {
                if (CADState.settings.snapEnabled) {
                    const snappedPos = snapPosition({ x: wall.x(), y: wall.y() });
                    wall.position(snappedPos);
                    showSnapIndicator(true);
                }
            });

            wall.on('dragend', () => {
                showSnapIndicator(false);
                // Update stored points
                const points = wall.points();
                wallData.points = [
                    points[0] + wall.x(),
                    points[1] + wall.y(),
                    points[2] + wall.x(),
                    points[3] + wall.y()
                ];
                saveHistoryState();
            });
        }

        function startWallDrawing(pos) {
            const snapped = snapPosition(pos);
            CADState.drawing.wallStartPoint = snapped;

            // Create preview line
            CADState.drawing.preview = new Konva.Line({
                points: [snapped.x, snapped.y, snapped.x, snapped.y],
                stroke: '#f4d03f',
                strokeWidth: CADState.wallType * 2,
                lineCap: 'round',
                dash: [5, 5],
                name: 'wall-preview'
            });
            CADState.layers.ui.add(CADState.drawing.preview);
        }

        function updateWallPreview(pos, constrained) {
            if (!CADState.drawing.preview || !CADState.drawing.wallStartPoint) return;

            let endPos = snapPosition(pos);

            // Constrain to horizontal/vertical if shift is held
            if (constrained) {
                const start = CADState.drawing.wallStartPoint;
                const dx = Math.abs(endPos.x - start.x);
                const dy = Math.abs(endPos.y - start.y);
                if (dx > dy) {
                    endPos.y = start.y;
                } else {
                    endPos.x = start.x;
                }
            }

            CADState.drawing.preview.points([
                CADState.drawing.wallStartPoint.x,
                CADState.drawing.wallStartPoint.y,
                endPos.x,
                endPos.y
            ]);
            CADState.layers.ui.batchDraw();
            showSnapIndicator(true);
        }

        function finishWallDrawing(pos, constrained) {
            if (!CADState.drawing.wallStartPoint) return;

            let endPos = snapPosition(pos);

            // Constrain to horizontal/vertical if shift is held
            if (constrained) {
                const start = CADState.drawing.wallStartPoint;
                const dx = Math.abs(endPos.x - start.x);
                const dy = Math.abs(endPos.y - start.y);
                if (dx > dy) {
                    endPos.y = start.y;
                } else {
                    endPos.x = start.x;
                }
            }

            // Create the actual wall
            createWall(
                CADState.drawing.wallStartPoint.x,
                CADState.drawing.wallStartPoint.y,
                endPos.x,
                endPos.y
            );

            // Clean up preview
            if (CADState.drawing.preview) {
                CADState.drawing.preview.destroy();
                CADState.drawing.preview = null;
            }
            CADState.drawing.wallStartPoint = null;
            CADState.layers.ui.batchDraw();
            showSnapIndicator(false);
            saveHistoryState();
        }

        function cancelWallDrawing() {
            if (CADState.drawing.preview) {
                CADState.drawing.preview.destroy();
                CADState.drawing.preview = null;
            }
            CADState.drawing.wallStartPoint = null;
            CADState.layers.ui.batchDraw();
            showSnapIndicator(false);
        }

        // ========== FURNITURE CREATION ==========
        function createFurniture(type, x, y, rotation = 0) {
            const furnitureId = CADState.generateId('furniture');
            let group;

            switch (type) {
                case 'bed': group = createBedShape(80, 60); break;
                case 'sofa': group = createSofaShape(80, 30); break;
                case 'table': group = createTableShape(40, 25); break;
                case 'chair': group = createChairShape(20, 20); break;
                case 'toilet': group = createToiletShape(25, 30); break;
                case 'sink': group = createSinkShape(30, 25); break;
                case 'stove': group = createStoveShape(40, 30); break;
                case 'fridge': group = createFridgeShape(30, 50); break;
                case 'washer': group = createWasherShape(30, 30); break;
                default: group = createTableShape(40, 25);
            }

            // Position and configure
            const snapped = snapPosition({ x, y });
            group.position(snapped);
            group.rotation(rotation);
            group.id(furnitureId);
            group.name('furniture-group');
            group.draggable(true);

            // Store furniture data
            const furnitureData = {
                id: furnitureId,
                type: type,
                rotation: rotation,
                konvaGroup: group
            };
            CADState.furniture.push(furnitureData);

            // Add to layer
            CADState.layers.furniture.add(group);

            // Setup interactions
            setupFurnitureInteractions(group, furnitureData);

            CADState.layers.furniture.batchDraw();
            updateObjectCount();
            updateObjectTree();

            return furnitureData;
        }

        function setupFurnitureInteractions(group, furnitureData) {
            group.on('click tap', (e) => {
                if (CADState.mode === 'select') {
                    e.cancelBubble = true;
                    selectObjects([group], e.evt.shiftKey);
                }
            });

            group.on('dragmove', () => {
                if (CADState.settings.snapEnabled) {
                    const snappedPos = snapPosition({ x: group.x(), y: group.y() });
                    group.position(snappedPos);
                    showSnapIndicator(true);
                }
            });

            group.on('dragend', () => {
                showSnapIndicator(false);
                saveHistoryState();
            });

            group.on('transform', () => {
                furnitureData.rotation = group.rotation();
            });

            group.on('transformend', () => {
                saveHistoryState();
            });
        }

        // Furniture shape creators
        function createBedShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#2a3a4a', cornerRadius: 3
            }));
            group.add(new Konva.Rect({
                x: -w/2 + 5, y: -h/2 + 5, width: w - 10, height: 12,
                stroke: '#666', strokeWidth: 1, fill: '#3a4a5a', cornerRadius: 2
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'BED',
                fontSize: 8, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createSofaShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#3a4a3a', cornerRadius: 4
            }));
            group.add(new Konva.Rect({
                x: -w/2 + 3, y: -h/2 + 3, width: w - 6, height: 8,
                stroke: '#666', strokeWidth: 1, fill: '#4a5a4a', cornerRadius: 2
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'SOFA',
                fontSize: 8, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createTableShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1, fill: '#4a4030'
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'TABLE',
                fontSize: 7, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createChairShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1, fill: '#4a4030'
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'CHR',
                fontSize: 7, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createToiletShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Ellipse({
                x: 0, y: 5,
                radiusX: w / 2 - 2, radiusY: h / 3,
                stroke: '#888', strokeWidth: 1.5, fill: '#e8e8e8'
            }));
            group.add(new Konva.Rect({
                x: -w/2 + 2, y: -h/2, width: w - 4, height: h / 3,
                stroke: '#888', strokeWidth: 1.5, fill: '#e8e8e8', cornerRadius: 2
            }));
            group.add(new Konva.Text({
                x: -w/2 - 5, y: h/2 + 3, width: w + 10, text: 'WC',
                fontSize: 8, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createSinkShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#2a3a4a', cornerRadius: 3
            }));
            group.add(new Konva.Circle({
                x: 0, y: 0, radius: 4,
                stroke: '#666', strokeWidth: 1
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'SINK',
                fontSize: 7, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createStoveShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#3a3a3a'
            }));
            const burnerSize = 8;
            const positions = [[-w/4, -h/4], [w/4, -h/4], [-w/4, h/4], [w/4, h/4]];
            positions.forEach(pos => {
                group.add(new Konva.Circle({
                    x: pos[0], y: pos[1], radius: burnerSize / 2,
                    stroke: '#ff6b6b', strokeWidth: 1.5
                }));
            });
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'STOVE',
                fontSize: 8, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createFridgeShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#e8e8e8'
            }));
            group.add(new Konva.Line({
                points: [-w/2, -h/2 + h * 0.4, w/2, -h/2 + h * 0.4],
                stroke: '#666', strokeWidth: 1
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'FRIG',
                fontSize: 7, fill: '#666', align: 'center'
            }));
            return group;
        }

        function createWasherShape(w, h) {
            const group = new Konva.Group();
            group.add(new Konva.Rect({
                x: -w/2, y: -h/2, width: w, height: h,
                stroke: '#888', strokeWidth: 1.5, fill: '#e8e8e8', cornerRadius: 3
            }));
            group.add(new Konva.Circle({
                x: 0, y: 0, radius: 10,
                stroke: '#666', strokeWidth: 1
            }));
            group.add(new Konva.Text({
                x: -w/2, y: h/2 + 3, width: w, text: 'WASH',
                fontSize: 7, fill: '#666', align: 'center'
            }));
            return group;
        }

        // Rotate selected furniture
        function rotateSelectedFurniture() {
            CADState.selection.forEach(obj => {
                if (obj.hasName('furniture-group')) {
                    obj.rotation((obj.rotation() + 90) % 360);
                    // Update data
                    const data = CADState.furniture.find(f => f.id === obj.id());
                    if (data) data.rotation = obj.rotation();
                }
            });
            CADState.layers.furniture.batchDraw();
            saveHistoryState();
        }

        // ========== DIMENSION LINES ==========
        function createDimensionAnnotation(x1, y1, x2, y2) {
            const dimColor = '#ff4444';
            const tickSize = 5;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const lengthFt = (length / CADState.settings.scaleFactor).toFixed(1);
            const lengthM = (lengthFt * 0.3048).toFixed(2);
            const text = `${lengthFt}' (${lengthM}m)`;

            const group = new Konva.Group({
                draggable: true,
                name: 'dimension-group'
            });

            // Determine orientation
            const isHorizontal = Math.abs(dx) > Math.abs(dy);

            // Main dimension line
            group.add(new Konva.Line({
                points: [x1, y1, x2, y2],
                stroke: dimColor,
                strokeWidth: 1
            }));

            // Tick marks
            if (isHorizontal) {
                group.add(new Konva.Line({
                    points: [x1, y1 - tickSize, x1, y1 + tickSize],
                    stroke: dimColor, strokeWidth: 1
                }));
                group.add(new Konva.Line({
                    points: [x2, y2 - tickSize, x2, y2 + tickSize],
                    stroke: dimColor, strokeWidth: 1
                }));
                group.add(new Konva.Text({
                    x: (x1 + x2) / 2 - 30, y: y1 - 14,
                    text: text, fontSize: 9, fill: dimColor,
                    fontFamily: 'Segoe UI, sans-serif'
                }));
            } else {
                group.add(new Konva.Line({
                    points: [x1 - tickSize, y1, x1 + tickSize, y1],
                    stroke: dimColor, strokeWidth: 1
                }));
                group.add(new Konva.Line({
                    points: [x2 - tickSize, y2, x2 + tickSize, y2],
                    stroke: dimColor, strokeWidth: 1
                }));
                group.add(new Konva.Text({
                    x: x1 - 14, y: (y1 + y2) / 2,
                    text: text, fontSize: 9, fill: dimColor,
                    fontFamily: 'Segoe UI, sans-serif',
                    rotation: -90
                }));
            }

            CADState.layers.annotations.add(group);

            group.on('click tap', (e) => {
                if (CADState.mode === 'select') {
                    e.cancelBubble = true;
                    selectObjects([group], e.evt.shiftKey);
                }
            });

            CADState.layers.annotations.batchDraw();
            updateObjectCount();
            return group;
        }

        // ========== NORTH ARROW ==========
        function drawNorthArrow() {
            const stage = CADState.stage;
            const arrowX = stage.width() - 60;
            const arrowY = 60;

            const northGroup = new Konva.Group({
                x: arrowX,
                y: arrowY,
                rotation: CADState.northArrowAngle,
                draggable: true,
                name: 'north-arrow'
            });

            northGroup.add(new Konva.Circle({
                radius: 25,
                stroke: '#f4d03f',
                strokeWidth: 2,
                fill: 'rgba(58, 58, 58, 0.8)'
            }));

            northGroup.add(new Konva.Line({
                points: [0, 15, 0, -15],
                stroke: '#f4d03f',
                strokeWidth: 2
            }));
            northGroup.add(new Konva.Line({
                points: [-6, -8, 0, -15, 6, -8],
                stroke: '#f4d03f',
                strokeWidth: 2,
                closed: true,
                fill: '#f4d03f'
            }));

            northGroup.add(new Konva.Text({
                x: -5,
                y: -28,
                text: 'N',
                fontSize: 14,
                fontStyle: 'bold',
                fill: '#fff'
            }));

            // Click to rotate compass 45 degrees
            northGroup.on('click tap', (e) => {
                e.cancelBubble = true; // Prevent selection
                CADState.northArrowAngle = (CADState.northArrowAngle + 45) % 360;
                northGroup.rotation(CADState.northArrowAngle);
                CADState.layers.ui.batchDraw();
            });

            CADState.layers.ui.add(northGroup);
            CADState.layers.ui.batchDraw();
        }

        // ========== EVENT HANDLERS ==========
        function setupEventHandlers() {
            const stage = CADState.stage;

            // Mouse position tracking
            stage.on('mousemove touchmove', (e) => {
                const pos = stage.getPointerPosition();
                if (pos) {
                    const stagePos = getStagePointerPosition();
                    document.getElementById('mousePos').textContent =
                        `X: ${Math.round(stagePos.x)}, Y: ${Math.round(stagePos.y)}`;

                    // Handle drawing modes
                    if (CADState.drawing.isDrawing) {
                        handleDrawingMove(stagePos, e.evt.shiftKey);
                    }

                    // Update wall preview
                    if (CADState.mode === 'wall' && CADState.drawing.wallStartPoint) {
                        updateWallPreview(stagePos, e.evt.shiftKey);
                    }
                }
            });

            // Mouse down
            stage.on('mousedown touchstart', (e) => {
                const pos = getStagePointerPosition();

                if (CADState.mode === 'room') {
                    startRoomDrawing(pos);
                } else if (CADState.mode === 'wall') {
                    if (!CADState.drawing.wallStartPoint) {
                        startWallDrawing(pos);
                    }
                } else if (CADState.mode === 'draw') {
                    CADState.drawing.isDrawing = true;
                    CADState.drawing.startPos = pos;
                }
            });

            // Mouse up
            stage.on('mouseup touchend', (e) => {
                const pos = getStagePointerPosition();

                if (CADState.mode === 'room' && CADState.drawing.isDrawing) {
                    finishRoomDrawing(pos);
                } else if (CADState.mode === 'wall' && CADState.drawing.wallStartPoint) {
                    finishWallDrawing(pos, e.evt?.shiftKey);
                } else if (CADState.mode === 'draw') {
                    CADState.drawing.isDrawing = false;
                    CADState.drawing.startPos = null;
                    saveHistoryState();
                }
            });

            // Click for selection or object placement
            stage.on('click tap', (e) => {
                const pos = getStagePointerPosition();

                if (CADState.mode === 'select' && e.target === stage) {
                    deselectAll();
                } else if (CADState.mode === 'place' && e.target === stage) {
                    // Sims-style room placement
                    placeRoomBlock(pos);
                } else if (CADState.mode === 'door' && e.target === stage) {
                    createDoor(pos.x, pos.y);
                    saveHistoryState();
                } else if (CADState.mode === 'window' && e.target === stage) {
                    createWindow(pos.x, pos.y);
                    saveHistoryState();
                } else if (CADState.mode === 'observation' && e.target === stage) {
                    createObservation(pos.x, pos.y);
                    saveHistoryState();
                } else if (CADState.mode === 'sample' && e.target === stage) {
                    createSample(pos.x, pos.y);
                    saveHistoryState();
                } else if (CADState.mode === 'photo' && e.target === stage) {
                    createPhotoMarker(pos.x, pos.y);
                    saveHistoryState();
                } else if (['radiator', 'riser', 'baseboard', 'trim', 'chairrail', 'crown', 'cabinet', 'stairs', 'railing', 'pipe'].includes(CADState.mode) && e.target === stage) {
                    createComponent(CADState.mode, pos.x, pos.y);
                    saveHistoryState();
                }
            });

            // Zoom with scroll
            stage.on('wheel', (e) => {
                e.evt.preventDefault();
                const oldScale = stage.scaleX();
                const pointer = stage.getPointerPosition();

                const scaleBy = 1.1;
                let newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;
                newScale = Math.max(0.1, Math.min(5, newScale)); // Clamp zoom

                stage.scale({ x: newScale, y: newScale });

                const newPos = {
                    x: pointer.x - (pointer.x - stage.x()) * (newScale / oldScale),
                    y: pointer.y - (pointer.y - stage.y()) * (newScale / oldScale)
                };
                stage.position(newPos);

                document.getElementById('zoomLevel').textContent = Math.round(newScale * 100) + '%';
            });

            // Responsive resize
            window.addEventListener('resize', () => {
                const container = document.getElementById('blueprint-container');
                stage.width(container.offsetWidth);
                stage.height(container.offsetHeight);
                drawGrid();
            });
        }

        function getStagePointerPosition() {
            const stage = CADState.stage;
            const pointer = stage.getPointerPosition();
            if (!pointer) return { x: 0, y: 0 };
            const transform = stage.getAbsoluteTransform().copy().invert();
            return transform.point(pointer);
        }

        // ========== ROOM DRAWING MODE ==========
        function startRoomDrawing(pos) {
            const snapped = snapPosition(pos);
            CADState.drawing.isDrawing = true;
            CADState.drawing.startPos = snapped;

            // Create preview rectangle
            CADState.drawing.preview = new Konva.Rect({
                x: snapped.x,
                y: snapped.y,
                width: 0,
                height: 0,
                stroke: '#f4d03f',
                strokeWidth: 2,
                dash: [5, 5],
                name: 'room-preview'
            });
            CADState.layers.ui.add(CADState.drawing.preview);
        }

        function updateRoomPreview(pos) {
            if (!CADState.drawing.preview || !CADState.drawing.startPos) return;

            const snapped = snapPosition(pos);
            const start = CADState.drawing.startPos;

            const x = Math.min(start.x, snapped.x);
            const y = Math.min(start.y, snapped.y);
            const width = Math.abs(snapped.x - start.x);
            const height = Math.abs(snapped.y - start.y);

            CADState.drawing.preview.setAttrs({ x, y, width, height });
            CADState.layers.ui.batchDraw();
            showSnapIndicator(true);
        }

        function finishRoomDrawing(pos) {
            if (!CADState.drawing.startPos) return;

            const snapped = snapPosition(pos);
            const start = CADState.drawing.startPos;

            const x = Math.min(start.x, snapped.x);
            const y = Math.min(start.y, snapped.y);
            const width = Math.abs(snapped.x - start.x);
            const height = Math.abs(snapped.y - start.y);

            // Minimum size validation - require deliberate drag (at least 40px in each direction)
            const minRoomSize = 40;
            if (width >= minRoomSize && height >= minRoomSize) {
                // Create room with temporary "Custom" type, then open dialog to assign type
                const roomData = createRoom(x, y, width, height, 'Custom');
                saveHistoryState();

                // Immediately open the label dialog so user can assign a room type
                openRoomLabelModal(roomData);

                // Switch back to select mode after creating a room to prevent accidental creation
                setTool('select');
            }

            // Clean up
            if (CADState.drawing.preview) {
                CADState.drawing.preview.destroy();
                CADState.drawing.preview = null;
            }
            CADState.drawing.isDrawing = false;
            CADState.drawing.startPos = null;
            CADState.layers.ui.batchDraw();
            showSnapIndicator(false);
        }

        function handleDrawingMove(pos, shiftKey) {
            if (CADState.mode === 'room') {
                updateRoomPreview(pos);
            } else if (CADState.mode === 'draw' && CADState.drawing.startPos) {
                handleFreehandDraw(pos);
            }
        }

        function handleFreehandDraw(pos) {
            const start = CADState.drawing.startPos;
            if (!start) return;

            CADState.layers.annotations.add(new Konva.Line({
                points: [start.x, start.y, pos.x, pos.y],
                stroke: '#f4d03f',
                strokeWidth: 2,
                lineCap: 'round',
                lineJoin: 'round',
                name: 'freehand'
            }));
            CADState.layers.annotations.batchDraw();
            CADState.drawing.startPos = pos;
            updateObjectCount();
        }

        // ========== TOOL FUNCTIONS ==========
        function setTool(tool) {
            // Cancel any current drawing operation
            cancelCurrentOperation();

            // Clear room palette selection when switching away from place mode
            if (tool !== 'place') {
                clearRoomSelection();
            }

            CADState.mode = tool;
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tool-icon').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.component-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.assessment-btn').forEach(btn => btn.classList.remove('active'));

            const btn = document.getElementById(tool + 'Btn');
            if (btn) btn.classList.add('active');

            // Tool-specific button activation
            if (tool === 'room') document.getElementById('roomToolBtn')?.classList.add('active');
            if (tool === 'wall') document.getElementById('wallToolBtn')?.classList.add('active');

            const toolNames = {
                'select': 'Select',
                'room': 'Draw Room',
                'wall': 'Draw Wall',
                'draw': 'Freehand',
                'place': 'Place ' + (CADState.selectedRoomType || 'Room'),
                'door': 'Place Door',
                'window': 'Place Window',
                'passthrough': 'Place Pass-through',
                'observation': 'Place Observation',
                'sample': 'Place Sample',
                'photo': 'Place Photo',
                'radiator': 'Place Radiator',
                'riser': 'Place Riser',
                'baseboard': 'Place Baseboard',
                'trim': 'Place Trim',
                'chairrail': 'Place Chair Rail',
                'crown': 'Place Crown',
                'cabinet': 'Place Cabinet',
                'stairs': 'Place Stairs',
                'railing': 'Place Railing',
                'pipe': 'Place Pipe'
            };
            document.getElementById('currentTool').textContent = toolNames[tool] || tool;

            // Only allow panning in select mode
            CADState.stage.draggable(tool === 'select');

            // Deselect when switching tools
            if (tool !== 'select') {
                deselectAll();
            }
        }

        function cancelCurrentOperation() {
            if (CADState.drawing.preview) {
                CADState.drawing.preview.destroy();
                CADState.drawing.preview = null;
            }
            CADState.drawing.isDrawing = false;
            CADState.drawing.startPos = null;
            CADState.drawing.wallStartPoint = null;
            CADState.layers.ui.batchDraw();
            showSnapIndicator(false);
        }

        function setWallType(type) {
            CADState.wallType = type;
            // Update wall type buttons
            document.querySelectorAll('.wall-type').forEach(el => el.classList.remove('active'));
            const wallTypeEl = document.querySelector(`.wall-type-${type}`);
            if (wallTypeEl) wallTypeEl.classList.add('active');
        }

        function setAnnotation(type) {
            CADState.mode = 'annotation-' + type;
            document.getElementById('currentTool').textContent = type.charAt(0).toUpperCase() + type.slice(1);
        }

        function toggleGrid() {
            CADState.settings.showGrid = !CADState.settings.showGrid;
            drawGrid();
        }

        function zoomIn() {
            const stage = CADState.stage;
            const newScale = Math.min(5, stage.scaleX() * 1.2);
            stage.scale({ x: newScale, y: newScale });
            document.getElementById('zoomLevel').textContent = Math.round(newScale * 100) + '%';
        }

        function zoomOut() {
            const stage = CADState.stage;
            const newScale = Math.max(0.1, stage.scaleX() / 1.2);
            stage.scale({ x: newScale, y: newScale });
            document.getElementById('zoomLevel').textContent = Math.round(newScale * 100) + '%';
        }

        function resetView() {
            const stage = CADState.stage;
            stage.scale({ x: 1, y: 1 });
            stage.position({ x: 0, y: 0 });
            document.getElementById('zoomLevel').textContent = '100%';
        }

        function changeLevel(delta) {
            CADState.level = Math.max(1, Math.min(10, CADState.level + delta));
            const levelNames = ['', 'Ground', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th', '9th', '10th'];
            document.getElementById('levelDisplay').textContent = `Level ${CADState.level} (${levelNames[CADState.level]})`;
        }

        // ========== SELECTION SYSTEM ==========
        function selectObjects(objects, addToSelection = false) {
            if (!addToSelection) {
                CADState.selection = [];
            }

            objects.forEach(obj => {
                if (!CADState.selection.includes(obj)) {
                    CADState.selection.push(obj);
                }
            });

            // Update transformer
            CADState.transformer.nodes(CADState.selection);
            CADState.layers.ui.batchDraw();
        }

        function deselectAll() {
            CADState.selection = [];
            CADState.transformer.nodes([]);
            CADState.layers.ui.batchDraw();
        }

        function deleteSelected() {
            if (CADState.selection.length === 0) return;

            CADState.selection.forEach(obj => {
                const id = obj.id();

                // Remove from all data arrays
                CADState.rooms = CADState.rooms.filter(r => r.id !== id);
                CADState.walls = CADState.walls.filter(w => w.id !== id);
                CADState.furniture = CADState.furniture.filter(f => f.id !== id);
                CADState.openings = CADState.openings.filter(o => o.id !== id);
                CADState.components = CADState.components.filter(c => c.id !== id);
                CADState.observations = CADState.observations.filter(o => o.id !== id);
                CADState.samples = CADState.samples.filter(s => s.id !== id);
                CADState.photos = CADState.photos.filter(p => p.id !== id);

                // Destroy Konva object
                obj.destroy();
            });

            CADState.selection = [];
            CADState.transformer.nodes([]);

            // Redraw all layers
            Object.values(CADState.layers).forEach(layer => layer.batchDraw());
            updateObjectCount();
            updateObjectTree();
            updateAssessmentLists();
            runQAValidation();
            saveHistoryState();
        }

        function copySelected() {
            if (CADState.selection.length === 0) return;

            const newSelection = [];

            CADState.selection.forEach(obj => {
                if (obj.hasName('room-group')) {
                    const data = CADState.rooms.find(r => r.id === obj.id());
                    if (data) {
                        const roomRect = obj.findOne('.room-fill');
                        const newRoom = createRoom(
                            obj.x() + 20,
                            obj.y() + 20,
                            roomRect.width(),
                            roomRect.height(),
                            data.type,
                            data.customLabel
                        );
                        newSelection.push(newRoom.konvaGroup);
                    }
                } else if (obj.hasName('furniture-group')) {
                    const data = CADState.furniture.find(f => f.id === obj.id());
                    if (data) {
                        const newFurniture = createFurniture(
                            data.type,
                            obj.x() + 20,
                            obj.y() + 20,
                            data.rotation
                        );
                        newSelection.push(newFurniture.konvaGroup);
                    }
                }
            });

            if (newSelection.length > 0) {
                selectObjects(newSelection);
                saveHistoryState();
            }
        }

        // ========== FEATURE/ICON ADDING ==========
        function addFeature(type) {
            const stage = CADState.stage;
            const center = getStagePointerPosition() || { x: stage.width() / 2, y: stage.height() / 2 };
            const snapped = snapPosition(center);

            const featureId = CADState.generateId('feature');
            let feature;

            switch (type) {
                case 'door':
                    feature = new Konva.Group({ x: snapped.x, y: snapped.y, draggable: true, name: 'feature-group', id: featureId });
                    feature.add(new Konva.Arc({
                        innerRadius: 0, outerRadius: 30,
                        angle: 90, stroke: '#f4d03f',
                        strokeWidth: 1.5, dash: [4, 2]
                    }));
                    feature.add(new Konva.Line({
                        points: [0, 0, 30, 0],
                        stroke: '#f4d03f', strokeWidth: 2
                    }));
                    break;
                case 'window':
                    feature = new Konva.Rect({
                        x: snapped.x - 20, y: snapped.y - 5,
                        width: 40, height: 10,
                        stroke: '#f4d03f', strokeWidth: 2,
                        fill: 'rgba(244, 208, 63, 0.3)', opacity: 0.5,
                        draggable: true, name: 'feature-group', id: featureId
                    });
                    break;
                case 'stairs':
                    feature = new Konva.Group({ x: snapped.x, y: snapped.y, draggable: true, name: 'feature-group', id: featureId });
                    for (let i = 0; i < 8; i++) {
                        feature.add(new Konva.Line({
                            points: [-15, i * 5 - 20, 15, i * 5 - 20],
                            stroke: '#888', strokeWidth: 1
                        }));
                    }
                    feature.add(new Konva.Rect({
                        x: -15, y: -20, width: 30, height: 40,
                        stroke: '#888', strokeWidth: 1.5
                    }));
                    break;
                case 'column':
                    feature = new Konva.Rect({
                        x: snapped.x - 10, y: snapped.y - 10,
                        width: 20, height: 20,
                        fill: '#666', stroke: '#888',
                        strokeWidth: 2, draggable: true,
                        name: 'feature-group', id: featureId
                    });
                    break;
            }

            if (feature) {
                CADState.layers.furniture.add(feature);
                setupGenericInteractions(feature);
                CADState.layers.furniture.batchDraw();
                updateObjectCount();
                saveHistoryState();
            }
        }

        function addIcon(type) {
            const stage = CADState.stage;
            const center = getStagePointerPosition() || { x: stage.width() / 2, y: stage.height() / 2 };
            const snapped = snapPosition(center);

            const iconId = CADState.generateId('icon');
            const iconGroup = new Konva.Group({ x: snapped.x, y: snapped.y, draggable: true, name: 'icon-group', id: iconId });

            switch (type) {
                case 'radiator':
                    iconGroup.add(new Konva.Rect({ x: -20, y: -10, width: 40, height: 20, stroke: '#ff6b6b', strokeWidth: 1.5 }));
                    for (let i = -15; i <= 15; i += 10) {
                        iconGroup.add(new Konva.Line({ points: [i, -8, i, 8], stroke: '#ff6b6b', strokeWidth: 1 }));
                    }
                    break;
                case 'pipe':
                    iconGroup.add(new Konva.Line({ points: [-20, 0, -10, -10, 0, 10, 10, -10, 20, 0], stroke: '#f4d03f', strokeWidth: 2 }));
                    break;
                case 'riser':
                    iconGroup.add(new Konva.Circle({ radius: 15, stroke: '#f4d03f', strokeWidth: 1.5 }));
                    iconGroup.add(new Konva.Line({ points: [0, -10, 0, 10], stroke: '#f4d03f', strokeWidth: 2 }));
                    iconGroup.add(new Konva.Line({ points: [-5, 5, 0, 10, 5, 5], stroke: '#f4d03f', strokeWidth: 2 }));
                    break;
                case 'vent':
                    iconGroup.add(new Konva.Rect({ x: -15, y: -8, width: 30, height: 16, stroke: '#888', strokeWidth: 1.5 }));
                    for (let i = -10; i <= 10; i += 5) {
                        iconGroup.add(new Konva.Line({ points: [i, -6, i, 6], stroke: '#888', strokeWidth: 1 }));
                    }
                    break;
            }

            CADState.layers.furniture.add(iconGroup);
            setupGenericInteractions(iconGroup);
            CADState.layers.furniture.batchDraw();
            updateObjectCount();
            saveHistoryState();
        }

        function addSymbol(type) {
            const stage = CADState.stage;
            const center = getStagePointerPosition() || { x: stage.width() / 2, y: stage.height() / 2 };
            createFurniture(type, center.x, center.y);
            saveHistoryState();
        }

        function setupGenericInteractions(obj) {
            obj.on('click tap', (e) => {
                if (CADState.mode === 'select') {
                    e.cancelBubble = true;
                    selectObjects([obj], e.evt.shiftKey);
                }
            });

            obj.on('dragmove', () => {
                if (CADState.settings.snapEnabled) {
                    const snappedPos = snapPosition({ x: obj.x(), y: obj.y() });
                    obj.position(snappedPos);
                    showSnapIndicator(true);
                }
            });

            obj.on('dragend', () => {
                showSnapIndicator(false);
                saveHistoryState();
            });
        }

        // ========== UNDO/REDO SYSTEM ==========
        function saveHistoryState() {
            // Capture current state
            const state = {
                rooms: CADState.rooms.map(r => ({
                    id: r.id,
                    type: r.type,
                    customLabel: r.customLabel,
                    x: r.konvaGroup.x(),
                    y: r.konvaGroup.y(),
                    width: r.konvaGroup.findOne('.room-fill').width(),
                    height: r.konvaGroup.findOne('.room-fill').height()
                })),
                walls: CADState.walls.map(w => ({
                    id: w.id,
                    points: w.points,
                    thickness: w.thickness
                })),
                furniture: CADState.furniture.map(f => ({
                    id: f.id,
                    type: f.type,
                    x: f.konvaGroup.x(),
                    y: f.konvaGroup.y(),
                    rotation: f.rotation
                }))
            };

            // Add to undo stack
            CADState.history.undoStack.push(JSON.stringify(state));

            // Limit stack size
            if (CADState.history.undoStack.length > CADState.history.maxHistory) {
                CADState.history.undoStack.shift();
            }

            // Clear redo stack on new action
            CADState.history.redoStack = [];
        }

        function undo() {
            if (CADState.history.undoStack.length <= 1) return; // Keep at least one state

            // Move current state to redo
            const currentState = CADState.history.undoStack.pop();
            CADState.history.redoStack.push(currentState);

            // Restore previous state
            const previousState = CADState.history.undoStack[CADState.history.undoStack.length - 1];
            if (previousState) {
                restoreState(JSON.parse(previousState));
            }
        }

        function redo() {
            if (CADState.history.redoStack.length === 0) return;

            const nextState = CADState.history.redoStack.pop();
            CADState.history.undoStack.push(nextState);
            restoreState(JSON.parse(nextState));
        }

        function restoreState(state) {
            // Clear current objects
            CADState.rooms.forEach(r => r.konvaGroup.destroy());
            CADState.walls.forEach(w => w.konvaLine.destroy());
            CADState.furniture.forEach(f => f.konvaGroup.destroy());

            CADState.rooms = [];
            CADState.walls = [];
            CADState.furniture = [];

            // Restore rooms
            state.rooms.forEach(r => {
                createRoom(r.x, r.y, r.width, r.height, r.type, r.customLabel);
            });

            // Restore walls
            state.walls.forEach(w => {
                createWall(w.points[0], w.points[1], w.points[2], w.points[3]);
            });

            // Restore furniture
            state.furniture.forEach(f => {
                createFurniture(f.type, f.x, f.y, f.rotation);
            });

            deselectAll();
            updateObjectTree();
        }

        // ========== SAVE/LOAD ==========
        function saveToStorage() {
            try {
                const data = {
                    version: 3,
                    rooms: CADState.rooms.map(r => ({
                        id: r.id,
                        type: r.type,
                        customLabel: r.customLabel,
                        x: r.konvaGroup.x(),
                        y: r.konvaGroup.y(),
                        width: r.konvaGroup.findOne('.room-fill').width(),
                        height: r.konvaGroup.findOne('.room-fill').height()
                    })),
                    walls: CADState.walls.map(w => ({
                        id: w.id,
                        points: w.points,
                        thickness: w.thickness
                    })),
                    furniture: CADState.furniture.map(f => ({
                        id: f.id,
                        type: f.type,
                        x: f.konvaGroup.x(),
                        y: f.konvaGroup.y(),
                        rotation: f.rotation
                    })),
                    openings: CADState.openings.map(o => ({
                        id: o.id,
                        type: o.id.startsWith('D-') ? 'door' : 'window',
                        wallId: o.wallId,
                        width: o.width,
                        swingDirection: o.swingDirection,
                        swingInOut: o.swingInOut,
                        arcVisible: o.arcVisible,
                        sillHeight: o.sillHeight,
                        hasStool: o.hasStool,
                        hasApron: o.hasApron,
                        hasWell: o.hasWell,
                        x: o.konvaGroup.x(),
                        y: o.konvaGroup.y()
                    })),
                    components: CADState.components.map(c => ({
                        id: c.id,
                        type: c.type,
                        wallId: c.wallId,
                        x: c.konvaGroup.x(),
                        y: c.konvaGroup.y()
                    })),
                    observations: CADState.observations.map(o => ({
                        id: o.id,
                        conditionCode: o.conditionCode,
                        priority: o.priority,
                        description: o.description,
                        photoLinks: o.photoLinks,
                        roomId: o.roomId,
                        x: o.konvaGroup.x(),
                        y: o.konvaGroup.y()
                    })),
                    samples: CADState.samples.map(s => ({
                        id: s.id,
                        method: s.method,
                        target: s.target,
                        result: s.result,
                        notes: s.notes,
                        x: s.konvaGroup.x(),
                        y: s.konvaGroup.y()
                    })),
                    photos: CADState.photos.map(p => ({
                        id: p.id,
                        direction: p.direction,
                        caption: p.caption,
                        linkedObsIds: p.linkedObsIds,
                        x: p.konvaGroup.x(),
                        y: p.konvaGroup.y()
                    })),
                    counters: CADState.counters,
                    viewState: {
                        scale: CADState.stage.scaleX(),
                        x: CADState.stage.x(),
                        y: CADState.stage.y()
                    },
                    northArrowAngle: CADState.northArrowAngle,
                    level: CADState.level,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem('cad-blueprint-data-v3', JSON.stringify(data));
                alert('Assessment saved successfully!');
            } catch (e) {
                console.error('Save failed:', e);
                alert('Save failed: ' + e.message);
            }
        }

        function loadFromStorage(silent = false) {
            try {
                // Try v3 format first, then v2
                let saved = localStorage.getItem('cad-blueprint-data-v3') || localStorage.getItem('cad-blueprint-data-v2');
                let data;

                if (saved) {
                    data = JSON.parse(saved);
                } else {
                    saved = localStorage.getItem('cad-blueprint-data');
                    if (saved) {
                        const v1Data = JSON.parse(saved);
                        CADState.northArrowAngle = v1Data.northArrowAngle || 0;
                        CADState.level = v1Data.currentLevel || 1;
                        if (!silent) alert('Migrated settings from old save format.');
                        return;
                    }
                    return;
                }

                // Clear all existing objects
                CADState.rooms.forEach(r => r.konvaGroup.destroy());
                CADState.walls.forEach(w => w.konvaLine.destroy());
                CADState.furniture.forEach(f => f.konvaGroup.destroy());
                CADState.openings.forEach(o => o.konvaGroup.destroy());
                CADState.components.forEach(c => c.konvaGroup.destroy());
                CADState.observations.forEach(o => o.konvaGroup.destroy());
                CADState.samples.forEach(s => s.konvaGroup.destroy());
                CADState.photos.forEach(p => p.konvaGroup.destroy());

                CADState.rooms = [];
                CADState.walls = [];
                CADState.furniture = [];
                CADState.openings = [];
                CADState.components = [];
                CADState.observations = [];
                CADState.samples = [];
                CADState.photos = [];

                // Restore counters if available
                if (data.counters) {
                    CADState.counters = data.counters;
                }

                // Restore rooms
                if (data.rooms) {
                    data.rooms.forEach(r => {
                        createRoom(r.x, r.y, r.width, r.height, r.type, r.customLabel);
                    });
                }

                // Restore walls
                if (data.walls) {
                    data.walls.forEach(w => {
                        createWall(w.points[0], w.points[1], w.points[2], w.points[3]);
                    });
                }

                // Restore furniture
                if (data.furniture) {
                    data.furniture.forEach(f => {
                        createFurniture(f.type, f.x, f.y, f.rotation);
                    });
                }

                // Restore openings
                if (data.openings) {
                    data.openings.forEach(o => {
                        if (o.type === 'door' || o.id.startsWith('D-')) {
                            const door = createDoor(o.x, o.y, o.wallId);
                            door.width = o.width;
                            door.swingDirection = o.swingDirection;
                            door.swingInOut = o.swingInOut;
                            door.arcVisible = o.arcVisible;
                        } else {
                            const win = createWindow(o.x, o.y, o.wallId);
                            win.width = o.width;
                            win.sillHeight = o.sillHeight;
                            win.hasStool = o.hasStool;
                            win.hasApron = o.hasApron;
                            win.hasWell = o.hasWell;
                        }
                    });
                }

                // Restore components
                if (data.components) {
                    data.components.forEach(c => {
                        const comp = createComponent(c.type, c.x, c.y);
                        comp.wallId = c.wallId;
                    });
                }

                // Restore observations
                if (data.observations) {
                    data.observations.forEach(o => {
                        // Create without opening modal
                        const obsId = o.id;
                        const obsGroup = new Konva.Group({ x: o.x, y: o.y, draggable: true, name: 'obs-group', id: obsId });
                        const colors = { 'DET': '#ff4444', 'FRI': '#ff9800', 'IMP': '#2196f3', 'WET': '#9c27b0', 'SUS': '#607d8b' };
                        obsGroup.add(new Konva.RegularPolygon({ sides: 3, radius: 15, fill: colors[o.conditionCode] || '#ff4444', stroke: '#fff', strokeWidth: 2, name: 'obs-marker' }));
                        obsGroup.add(new Konva.Text({ x: -4, y: -8, text: '!', fontSize: 16, fontStyle: 'bold', fill: '#fff' }));
                        obsGroup.add(new Konva.Text({ x: -20, y: 20, text: obsId, fontSize: 9, fill: colors[o.conditionCode] || '#ff4444', fontStyle: 'bold', name: 'obs-label' }));
                        const obsData = { id: obsId, conditionCode: o.conditionCode, priority: o.priority, description: o.description, photoLinks: o.photoLinks || [], roomId: o.roomId, position: { x: o.x, y: o.y }, konvaGroup: obsGroup };
                        CADState.observations.push(obsData);
                        CADState.layers.observations.add(obsGroup);
                        setupGenericDragInteractions(obsGroup);
                        obsGroup.on('dblclick', () => openObservationModal(obsData));
                    });
                }

                // Restore samples
                if (data.samples) {
                    data.samples.forEach(s => {
                        const sampleId = s.id;
                        const sampleGroup = new Konva.Group({ x: s.x, y: s.y, draggable: true, name: 'sample-group', id: sampleId });
                        const colors = { 'POS': '#ff4444', 'NEG': '#4caf50', 'INCONCLUSIVE': '#ff9800', 'NO-ACCESS': '#607d8b' };
                        sampleGroup.add(new Konva.Circle({ radius: 12, fill: colors[s.result] || '#2196f3', stroke: '#fff', strokeWidth: 2, name: 'sample-marker' }));
                        sampleGroup.add(new Konva.Text({ x: -5, y: -7, text: 'S', fontSize: 12, fontStyle: 'bold', fill: '#fff' }));
                        sampleGroup.add(new Konva.Text({ x: -15, y: 16, text: sampleId, fontSize: 9, fill: colors[s.result] || '#2196f3', fontStyle: 'bold', name: 'sample-label' }));
                        const sampleData = { id: sampleId, method: s.method, target: s.target, result: s.result, notes: s.notes, position: { x: s.x, y: s.y }, konvaGroup: sampleGroup };
                        CADState.samples.push(sampleData);
                        CADState.layers.samples.add(sampleGroup);
                        setupGenericDragInteractions(sampleGroup);
                        sampleGroup.on('dblclick', () => openSampleModal(sampleData));
                    });
                }

                // Restore photos
                if (data.photos) {
                    data.photos.forEach(p => {
                        const photoId = p.id;
                        const photoGroup = new Konva.Group({ x: p.x, y: p.y, draggable: true, name: 'photo-group', id: photoId, rotation: p.direction || 0 });
                        photoGroup.add(new Konva.Rect({ x: -10, y: -8, width: 20, height: 16, fill: '#4caf50', stroke: '#fff', strokeWidth: 2, cornerRadius: 2, name: 'photo-body' }));
                        photoGroup.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: '#2e7d32', stroke: '#fff', strokeWidth: 1 }));
                        photoGroup.add(new Konva.Arrow({ points: [0, -12, 0, -25], pointerLength: 6, pointerWidth: 6, fill: '#4caf50', stroke: '#4caf50', strokeWidth: 2, name: 'photo-arrow' }));
                        photoGroup.add(new Konva.Text({ x: -15, y: 12, text: photoId, fontSize: 9, fill: '#4caf50', fontStyle: 'bold' }));
                        const photoData = { id: photoId, direction: p.direction || 0, caption: p.caption, linkedObsIds: p.linkedObsIds || [], position: { x: p.x, y: p.y }, konvaGroup: photoGroup };
                        CADState.photos.push(photoData);
                        CADState.layers.photos.add(photoGroup);
                        setupGenericDragInteractions(photoGroup);
                        photoGroup.on('dblclick', () => { photoData.direction = (photoData.direction + 45) % 360; photoGroup.rotation(photoData.direction); CADState.layers.photos.batchDraw(); });
                    });
                }

                // Redraw new layers
                CADState.layers.observations.batchDraw();
                CADState.layers.samples.batchDraw();
                CADState.layers.photos.batchDraw();

                // Restore view state
                if (data.viewState) {
                    CADState.stage.scale({ x: data.viewState.scale, y: data.viewState.scale });
                    CADState.stage.position({ x: data.viewState.x, y: data.viewState.y });
                    document.getElementById('zoomLevel').textContent = Math.round(data.viewState.scale * 100) + '%';
                }

                CADState.northArrowAngle = data.northArrowAngle || 0;
                CADState.level = data.level || 1;

                updateObjectTree();
                updateAssessmentLists();
                runQAValidation();

                if (!silent) {
                    alert('Assessment loaded from ' + new Date(data.timestamp).toLocaleString());
                }
            } catch (e) {
                console.error('Load failed:', e);
                if (!silent) {
                    alert('Load failed: ' + e.message);
                }
            }
        }

        // ========== PDF EXPORT ==========
        async function exportPDF() {
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('landscape', 'mm', 'a4');

                // Title
                pdf.setFontSize(18);
                pdf.setTextColor(0, 0, 0);
                pdf.text('Lead Risk Assessment - Floor Plan', 15, 15);

                // Date and scale info
                pdf.setFontSize(10);
                pdf.text('Date: ' + new Date().toLocaleDateString(), 15, 22);
                pdf.text('Scale: 1:50 | Level: ' + CADState.level, 15, 28);

                // Hide UI elements during export
                CADState.transformer.nodes([]);
                CADState.layers.ui.visible(false);

                // Canvas export
                const dataURL = CADState.stage.toDataURL({
                    pixelRatio: 2,
                    mimeType: 'image/png'
                });

                // Restore UI
                CADState.layers.ui.visible(true);

                // Add image to PDF
                pdf.addImage(dataURL, 'PNG', 15, 35, 267, 140);

                // Legend
                pdf.setFontSize(8);
                pdf.text('Legend: Triangle = Observation | Circle S = Sample | Camera = Photo | Yellow = Doors/Windows', 15, 180);

                // Stats summary
                const stats = [
                    'Rooms: ' + CADState.rooms.length,
                    'Doors: ' + CADState.openings.filter(o => o.id.startsWith('D-')).length,
                    'Windows: ' + CADState.openings.filter(o => o.id.startsWith('WIN-')).length,
                    'Observations: ' + CADState.observations.length,
                    'Samples: ' + CADState.samples.length,
                    'Photos: ' + CADState.photos.length
                ].join(' | ');
                pdf.text(stats, 15, 185);

                // QA Summary
                const qaErrors = CADState.qaFlags.filter(f => f.type === 'error').length;
                const qaWarnings = CADState.qaFlags.filter(f => f.type === 'warning').length;
                pdf.text('QA Status: ' + qaErrors + ' errors, ' + qaWarnings + ' warnings', 15, 190);

                // Save
                pdf.save('lead-assessment-floor-plan.pdf');
            } catch (e) {
                console.error('PDF export failed:', e);
                alert('PDF export failed: ' + e.message);
            }
        }

        // ========== UTILITY ==========
        function updateObjectCount() {
            const count = CADState.rooms.length + CADState.walls.length + CADState.furniture.length +
                          CADState.openings.length + CADState.components.length +
                          CADState.observations.length + CADState.samples.length + CADState.photos.length;
            document.getElementById('objectCount').textContent = count;
        }

        function updateObjectTree() {
            const tree = document.getElementById('objectTree');
            while (tree.firstChild) {
                tree.removeChild(tree.firstChild);
            }

            // Helper function to add tree item
            function addTreeItem(label, color, indent, onClick) {
                const item = document.createElement('div');
                item.className = 'tree-item';
                item.style.paddingLeft = (indent * 12) + 'px';
                if (onClick) item.addEventListener('click', onClick);
                const icon = document.createElement('div');
                icon.className = 'tree-icon';
                icon.style.background = color;
                item.appendChild(icon);
                item.appendChild(document.createTextNode(label));
                tree.appendChild(item);
            }

            // Helper to add section header
            function addSection(label) {
                const item = document.createElement('div');
                item.className = 'tree-item';
                item.style.fontWeight = 'bold';
                item.style.color = '#f4d03f';
                item.style.fontSize = '10px';
                item.style.marginTop = '8px';
                item.appendChild(document.createTextNode(label));
                tree.appendChild(item);
            }

            // ROOMS section
            addSection('ROOMS (' + CADState.rooms.length + ')');
            CADState.rooms.forEach(room => {
                const label = room.id + ' - ' + (room.name || room.customLabel || room.type || 'Room');
                addTreeItem(label, '#f4d03f', 1, () => {
                    if (room.konvaGroup) { setTool('select'); selectObjects([room.konvaGroup]); }
                });
            });

            // OPENINGS section (Doors, Windows, Cased)
            const doors = CADState.openings.filter(o => o.type === 'door' || o.id.startsWith('D-'));
            const windows = CADState.openings.filter(o => o.type === 'window' || o.id.startsWith('WIN-'));
            const casedOpenings = CADState.openings.filter(o => o.type === 'cased' || o.id.startsWith('OP-'));

            if (doors.length > 0) {
                addSection('DOORS (' + doors.length + ')');
                doors.forEach(d => {
                    addTreeItem(d.id, '#f4d03f', 1, () => { if (d.konvaGroup) { setTool('select'); selectObjects([d.konvaGroup]); }});
                });
            }

            if (windows.length > 0) {
                addSection('WINDOWS (' + windows.length + ')');
                windows.forEach(w => {
                    addTreeItem(w.id, '#4fc3f7', 1, () => { if (w.konvaGroup) { setTool('select'); selectObjects([w.konvaGroup]); }});
                });
            }

            if (casedOpenings.length > 0) {
                addSection('OPENINGS (' + casedOpenings.length + ')');
                casedOpenings.forEach(o => {
                    addTreeItem(o.id + ' "---------"', '#f4d03f', 1, () => { if (o.konvaGroup) { setTool('select'); selectObjects([o.konvaGroup]); }});
                });
            }

            // CLOSETS section
            if (CADState.closets && CADState.closets.length > 0) {
                addSection('CLOSETS (' + CADState.closets.length + ')');
                CADState.closets.forEach(c => {
                    addTreeItem(c.id, '#9e9e9e', 1, () => { if (c.konvaGroup) { setTool('select'); selectObjects([c.konvaGroup]); }});
                });
            }

            // MEP section
            const mepCount = (CADState.mepNodes ? CADState.mepNodes.length : 0) +
                            (CADState.poeMarkers ? CADState.poeMarkers.length : 0) +
                            CADState.components.filter(c => ['radiator','riser'].includes(c.type)).length;

            if (mepCount > 0) {
                addSection('MEP (' + mepCount + ')');

                // Radiators
                CADState.components.filter(c => c.type === 'radiator').forEach(c => {
                    addTreeItem(c.id, '#ff9800', 1, () => { if (c.konvaGroup) { setTool('select'); selectObjects([c.konvaGroup]); }});
                });

                // Risers
                CADState.components.filter(c => c.type === 'riser').forEach(c => {
                    addTreeItem(c.id, '#ff5722', 1, () => { if (c.konvaGroup) { setTool('select'); selectObjects([c.konvaGroup]); }});
                });

                // Pipe nodes (hollow)
                if (CADState.mepNodes) {
                    CADState.mepNodes.filter(n => n.type === 'pipe').forEach(n => {
                        addTreeItem(n.id + ' (hollow)', '#2196f3', 1, () => { if (n.konvaGroup) { setTool('select'); selectObjects([n.konvaGroup]); }});
                    });

                    // Gas nodes (filled)
                    CADState.mepNodes.filter(n => n.type === 'gas').forEach(n => {
                        addTreeItem(n.id + ' (filled)', '#ff9800', 1, () => { if (n.konvaGroup) { setTool('select'); selectObjects([n.konvaGroup]); }});
                    });
                }

                // POE markers
                if (CADState.poeMarkers) {
                    CADState.poeMarkers.forEach(p => {
                        const colors = { water: '#2196f3', gas: '#ff9800', electric: '#f44336', telecom: '#9c27b0' };
                        addTreeItem(p.id + ' (' + p.type + ')', colors[p.type] || '#888', 1, () => { if (p.konvaGroup) { setTool('select'); selectObjects([p.konvaGroup]); }});
                    });
                }
            }

            // LRA section
            const lraCount = CADState.observations.length + CADState.samples.length + CADState.photos.length;
            if (lraCount > 0) {
                addSection('LRA MARKERS (' + lraCount + ')');

                CADState.observations.forEach(o => {
                    addTreeItem(o.id + ' (' + (o.conditionCode || '?') + ')', '#ff4444', 1, () => { if (o.konvaGroup) { setTool('select'); selectObjects([o.konvaGroup]); }});
                });

                CADState.samples.forEach(s => {
                    addTreeItem(s.id + ' (' + (s.method || '?') + ')', '#e91e63', 1, () => { if (s.konvaGroup) { setTool('select'); selectObjects([s.konvaGroup]); }});
                });

                CADState.photos.forEach(p => {
                    addTreeItem(p.id, '#4caf50', 1, () => { if (p.konvaGroup) { setTool('select'); selectObjects([p.konvaGroup]); }});
                });
            }

            // Other components
            const otherComps = CADState.components.filter(c => !['radiator','riser'].includes(c.type));
            if (otherComps.length > 0) {
                addSection('COMPONENTS (' + otherComps.length + ')');
                otherComps.forEach(c => {
                    addTreeItem(c.id, '#888', 1, () => { if (c.konvaGroup) { setTool('select'); selectObjects([c.konvaGroup]); }});
                });
            }
        }

        function selectRoomById(id) {
            const room = CADState.rooms.find(r => r.id === id);
            if (room) {
                setTool('select');
                selectObjects([room.konvaGroup]);
            }
        }

        function selectFurnitureById(id) {
            const furniture = CADState.furniture.find(f => f.id === id);
            if (furniture) {
                setTool('select');
                selectObjects([furniture.konvaGroup]);
            }
        }

        // ========== KEYBOARD SHORTCUTS ==========
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger shortcuts when typing in inputs
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                // Tool shortcuts
                if (!e.ctrlKey && !e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'v': setTool('select'); break;
                        case 'r':
                            if (!e.shiftKey) setTool('room');
                            break;
                        case 'w': setTool('wall'); break;
                        case 'escape':
                            cancelCurrentOperation();
                            clearRoomSelection();
                            deselectAll();
                            setTool('select');
                            break;
                    }
                }

                // Delete
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (e.target.tagName !== 'INPUT') {
                        e.preventDefault();
                        deleteSelected();
                    }
                }

                // Rotate furniture with R key (when shift is held)
                if (e.key.toLowerCase() === 'r' && e.shiftKey && CADState.selection.length > 0) {
                    e.preventDefault();
                    rotateSelectedFurniture();
                }

                // Undo/Redo
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                }

                if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }

                // Save
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveToStorage();
                }

                // Copy
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    if (CADState.selection.length > 0) {
                        e.preventDefault();
                        copySelected();
                    }
                }
            });
        }

        // ========== FURNITURE DRAG AND DROP ==========
        function setupFurnitureDragAndDrop() {
            const symbolItems = document.querySelectorAll('.symbol-item[draggable="true"]');
            const container = document.getElementById('blueprint-container');

            symbolItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('furniture-type', item.dataset.furniture);
                    item.classList.add('dragging');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });
            });

            // Allow drop on canvas
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const furnitureType = e.dataTransfer.getData('furniture-type');
                if (furnitureType) {
                    // Convert screen coordinates to stage coordinates
                    const rect = container.getBoundingClientRect();
                    const stage = CADState.stage;
                    const scale = stage.scaleX();

                    const x = (e.clientX - rect.left - stage.x()) / scale;
                    const y = (e.clientY - rect.top - stage.y()) / scale;

                    createFurniture(furnitureType, x, y);
                    saveHistoryState();
                }
            });
        }

        // ========== ROOM PALETTE (Sims-style) ==========
        function setupRoomPalette() {
            const roomBlocks = document.querySelectorAll('.room-block');

            roomBlocks.forEach(block => {
                block.addEventListener('click', () => {
                    const roomType = block.dataset.room;

                    // Toggle selection
                    if (CADState.selectedRoomType === roomType) {
                        // Deselect
                        CADState.selectedRoomType = null;
                        block.classList.remove('selected');
                        setTool('select');
                    } else {
                        // Select this room type
                        roomBlocks.forEach(b => b.classList.remove('selected'));
                        block.classList.add('selected');
                        CADState.selectedRoomType = roomType;
                        setTool('place');
                    }
                });
            });
        }

        function placeRoomBlock(pos) {
            if (!CADState.selectedRoomType) return;

            const roomType = CADState.selectedRoomType;
            const typeInfo = ROOM_TYPES[roomType] || ROOM_TYPES['Custom'];
            const size = typeInfo.defaultSize || { w: 100, h: 100 };

            // Snap position to grid
            const snapped = snapPosition(pos);

            // Center the room on click position
            const x = snapped.x - size.w / 2;
            const y = snapped.y - size.h / 2;

            // Create the room
            createRoom(x, y, size.w, size.h, roomType);
            saveHistoryState();

            // Keep the room type selected for placing more rooms
            // User can press Escape or V to exit placement mode
        }

        function clearRoomSelection() {
            CADState.selectedRoomType = null;
            document.querySelectorAll('.room-block').forEach(b => b.classList.remove('selected'));
        }

        // ========== ACCORDION TOGGLE ==========
        function toggleAccordion(header) {
            const section = header.parentElement;
            section.classList.toggle('collapsed');
        }

        // ========== LAYER VISIBILITY & LOCKS ==========
        function toggleLayerVisibility(layerName, visible) {
            CADState.layerVisibility[layerName] = visible;
            if (layerName === 'basePlan') {
                CADState.layers.rooms.visible(visible);
                CADState.layers.walls.visible(visible);
            } else if (CADState.layers[layerName]) {
                CADState.layers[layerName].visible(visible);
            }
            CADState.stage.batchDraw();
        }

        function toggleLayerLock(layerName, btn) {
            CADState.layerLocks[layerName] = !CADState.layerLocks[layerName];
            btn.classList.toggle('locked', CADState.layerLocks[layerName]);
            btn.textContent = CADState.layerLocks[layerName] ? 'U' : 'L';
            updateLayerDraggable(layerName);
        }

        function updateLayerDraggable(layerName) {
            const locked = CADState.layerLocks[layerName];
            if (layerName === 'basePlan') {
                CADState.rooms.forEach(r => r.konvaGroup.draggable(!locked));
                CADState.walls.forEach(w => w.konvaLine.draggable(!locked));
            }
        }

        // ========== SNAP SETTINGS ==========
        function toggleSnapSetting(setting, enabled) {
            CADState.snapSettings[setting] = enabled;
        }

        function setGridSpacing(spacing) {
            CADState.settings.gridSize = spacing;
            drawGrid();
        }

        function setWallThickness(thickness) {
            CADState.wallType = thickness;
        }

        function setWallCategory(category) {
            CADState.wallCategory = category;
            document.getElementById('wallInterior').classList.toggle('active', category === 'interior');
            document.getElementById('wallExterior').classList.toggle('active', category === 'exterior');
            document.getElementById('wallPartition').classList.toggle('active', category === 'partition');
        }

        // ========== ENHANCED SNAP POINT FINDER ==========
        function findSnapPoint(pos) {
            const threshold = CADState.settings.snapThreshold;
            let bestSnap = null;
            let bestDist = threshold;

            if (CADState.snapSettings.endpoints) {
                CADState.walls.forEach(wall => {
                    const points = wall.points;
                    [[points[0], points[1]], [points[2], points[3]]].forEach(([x, y]) => {
                        const dist = Math.hypot(pos.x - x, pos.y - y);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestSnap = { point: { x, y }, type: 'endpoint', wallId: wall.id };
                        }
                    });
                });
            }

            if (CADState.snapSettings.midpoints) {
                CADState.walls.forEach(wall => {
                    const points = wall.points;
                    const midX = (points[0] + points[2]) / 2;
                    const midY = (points[1] + points[3]) / 2;
                    const dist = Math.hypot(pos.x - midX, pos.y - midY);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestSnap = { point: { x: midX, y: midY }, type: 'midpoint', wallId: wall.id };
                    }
                });
            }

            if (CADState.snapSettings.corners) {
                CADState.rooms.forEach(room => {
                    const group = room.konvaGroup;
                    const rect = group.findOne('.room-fill');
                    const corners = [
                        { x: group.x(), y: group.y() },
                        { x: group.x() + rect.width(), y: group.y() },
                        { x: group.x(), y: group.y() + rect.height() },
                        { x: group.x() + rect.width(), y: group.y() + rect.height() }
                    ];
                    corners.forEach(corner => {
                        const dist = Math.hypot(pos.x - corner.x, pos.y - corner.y);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestSnap = { point: corner, type: 'corner', roomId: room.id };
                        }
                    });
                });
            }

            if (CADState.snapSettings.grid && !bestSnap) {
                const gridSize = CADState.settings.gridSize;
                const snappedX = Math.round(pos.x / gridSize) * gridSize;
                const snappedY = Math.round(pos.y / gridSize) * gridSize;
                bestSnap = { point: { x: snappedX, y: snappedY }, type: 'grid' };
            }

            return bestSnap;
        }

        // ========== DOOR CREATION ==========
        function createDoor(x, y, wallId = null) {
            const doorId = CADState.generateDoorId();
            const doorGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'door-group', id: doorId
            });

            doorGroup.add(new Konva.Arc({
                innerRadius: 0, outerRadius: 30, angle: 90,
                stroke: '#f4d03f', strokeWidth: 1.5, dash: [4, 2], name: 'door-arc'
            }));
            doorGroup.add(new Konva.Line({
                points: [0, 0, 30, 0], stroke: '#f4d03f', strokeWidth: 3, name: 'door-leaf'
            }));
            doorGroup.add(new Konva.Text({
                x: -15, y: 35, text: doorId, fontSize: 10, fill: '#f4d03f', name: 'door-label'
            }));

            const doorData = {
                id: doorId, wallId: wallId, width: 32, swingDirection: 'left',
                swingInOut: 'in', arcVisible: true, konvaGroup: doorGroup
            };
            CADState.openings.push(doorData);
            CADState.layers.openings.add(doorGroup);
            setupGenericDragInteractions(doorGroup);
            doorGroup.on('dblclick', () => openDoorModal(doorData));
            CADState.layers.openings.batchDraw();
            updateObjectCount();
            runQAValidation();
            return doorData;
        }

        // ========== WINDOW CREATION ==========
        function createWindow(x, y, wallId = null) {
            const windowId = CADState.generateWindowId();
            const windowGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'window-group', id: windowId
            });

            windowGroup.add(new Konva.Rect({
                x: -20, y: -5, width: 40, height: 10,
                stroke: '#f4d03f', strokeWidth: 2, fill: 'rgba(244, 208, 63, 0.2)', name: 'window-frame'
            }));
            windowGroup.add(new Konva.Line({
                points: [-22, 5, 22, 5], stroke: '#f4d03f', strokeWidth: 1, name: 'window-sill'
            }));
            windowGroup.add(new Konva.Text({
                x: -20, y: 10, text: windowId, fontSize: 9, fill: '#f4d03f', name: 'window-label'
            }));

            const windowData = {
                id: windowId, wallId: wallId, width: 36, sillHeight: 36,
                hasStool: true, hasApron: true, hasWell: false, konvaGroup: windowGroup
            };
            CADState.openings.push(windowData);
            CADState.layers.openings.add(windowGroup);
            setupGenericDragInteractions(windowGroup);
            windowGroup.on('dblclick', () => openWindowModal(windowData));
            CADState.layers.openings.batchDraw();
            updateObjectCount();
            runQAValidation();
            return windowData;
        }

        // ========== OBSERVATION CREATION ==========
        function createObservation(x, y) {
            const obsId = CADState.generateObsId();
            const obsGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'obs-group', id: obsId
            });

            obsGroup.add(new Konva.RegularPolygon({
                sides: 3, radius: 15, fill: '#ff4444', stroke: '#fff', strokeWidth: 2, name: 'obs-marker'
            }));
            obsGroup.add(new Konva.Text({
                x: -4, y: -8, text: '!', fontSize: 16, fontStyle: 'bold', fill: '#fff'
            }));
            obsGroup.add(new Konva.Text({
                x: -20, y: 20, text: obsId, fontSize: 9, fill: '#ff4444', fontStyle: 'bold', name: 'obs-label'
            }));

            const obsData = {
                id: obsId, conditionCode: '', priority: '', description: '',
                photoLinks: [], roomId: '', position: { x, y }, konvaGroup: obsGroup
            };
            CADState.observations.push(obsData);
            CADState.layers.observations.add(obsGroup);
            setupGenericDragInteractions(obsGroup);
            obsGroup.on('dblclick', () => openObservationModal(obsData));
            CADState.layers.observations.batchDraw();
            updateObjectCount();
            updateAssessmentLists();
            runQAValidation();
            openObservationModal(obsData);
            return obsData;
        }

        // ========== SAMPLE CREATION ==========
        function createSample(x, y) {
            const sampleId = CADState.generateSampleId();
            const sampleGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'sample-group', id: sampleId
            });

            sampleGroup.add(new Konva.Circle({
                radius: 12, fill: '#2196f3', stroke: '#fff', strokeWidth: 2, name: 'sample-marker'
            }));
            sampleGroup.add(new Konva.Text({
                x: -5, y: -7, text: 'S', fontSize: 12, fontStyle: 'bold', fill: '#fff'
            }));
            sampleGroup.add(new Konva.Text({
                x: -15, y: 16, text: sampleId, fontSize: 9, fill: '#2196f3', fontStyle: 'bold', name: 'sample-label'
            }));

            const sampleData = {
                id: sampleId, method: '', target: '', result: '', notes: '',
                position: { x, y }, konvaGroup: sampleGroup
            };
            CADState.samples.push(sampleData);
            CADState.layers.samples.add(sampleGroup);
            setupGenericDragInteractions(sampleGroup);
            sampleGroup.on('dblclick', () => openSampleModal(sampleData));
            CADState.layers.samples.batchDraw();
            updateObjectCount();
            updateAssessmentLists();
            runQAValidation();
            openSampleModal(sampleData);
            return sampleData;
        }

        // ========== PHOTO MARKER CREATION ==========
        function createPhotoMarker(x, y) {
            const photoId = CADState.generatePhotoId();
            const photoGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'photo-group', id: photoId
            });

            photoGroup.add(new Konva.Rect({
                x: -10, y: -8, width: 20, height: 16, fill: '#4caf50',
                stroke: '#fff', strokeWidth: 2, cornerRadius: 2, name: 'photo-body'
            }));
            photoGroup.add(new Konva.Circle({
                x: 0, y: 0, radius: 5, fill: '#2e7d32', stroke: '#fff', strokeWidth: 1
            }));
            photoGroup.add(new Konva.Arrow({
                points: [0, -12, 0, -25], pointerLength: 6, pointerWidth: 6,
                fill: '#4caf50', stroke: '#4caf50', strokeWidth: 2, name: 'photo-arrow'
            }));
            photoGroup.add(new Konva.Text({
                x: -15, y: 12, text: photoId, fontSize: 9, fill: '#4caf50', fontStyle: 'bold'
            }));

            const photoData = {
                id: photoId, direction: 0, caption: '', linkedObsIds: [],
                position: { x, y }, konvaGroup: photoGroup
            };
            CADState.photos.push(photoData);
            CADState.layers.photos.add(photoGroup);
            setupGenericDragInteractions(photoGroup);
            photoGroup.on('dblclick', () => {
                photoData.direction = (photoData.direction + 45) % 360;
                photoGroup.rotation(photoData.direction);
                CADState.layers.photos.batchDraw();
            });
            CADState.layers.photos.batchDraw();
            updateObjectCount();
            updateAssessmentLists();
            openPhotoModal(photoData);
            return photoData;
        }

        // ========== COMPONENT CREATION ==========
        function createComponent(type, x, y) {
            const compId = CADState.generateComponentId(type);
            const compGroup = new Konva.Group({
                x: x, y: y, draggable: true, name: 'component-group', id: compId
            });

            switch (type) {
                case 'radiator':
                    compGroup.add(new Konva.Rect({ x: -20, y: -10, width: 40, height: 20, stroke: '#ff6b6b', strokeWidth: 1.5, fill: 'rgba(255,107,107,0.2)' }));
                    for (let i = -15; i <= 15; i += 10) compGroup.add(new Konva.Line({ points: [i, -8, i, 8], stroke: '#ff6b6b', strokeWidth: 1 }));
                    break;
                case 'riser':
                    compGroup.add(new Konva.Circle({ radius: 12, stroke: '#f4d03f', strokeWidth: 2, fill: 'rgba(244,208,63,0.2)' }));
                    compGroup.add(new Konva.Line({ points: [0, -8, 0, 8], stroke: '#f4d03f', strokeWidth: 2 }));
                    break;
                case 'baseboard':
                    compGroup.add(new Konva.Rect({ x: -25, y: -3, width: 50, height: 6, fill: '#8b4513', stroke: '#5d2f0d', strokeWidth: 1 }));
                    break;
                case 'trim':
                    compGroup.add(new Konva.Rect({ x: -20, y: -2, width: 40, height: 4, fill: '#deb887', stroke: '#b8860b', strokeWidth: 1 }));
                    break;
                case 'cabinet':
                    compGroup.add(new Konva.Rect({ x: -20, y: -15, width: 40, height: 30, fill: '#654321', stroke: '#3d2314', strokeWidth: 2 }));
                    break;
                case 'stairs':
                    compGroup.add(new Konva.Rect({ x: -15, y: -20, width: 30, height: 40, stroke: '#888', strokeWidth: 1.5, fill: 'rgba(136,136,136,0.2)' }));
                    for (let i = 0; i < 8; i++) compGroup.add(new Konva.Line({ points: [-13, i * 5 - 18, 13, i * 5 - 18], stroke: '#888', strokeWidth: 1 }));
                    break;
                default:
                    compGroup.add(new Konva.Circle({ radius: 10, fill: '#888', stroke: '#666', strokeWidth: 1 }));
            }
            compGroup.add(new Konva.Text({ x: -20, y: 20, text: compId, fontSize: 8, fill: '#888' }));

            const compData = { id: compId, type: type, wallId: null, position: { x, y }, konvaGroup: compGroup };
            CADState.components.push(compData);
            CADState.layers.components.add(compGroup);
            setupGenericDragInteractions(compGroup);
            CADState.layers.components.batchDraw();
            updateObjectCount();
            runQAValidation();
            return compData;
        }

        function setupGenericDragInteractions(obj) {
            obj.on('click tap', (e) => {
                if (CADState.mode === 'select') { e.cancelBubble = true; selectObjects([obj], e.evt.shiftKey); }
            });
            obj.on('dragmove', () => {
                const snap = findSnapPoint({ x: obj.x(), y: obj.y() });
                if (snap) { obj.position(snap.point); showSnapIndicator(true); }
            });
            obj.on('dragend', () => { showSnapIndicator(false); saveHistoryState(); });
        }

        // ========== MODAL FUNCTIONS ==========
        function openDoorModal(doorData) {
            CADState.editingDoor = doorData;
            document.getElementById('doorId').value = doorData.id;
            document.getElementById('doorWidth').value = doorData.width;
            document.getElementById('doorSwingDir').value = doorData.swingDirection;
            document.getElementById('doorSwingInOut').value = doorData.swingInOut;
            document.getElementById('doorArcVisible').checked = doorData.arcVisible;
            populateWallDropdown('doorWall', doorData.wallId);
            document.getElementById('doorModal').classList.add('active');
        }

        function closeDoorModal() { document.getElementById('doorModal').classList.remove('active'); CADState.editingDoor = null; }

        function saveDoor() {
            if (!CADState.editingDoor) return;
            CADState.editingDoor.width = parseInt(document.getElementById('doorWidth').value);
            CADState.editingDoor.wallId = document.getElementById('doorWall').value;
            CADState.editingDoor.swingDirection = document.getElementById('doorSwingDir').value;
            CADState.editingDoor.swingInOut = document.getElementById('doorSwingInOut').value;
            CADState.editingDoor.arcVisible = document.getElementById('doorArcVisible').checked;
            const arc = CADState.editingDoor.konvaGroup.findOne('.door-arc');
            if (arc) arc.visible(CADState.editingDoor.arcVisible);
            CADState.layers.openings.batchDraw();
            closeDoorModal();
            runQAValidation();
            saveHistoryState();
        }

        function openWindowModal(windowData) {
            CADState.editingWindow = windowData;
            document.getElementById('windowId').value = windowData.id;
            document.getElementById('windowWidth').value = windowData.width;
            document.getElementById('windowSillHeight').value = windowData.sillHeight;
            document.getElementById('windowHasStool').checked = windowData.hasStool;
            document.getElementById('windowHasApron').checked = windowData.hasApron;
            document.getElementById('windowHasWell').checked = windowData.hasWell || false;
            populateWallDropdown('windowWall', windowData.wallId);
            document.getElementById('windowModal').classList.add('active');
        }

        function closeWindowModal() { document.getElementById('windowModal').classList.remove('active'); CADState.editingWindow = null; }

        function saveWindow() {
            if (!CADState.editingWindow) return;
            CADState.editingWindow.width = parseInt(document.getElementById('windowWidth').value);
            CADState.editingWindow.wallId = document.getElementById('windowWall').value;
            CADState.editingWindow.sillHeight = parseInt(document.getElementById('windowSillHeight').value);
            CADState.editingWindow.hasStool = document.getElementById('windowHasStool').checked;
            CADState.editingWindow.hasApron = document.getElementById('windowHasApron').checked;
            CADState.editingWindow.hasWell = document.getElementById('windowHasWell').checked;
            closeWindowModal();
            runQAValidation();
            saveHistoryState();
        }

        function openObservationModal(obsData) {
            CADState.editingObservation = obsData;
            document.getElementById('obsId').value = obsData.id;
            document.getElementById('obsCondition').value = obsData.conditionCode || '';
            document.getElementById('obsPriority').value = obsData.priority || '';
            document.getElementById('obsDescription').value = obsData.description || '';
            populateRoomDropdown('obsRoom', obsData.roomId);
            populatePhotoCheckboxes('obsPhotoLinks', obsData.photoLinks);
            document.getElementById('observationModal').classList.add('active');
        }

        function closeObservationModal() { document.getElementById('observationModal').classList.remove('active'); CADState.editingObservation = null; }

        function saveObservation() {
            if (!CADState.editingObservation) return;
            CADState.editingObservation.conditionCode = document.getElementById('obsCondition').value;
            CADState.editingObservation.priority = document.getElementById('obsPriority').value;
            CADState.editingObservation.description = document.getElementById('obsDescription').value;
            CADState.editingObservation.roomId = document.getElementById('obsRoom').value;
            CADState.editingObservation.photoLinks = getCheckedValues('obsPhotoLinks');
            const marker = CADState.editingObservation.konvaGroup.findOne('.obs-marker');
            if (marker) {
                const colors = { 'DET': '#ff4444', 'FRI': '#ff9800', 'IMP': '#2196f3', 'WET': '#9c27b0', 'SUS': '#607d8b' };
                marker.fill(colors[CADState.editingObservation.conditionCode] || '#ff4444');
            }
            CADState.layers.observations.batchDraw();
            closeObservationModal();
            updateAssessmentLists();
            runQAValidation();
            saveHistoryState();
        }

        function openSampleModal(sampleData) {
            CADState.editingSample = sampleData;
            document.getElementById('sampleId').value = sampleData.id;
            document.getElementById('sampleMethod').value = sampleData.method || '';
            document.getElementById('sampleResult').value = sampleData.result || '';
            document.getElementById('sampleTarget').value = sampleData.target || '';
            document.getElementById('sampleNotes').value = sampleData.notes || '';
            document.getElementById('sampleModal').classList.add('active');
        }

        function closeSampleModal() { document.getElementById('sampleModal').classList.remove('active'); CADState.editingSample = null; }

        function saveSample() {
            if (!CADState.editingSample) return;
            CADState.editingSample.method = document.getElementById('sampleMethod').value;
            CADState.editingSample.result = document.getElementById('sampleResult').value;
            CADState.editingSample.target = document.getElementById('sampleTarget').value;
            CADState.editingSample.notes = document.getElementById('sampleNotes').value;
            const marker = CADState.editingSample.konvaGroup.findOne('.sample-marker');
            if (marker) {
                const colors = { 'POS': '#ff4444', 'NEG': '#4caf50', 'INCONCLUSIVE': '#ff9800', 'NO-ACCESS': '#607d8b' };
                marker.fill(colors[CADState.editingSample.result] || '#2196f3');
            }
            CADState.layers.samples.batchDraw();
            closeSampleModal();
            updateAssessmentLists();
            runQAValidation();
            saveHistoryState();
        }

        function openPhotoModal(photoData) {
            CADState.editingPhoto = photoData;
            document.getElementById('photoId').value = photoData.id;
            document.getElementById('photoDirection').value = photoData.direction || 0;
            document.getElementById('photoCaption').value = photoData.caption || '';
            populateObsCheckboxes('photoObsLinks', photoData.linkedObsIds);
            document.getElementById('photoModal').classList.add('active');
        }

        function closePhotoModal() { document.getElementById('photoModal').classList.remove('active'); CADState.editingPhoto = null; }

        function savePhoto() {
            if (!CADState.editingPhoto) return;
            CADState.editingPhoto.direction = parseInt(document.getElementById('photoDirection').value);
            CADState.editingPhoto.caption = document.getElementById('photoCaption').value;
            CADState.editingPhoto.linkedObsIds = getCheckedValues('photoObsLinks');
            CADState.editingPhoto.konvaGroup.rotation(CADState.editingPhoto.direction);
            CADState.layers.photos.batchDraw();
            closePhotoModal();
            updateAssessmentLists();
            saveHistoryState();
        }

        // ========== MODAL HELPER FUNCTIONS ==========
        function populateWallDropdown(selectId, selectedValue) {
            const select = document.getElementById(selectId);
            select.textContent = '';
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Select Wall...';
            select.appendChild(defaultOpt);
            CADState.walls.forEach(w => {
                const opt = document.createElement('option');
                opt.value = w.id;
                opt.textContent = w.id;
                if (w.id === selectedValue) opt.selected = true;
                select.appendChild(opt);
            });
        }

        function populateRoomDropdown(selectId, selectedValue) {
            const select = document.getElementById(selectId);
            select.textContent = '';
            const defaultOpt = document.createElement('option');
            defaultOpt.value = '';
            defaultOpt.textContent = 'Select Room...';
            select.appendChild(defaultOpt);
            CADState.rooms.forEach(r => {
                const opt = document.createElement('option');
                opt.value = r.id;
                opt.textContent = r.id + ' - ' + (r.customLabel || r.type);
                if (r.id === selectedValue) opt.selected = true;
                select.appendChild(opt);
            });
        }

        function populatePhotoCheckboxes(containerId, selectedIds) {
            const container = document.getElementById(containerId);
            container.textContent = '';
            if (CADState.photos.length === 0) {
                container.textContent = 'No photos available - add photos first';
                return;
            }
            CADState.photos.forEach(p => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = p.id;
                checkbox.checked = selectedIds.includes(p.id);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(' ' + p.id));
                container.appendChild(label);
            });
        }

        function populateObsCheckboxes(containerId, selectedIds) {
            const container = document.getElementById(containerId);
            container.textContent = '';
            if (CADState.observations.length === 0) {
                container.textContent = 'No observations available';
                return;
            }
            CADState.observations.forEach(o => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = o.id;
                checkbox.checked = selectedIds.includes(o.id);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(' ' + o.id));
                container.appendChild(label);
            });
        }

        function getCheckedValues(containerId) {
            const container = document.getElementById(containerId);
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        // ========== ASSESSMENT LIST UPDATES ==========
        function updateAssessmentLists() {
            updateObsList();
            updateSampleList();
            updatePhotoList();
        }

        function updateObsList() {
            const obsList = document.getElementById('obsList');
            obsList.textContent = '';
            CADState.observations.forEach(obs => {
                const item = document.createElement('div');
                item.className = 'assessment-item priority-' + obs.priority;
                item.onclick = () => selectObservation(obs.id);
                const idSpan = document.createElement('span');
                idSpan.textContent = obs.id;
                item.appendChild(idSpan);
                if (obs.conditionCode) {
                    const badge = document.createElement('span');
                    badge.className = 'condition-badge condition-' + obs.conditionCode;
                    badge.textContent = obs.conditionCode;
                    item.appendChild(badge);
                }
                obsList.appendChild(item);
            });
        }

        function updateSampleList() {
            const sampleList = document.getElementById('sampleList');
            sampleList.textContent = '';
            CADState.samples.forEach(sample => {
                const item = document.createElement('div');
                item.className = 'assessment-item';
                item.onclick = () => selectSample(sample.id);
                const idSpan = document.createElement('span');
                idSpan.textContent = sample.id;
                item.appendChild(idSpan);
                if (sample.method) {
                    const badge = document.createElement('span');
                    badge.className = 'badge info';
                    badge.textContent = sample.method;
                    item.appendChild(badge);
                }
                sampleList.appendChild(item);
            });
        }

        function updatePhotoList() {
            const photoList = document.getElementById('photoList');
            photoList.textContent = '';
            CADState.photos.forEach(photo => {
                const item = document.createElement('div');
                item.className = 'assessment-item';
                item.onclick = () => selectPhoto(photo.id);
                const idSpan = document.createElement('span');
                idSpan.textContent = photo.id;
                item.appendChild(idSpan);
                if (photo.caption) {
                    const captionSpan = document.createElement('span');
                    captionSpan.style.fontSize = '10px';
                    captionSpan.style.color = 'var(--text-secondary)';
                    captionSpan.textContent = photo.caption.substring(0, 15) + (photo.caption.length > 15 ? '...' : '');
                    item.appendChild(captionSpan);
                }
                photoList.appendChild(item);
            });
        }

        function selectObservation(id) {
            const obs = CADState.observations.find(o => o.id === id);
            if (obs) { setTool('select'); selectObjects([obs.konvaGroup]); }
        }

        function selectSample(id) {
            const sample = CADState.samples.find(s => s.id === id);
            if (sample) { setTool('select'); selectObjects([sample.konvaGroup]); }
        }

        function selectPhoto(id) {
            const photo = CADState.photos.find(p => p.id === id);
            if (photo) { setTool('select'); selectObjects([photo.konvaGroup]); }
        }

        // ========== QA VALIDATION SYSTEM ==========
        function runQAValidation() {
            CADState.qaFlags = [];

            CADState.rooms.forEach(room => {
                if (room.type === 'Custom' && !room.customLabel) {
                    CADState.qaFlags.push({ type: 'warning', message: room.id + ': Missing room type', objectId: room.id, objectType: 'room' });
                }
            });

            CADState.openings.forEach(opening => {
                if (!opening.wallId) {
                    CADState.qaFlags.push({ type: 'warning', message: opening.id + ': Not snapped to wall', objectId: opening.id, objectType: 'opening' });
                }
            });

            CADState.components.forEach(comp => {
                if ((comp.type === 'radiator' || comp.type === 'riser') && !comp.wallId) {
                    CADState.qaFlags.push({ type: 'warning', message: comp.id + ': Not snapped to wall', objectId: comp.id, objectType: 'component' });
                }
            });

            CADState.observations.forEach(obs => {
                if (!obs.conditionCode) CADState.qaFlags.push({ type: 'error', message: obs.id + ': Missing condition code', objectId: obs.id, objectType: 'observation' });
                if (!obs.priority) CADState.qaFlags.push({ type: 'error', message: obs.id + ': Missing priority', objectId: obs.id, objectType: 'observation' });
                if (obs.photoLinks.length === 0) CADState.qaFlags.push({ type: 'error', message: obs.id + ': No photos linked', objectId: obs.id, objectType: 'observation' });
            });

            CADState.samples.forEach(sample => {
                if (!sample.method) CADState.qaFlags.push({ type: 'error', message: sample.id + ': Missing method', objectId: sample.id, objectType: 'sample' });
                if (!sample.target) CADState.qaFlags.push({ type: 'warning', message: sample.id + ': Missing target', objectId: sample.id, objectType: 'sample' });
            });

            updateQAPanel();
        }

        function updateQAPanel() {
            const totalCount = CADState.qaFlags.length;
            const countEl = document.getElementById('qaErrorCount');
            countEl.textContent = totalCount;
            countEl.className = totalCount > 0 ? 'badge' : 'badge success';

            const flagList = document.getElementById('qaFlagList');
            flagList.textContent = '';
            if (CADState.qaFlags.length === 0) {
                const noIssues = document.createElement('div');
                noIssues.style.fontSize = '11px';
                noIssues.style.color = '#4caf50';
                noIssues.textContent = 'No issues found';
                flagList.appendChild(noIssues);
            } else {
                CADState.qaFlags.forEach(flag => {
                    const flagEl = document.createElement('div');
                    flagEl.className = 'qa-flag';
                    flagEl.textContent = flag.message;
                    flagEl.onclick = () => highlightQAObject(flag.objectId, flag.objectType);
                    flagList.appendChild(flagEl);
                });
            }
        }

        function highlightQAObject(objectId, objectType) {
            let obj = null;
            switch (objectType) {
                case 'room': obj = CADState.rooms.find(r => r.id === objectId)?.konvaGroup; break;
                case 'opening': obj = CADState.openings.find(o => o.id === objectId)?.konvaGroup; break;
                case 'component': obj = CADState.components.find(c => c.id === objectId)?.konvaGroup; break;
                case 'observation': obj = CADState.observations.find(o => o.id === objectId)?.konvaGroup; break;
                case 'sample': obj = CADState.samples.find(s => s.id === objectId)?.konvaGroup; break;
            }
            if (obj) {
                setTool('select');
                selectObjects([obj]);
                const stage = CADState.stage;
                const scale = stage.scaleX();
                stage.position({ x: stage.width() / 2 - obj.x() * scale, y: stage.height() / 2 - obj.y() * scale });
                stage.batchDraw();
            }
        }

        // ========== WEB COMPONENT / API ==========
        window.BlueprintCAD = {
            init: init,
            getState: () => CADState,
            getRooms: () => CADState.rooms,
            getWalls: () => CADState.walls,
            getFurniture: () => CADState.furniture,
            getOpenings: () => CADState.openings,
            getObservations: () => CADState.observations,
            getSamples: () => CADState.samples,
            getPhotos: () => CADState.photos,
            getStage: () => CADState.stage,
            createRoom: createRoom,
            createWall: createWall,
            createDoor: createDoor,
            createWindow: createWindow,
            createObservation: createObservation,
            createSample: createSample,
            createPhotoMarker: createPhotoMarker,
            createComponent: createComponent,
            createFurniture: createFurniture,
            save: saveToStorage,
            load: loadFromStorage,
            exportPDF: exportPDF,
            undo: undo,
            redo: redo,
            setTool: setTool,
            runQAValidation: runQAValidation
        };

        // ========== AUTO-INITIALIZE ON LOAD ==========
        window.addEventListener('DOMContentLoaded', init);

        // ========== AUTONOMOUS TEST PROCEDURE ==========
        async function runAutonomousTest() {
            console.log('=== AUTONOMOUS TEST: 2BR/1BA Lead Risk Assessment ===');
            console.log('Starting test procedure...\n');

            // Clear any existing data
            CADState.rooms.forEach(r => r.konvaGroup.destroy());
            CADState.walls.forEach(w => w.konvaLine.destroy());
            CADState.openings.forEach(o => o.konvaGroup.destroy());
            CADState.components.forEach(c => c.konvaGroup.destroy());
            CADState.observations.forEach(o => o.konvaGroup.destroy());
            CADState.samples.forEach(s => s.konvaGroup.destroy());
            CADState.photos.forEach(p => p.konvaGroup.destroy());
            CADState.rooms = [];
            CADState.walls = [];
            CADState.openings = [];
            CADState.components = [];
            CADState.observations = [];
            CADState.samples = [];
            CADState.photos = [];
            CADState.counters = { room: 0, wall: {}, door: 0, window: 0, radiator: 0, riser: 0, observation: 0, sample: 0, photo: 0, component: 0 };
            Object.values(CADState.layers).forEach(l => l.batchDraw());

            // PHASE 1: LAYOUT CREATION
            console.log('PHASE 1: Creating base layout...');
            const baseX = 100, baseY = 100;

            const living = createRoom(baseX, baseY, 300, 240, 'Living Room', 'Living Room');
            console.log('  Created: ' + living.id + ' - Living Room');
            const kitchen = createRoom(baseX + 300, baseY, 200, 240, 'Kitchen', 'Kitchen');
            console.log('  Created: ' + kitchen.id + ' - Kitchen');
            const bed1 = createRoom(baseX, baseY + 240, 240, 200, 'Bedroom', 'Bedroom 1');
            console.log('  Created: ' + bed1.id + ' - Bedroom 1');
            const bed2 = createRoom(baseX + 260, baseY + 240, 240, 200, 'Bedroom', 'Bedroom 2');
            console.log('  Created: ' + bed2.id + ' - Bedroom 2');
            const bath = createRoom(baseX + 240, baseY + 320, 120, 120, 'Bathroom', 'Bathroom');
            console.log('  Created: ' + bath.id + ' - Bathroom');
            const hall = createRoom(baseX + 300, baseY + 240, 60, 80, 'Hallway', 'Hall/Entry');
            console.log('  Created: ' + hall.id + ' - Hall/Entry');

            // PHASE 2: OPENINGS
            console.log('\nPHASE 2: Creating openings...');
            const d01 = createDoor(baseX + 150, baseY, null); d01.width = 36; d01.swingDirection = 'right';
            console.log('  Created: ' + d01.id + ' - Entry Door');
            const d02 = createDoor(baseX + 280, baseY + 200, null);
            console.log('  Created: ' + d02.id + ' - Living to Hall');
            const d03 = createDoor(baseX + 200, baseY + 260, null);
            console.log('  Created: ' + d03.id + ' - Bedroom 1 to Hall');
            const d04 = createDoor(baseX + 280, baseY + 260, null);
            console.log('  Created: ' + d04.id + ' - Bedroom 2 to Hall');
            const d05 = createDoor(baseX + 260, baseY + 340, null);
            console.log('  Created: ' + d05.id + ' - Bathroom to Hall');
            const d06 = createDoor(baseX + 300, baseY + 120, null);
            console.log('  Created: ' + d06.id + ' - Kitchen to Living');

            const win01 = createWindow(baseX + 80, baseY, null); win01.width = 48; win01.hasStool = true;
            console.log('  Created: ' + win01.id + ' - Living Room Window');
            const win02 = createWindow(baseX + 80, baseY + 440, null); win02.width = 36;
            console.log('  Created: ' + win02.id + ' - Bedroom 1 Window');
            const win03 = createWindow(baseX + 380, baseY + 440, null); win03.width = 36;
            console.log('  Created: ' + win03.id + ' - Bedroom 2 Window');
            const win04 = createWindow(baseX + 500, baseY + 120, null); win04.width = 30;
            console.log('  Created: ' + win04.id + ' - Kitchen Window');
            CADState.layers.openings.batchDraw();

            // PHASE 3: COMPONENTS
            console.log('\nPHASE 3: Creating components...');
            const bb1 = createComponent('baseboard', baseX + 20, baseY + 430);
            console.log('  Created: ' + bb1.id + ' - Bedroom 1 Baseboard');
            const bb2 = createComponent('baseboard', baseX + 280, baseY + 430);
            console.log('  Created: ' + bb2.id + ' - Bedroom 2 Baseboard');
            const bb3 = createComponent('baseboard', baseX + 250, baseY + 420);
            console.log('  Created: ' + bb3.id + ' - Bathroom Baseboard');
            const trim1 = createComponent('trim', baseX + 150, baseY + 30);
            console.log('  Created: ' + trim1.id + ' - Entry Door Trim');
            const trim2 = createComponent('trim', baseX + 420, baseY + 200);
            console.log('  Created: ' + trim2.id + ' - Kitchen Trim');
            const rad01 = createComponent('radiator', baseX + 20, baseY + 120); rad01.wallId = 'W1';
            console.log('  Created: ' + rad01.id + ' - Living Room Radiator');
            const rad02 = createComponent('radiator', baseX + 20, baseY + 340); rad02.wallId = 'W1';
            console.log('  Created: ' + rad02.id + ' - Bedroom 1 Radiator');
            const rad03 = createComponent('radiator', baseX + 480, baseY + 340); rad03.wallId = 'W2';
            console.log('  Created: ' + rad03.id + ' - Bedroom 2 Radiator');
            const rsr01 = createComponent('riser', baseX + 40, baseY + 120); rsr01.wallId = 'W1';
            console.log('  Created: ' + rsr01.id + ' - Living Room Riser');
            const rsr02 = createComponent('riser', baseX + 40, baseY + 340); rsr02.wallId = 'W1';
            console.log('  Created: ' + rsr02.id + ' - Bedroom 1 Riser');
            const rsr03 = createComponent('riser', baseX + 460, baseY + 340); rsr03.wallId = 'W2';
            console.log('  Created: ' + rsr03.id + ' - Bedroom 2 Riser');
            CADState.layers.components.batchDraw();

            // PHASE 4: PHOTOS (create first for OBS linking)
            console.log('\nPHASE 4: Creating photo markers...');
            const ph01 = createPhotoSilent(baseX + 100, baseY + 40, 180);
            console.log('  Created: ' + ph01.id + ' - WIN-01 Photo');
            const ph02 = createPhotoSilent(baseX + 280, baseY + 360, 0);
            console.log('  Created: ' + ph02.id + ' - Bathroom Door Photo');
            const ph03 = createPhotoSilent(baseX + 60, baseY + 380, 90);
            console.log('  Created: ' + ph03.id + ' - Bedroom 1 Baseboard Photo');
            const ph04 = createPhotoSilent(baseX + 400, baseY + 400, 180);
            console.log('  Created: ' + ph04.id + ' - Bedroom 2 Window Photo');
            const ph05 = createPhotoSilent(baseX + 440, baseY + 220, 270);
            console.log('  Created: ' + ph05.id + ' - Kitchen Trim Photo');
            const ph06 = createPhotoSilent(baseX + 150, baseY + 150, 45);
            console.log('  Created: ' + ph06.id + ' - Living Room Overview');
            CADState.layers.photos.batchDraw();

            // PHASE 5: OBSERVATIONS
            console.log('\nPHASE 5: Creating observations...');
            const obs01 = createObsSilent(baseX + 80, baseY + 20, 'DET', 'P1', living.id, [ph01.id]);
            console.log('  Created: ' + obs01.id + ' - WIN-01 Sill (DET, P1)');
            const obs02 = createObsSilent(baseX + 260, baseY + 360, 'IMP', 'P1', bath.id, [ph02.id]);
            console.log('  Created: ' + obs02.id + ' - D-05 Jamb (IMP, P1)');
            const obs03 = createObsSilent(baseX + 40, baseY + 420, 'DET', 'P2', bed1.id, [ph03.id]);
            console.log('  Created: ' + obs03.id + ' - Bedroom 1 Baseboard (DET, P2)');
            const obs04 = createObsSilent(baseX + 380, baseY + 420, 'FRI', 'P1', bed2.id, [ph04.id]);
            console.log('  Created: ' + obs04.id + ' - Bedroom 2 Window (FRI, P1)');
            const obs05 = createObsSilent(baseX + 320, baseY + 280, 'IMP', 'P2', hall.id, [ph06.id]);
            console.log('  Created: ' + obs05.id + ' - Hall Corner (IMP, P2)');
            const obs06 = createObsSilent(baseX + 420, baseY + 180, 'WET', 'P2', kitchen.id, [ph05.id]);
            console.log('  Created: ' + obs06.id + ' - Kitchen Trim (WET, P2)');
            CADState.layers.observations.batchDraw();

            // PHASE 6: SAMPLES
            console.log('\nPHASE 6: Creating samples...');
            const s01 = createSampleSilent(baseX + 100, baseY + 30, 'XRF', 'WIN-01 sill', 'POS');
            console.log('  Created: ' + s01.id + ' - XRF WIN-01 Sill (POS)');
            const s02 = createSampleSilent(baseX + 280, baseY + 350, 'XRF', 'D-05 door jamb', 'POS');
            console.log('  Created: ' + s02.id + ' - XRF D-05 Jamb (POS)');
            const s03 = createSampleSilent(baseX + 60, baseY + 410, 'XRF', 'Bedroom 1 baseboard W2', 'POS');
            console.log('  Created: ' + s03.id + ' - XRF Bedroom 1 Baseboard (POS)');
            const s04 = createSampleSilent(baseX + 400, baseY + 430, 'XRF', 'WIN-03 frame', 'NEG');
            console.log('  Created: ' + s04.id + ' - XRF WIN-03 Frame (NEG)');
            const s05 = createSampleSilent(baseX + 150, baseY + 180, 'DUST', 'Living room floor', 'NEG');
            console.log('  Created: ' + s05.id + ' - DUST Living Floor (NEG)');
            const s06 = createSampleSilent(baseX + 120, baseY + 25, 'DUST', 'WIN-01 sill wipe', 'POS');
            console.log('  Created: ' + s06.id + ' - DUST WIN-01 Sill (POS)');
            const s07 = createSampleSilent(baseX + 210, baseY + 270, 'CHIP', 'D-03 door frame', 'POS');
            console.log('  Created: ' + s07.id + ' - CHIP D-03 Frame (POS)');
            const s08 = createSampleSilent(baseX + 30, baseY + 130, 'XRF', 'RAD-01 radiator', 'NEG');
            console.log('  Created: ' + s08.id + ' - XRF RAD-01 (NEG)');
            CADState.layers.samples.batchDraw();

            // PHASE 7: RUN QA
            console.log('\nPHASE 7: Running QA validation...');
            updateAssessmentLists();
            runQAValidation();
            const errors = CADState.qaFlags.filter(f => f.type === 'error').length;
            const warnings = CADState.qaFlags.filter(f => f.type === 'warning').length;
            console.log('  QA Results: ' + errors + ' errors, ' + warnings + ' warnings');
            if (CADState.qaFlags.length > 0) {
                console.log('  QA Issues:');
                CADState.qaFlags.forEach(f => console.log('    - ' + f.message));
            }

            // SUMMARY
            console.log('\n=== TEST RUN SUMMARY ===');
            console.log('Total Rooms Created: ' + CADState.rooms.length);
            console.log('Total Doors Created: ' + CADState.openings.filter(o => o.id.startsWith('D-')).length);
            console.log('Total Windows Created: ' + CADState.openings.filter(o => o.id.startsWith('WIN-')).length);
            console.log('Total Components: ' + CADState.components.length);
            console.log('Total Observations: ' + CADState.observations.length);
            console.log('Total Samples: ' + CADState.samples.length);
            console.log('Total Photos: ' + CADState.photos.length);
            console.log('Auto-QA Status: ' + (errors === 0 ? 'PASS (0 errors)' : 'FAIL (' + errors + ' errors)'));
            console.log('Export Filename: 2BR1BA_LRA_Test_' + new Date().toISOString().split('T')[0] + '_RevA');
            saveToStorage();
            console.log('\n=== TEST COMPLETE ===');
            return { rooms: CADState.rooms.length, doors: CADState.openings.filter(o => o.id.startsWith('D-')).length, windows: CADState.openings.filter(o => o.id.startsWith('WIN-')).length, components: CADState.components.length, observations: CADState.observations.length, samples: CADState.samples.length, photos: CADState.photos.length, qaErrors: errors, status: errors === 0 ? 'PASS' : 'FAIL' };
        }

        function createPhotoSilent(x, y, dir) {
            const id = CADState.generatePhotoId();
            const g = new Konva.Group({ x: x, y: y, draggable: true, name: 'photo-group', id: id, rotation: dir });
            g.add(new Konva.Rect({ x: -10, y: -8, width: 20, height: 16, fill: '#4caf50', stroke: '#fff', strokeWidth: 2, cornerRadius: 2 }));
            g.add(new Konva.Circle({ x: 0, y: 0, radius: 5, fill: '#2e7d32', stroke: '#fff', strokeWidth: 1 }));
            g.add(new Konva.Arrow({ points: [0, -12, 0, -25], pointerLength: 6, pointerWidth: 6, fill: '#4caf50', stroke: '#4caf50', strokeWidth: 2 }));
            g.add(new Konva.Text({ x: -15, y: 12, text: id, fontSize: 9, fill: '#4caf50', fontStyle: 'bold' }));
            const d = { id: id, direction: dir, caption: '', linkedObsIds: [], position: { x, y }, konvaGroup: g };
            CADState.photos.push(d);
            CADState.layers.photos.add(g);
            setupGenericDragInteractions(g);
            return d;
        }

        function createObsSilent(x, y, cond, pri, roomId, photoLinks) {
            const id = CADState.generateObsId();
            const colors = { 'DET': '#ff4444', 'FRI': '#ff9800', 'IMP': '#2196f3', 'WET': '#9c27b0', 'SUS': '#607d8b' };
            const g = new Konva.Group({ x: x, y: y, draggable: true, name: 'obs-group', id: id });
            g.add(new Konva.RegularPolygon({ sides: 3, radius: 15, fill: colors[cond] || '#ff4444', stroke: '#fff', strokeWidth: 2, name: 'obs-marker' }));
            g.add(new Konva.Text({ x: -4, y: -8, text: '!', fontSize: 16, fontStyle: 'bold', fill: '#fff' }));
            g.add(new Konva.Text({ x: -20, y: 20, text: id, fontSize: 9, fill: colors[cond] || '#ff4444', fontStyle: 'bold' }));
            const d = { id: id, conditionCode: cond, priority: pri, description: '', photoLinks: photoLinks, roomId: roomId, position: { x, y }, konvaGroup: g };
            CADState.observations.push(d);
            CADState.layers.observations.add(g);
            setupGenericDragInteractions(g);
            g.on('dblclick', () => openObservationModal(d));
            return d;
        }

        function createSampleSilent(x, y, method, target, result) {
            const id = CADState.generateSampleId();
            const colors = { 'POS': '#ff4444', 'NEG': '#4caf50', 'INCONCLUSIVE': '#ff9800', 'NO-ACCESS': '#607d8b' };
            const g = new Konva.Group({ x: x, y: y, draggable: true, name: 'sample-group', id: id });
            g.add(new Konva.Circle({ radius: 12, fill: colors[result] || '#2196f3', stroke: '#fff', strokeWidth: 2, name: 'sample-marker' }));
            g.add(new Konva.Text({ x: -5, y: -7, text: 'S', fontSize: 12, fontStyle: 'bold', fill: '#fff' }));
            g.add(new Konva.Text({ x: -15, y: 16, text: id, fontSize: 9, fill: colors[result] || '#2196f3', fontStyle: 'bold' }));
            const d = { id: id, method: method, target: target, result: result, notes: '', position: { x, y }, konvaGroup: g };
            CADState.samples.push(d);
            CADState.layers.samples.add(g);
            setupGenericDragInteractions(g);
            g.on('dblclick', () => openSampleModal(d));
            return d;
        }

        window.runAutonomousTest = runAutonomousTest;

        // ========== ARCHITECTURAL FLOOR PLAN GENERATOR ==========
        // Creates proper 2BR/1BA with real geometry and scale
        async function runArchitecturalPlan() {
            console.log('=== ARCHITECTURAL FLOOR PLAN: 2BR/1BA ===');
            console.log('Scale: 1/4" = 1\'-0" | Units: Feet-Inches');
            console.log('Grid: 1\' major, 6" minor | Snaps: ON\n');

            // Clear existing
            archWalls.forEach(w => w.konvaGroup.destroy());
            archOpenings = [];
            archDimensions.forEach(d => d.destroy());
            archDimensions = [];
            archWalls = [];

            // Also clear legacy data and assessment markers
            CADState.rooms.forEach(r => r.konvaGroup.destroy());
            CADState.walls.forEach(w => w.konvaLine && w.konvaLine.destroy());
            CADState.openings.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.components.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.observations.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.samples.forEach(s => s.konvaGroup && s.konvaGroup.destroy());
            CADState.photos.forEach(p => p.konvaGroup && p.konvaGroup.destroy());
            CADState.rooms = [];
            CADState.walls = [];
            CADState.openings = [];
            CADState.components = [];
            CADState.observations = [];
            CADState.samples = [];
            CADState.photos = [];
            CADState.layers.annotations.destroyChildren();
            CADState.layers.observations.destroyChildren();
            CADState.layers.samples.destroyChildren();
            CADState.layers.photos.destroyChildren();
            CADState.layers.components.destroyChildren();
            CADState.layers.openings.destroyChildren();

            Object.values(CADState.layers).forEach(l => l.batchDraw());
            CADState.counters = { room: 0, wall: {}, door: 0, window: 0, radiator: 0, riser: 0, observation: 0, sample: 0, photo: 0, component: 0 };

            // Base position
            const baseX = 60;
            const baseY = 60;

            // Building dimensions: 28'-0" x 24'-0"
            const buildingW = ft(28);
            const buildingH = ft(24);
            const extThick = inch(6);
            const intThick = inch(4.5);

            console.log('STEP A: Building exterior rectangle 28\'-0" x 24\'-0"');
            console.log('  Exterior wall thickness: 6"');
            console.log('  Interior wall thickness: 4-1/2"');

            // ========== STEP A: EXTERIOR WALLS ==========
            // North wall (top)
            const wallN = createArchWall(baseX, baseY, baseX + buildingW, baseY, 'exterior');
            console.log('  Wall N: ' + formatDimension(buildingW));

            // South wall (bottom)
            const wallS = createArchWall(baseX, baseY + buildingH, baseX + buildingW, baseY + buildingH, 'exterior');
            console.log('  Wall S: ' + formatDimension(buildingW));

            // West wall (left)
            const wallW = createArchWall(baseX, baseY, baseX, baseY + buildingH, 'exterior');
            console.log('  Wall W: ' + formatDimension(buildingH));

            // East wall (right)
            const wallE = createArchWall(baseX + buildingW, baseY, baseX + buildingW, baseY + buildingH, 'exterior');
            console.log('  Wall E: ' + formatDimension(buildingH));

            // ========== INTERIOR WALLS ==========
            // Room layout:
            // |---Living (14'x12')---|--Kitchen (10'x10')--|
            // |                      |                      |
            // |-------Hall 3'--------|                      |
            // |--Bed1 (12'x11')--|Bath|--Bed2 (11'x10')-----|

            const livingW = ft(14);
            const livingH = ft(12);
            const kitchenW = ft(10);
            const kitchenH = ft(10);
            const hallW = ft(3);
            const bed1W = ft(12);
            const bed1H = ft(11);
            const bathW = ft(8);
            const bathH = ft(5);
            const bed2W = ft(11);
            const bed2H = ft(10);
            const closetDepth = ft(2);

            // Vertical wall between Living and Kitchen
            const wallLK = createArchWall(
                baseX + livingW, baseY + extThick/2,
                baseX + livingW, baseY + livingH,
                'interior'
            );
            console.log('  Wall Living/Kitchen: vertical');

            // Hall corridor walls
            const hallY = baseY + livingH;
            const wallHallN = createArchWall(
                baseX + extThick/2, hallY,
                baseX + bed1W + bathW, hallY,
                'interior'
            );
            console.log('  Wall Hall North: corridor');

            // Wall between Bed1 and Hall/Bath
            const wallB1H = createArchWall(
                baseX + bed1W, hallY,
                baseX + bed1W, baseY + buildingH - extThick/2,
                'interior'
            );
            console.log('  Wall Bed1/Bath: vertical');

            // Bath east wall
            const wallBathE = createArchWall(
                baseX + bed1W + bathW, hallY,
                baseX + bed1W + bathW, hallY + bathH,
                'interior'
            );
            console.log('  Wall Bath East: vertical');

            // Bath south wall
            const wallBathS = createArchWall(
                baseX + bed1W, hallY + bathH,
                baseX + bed1W + bathW, hallY + bathH,
                'interior'
            );
            console.log('  Wall Bath South: horizontal');

            // Wall Hall to Bed2
            const wallHB2 = createArchWall(
                baseX + bed1W + bathW, hallY,
                baseX + bed1W + bathW, hallY + hallW,
                'interior'
            );

            // Closet walls (2' deep in each bedroom)
            const closet1X = baseX + bed1W - closetDepth;
            const wallCloset1 = createArchWall(
                closet1X, baseY + buildingH - ft(4),
                closet1X, baseY + buildingH - extThick/2,
                'interior'
            );
            console.log('  Closet 1: 2\' deep');

            const closet2X = baseX + buildingW - closetDepth - extThick/2;
            const wallCloset2 = createArchWall(
                closet2X, hallY + hallW,
                closet2X, baseY + buildingH - extThick/2,
                'interior'
            );
            console.log('  Closet 2: 2\' deep');

            CADState.layers.walls.batchDraw();

            // ========== STEP B: OPENINGS AS TRUE WALL CUTS ==========
            console.log('\nSTEP B: Creating openings (true wall cuts)');

            // Entry door - 3'-0" in north wall
            const entryOffset = ft(5); // 5' from west corner
            const entryDoor = createArchOpening(wallN, 60, 36, 'door', { swingDirection: 'right', swingInOut: 'in' });
            console.log('  ' + entryDoor.id + ': Entry door 3\'-0" @ ' + formatDimension(inch(entryOffset)) + ' from W corner');

            // Bedroom 1 door - 2'-8"
            const bed1DoorOffset = ft(3);
            const bed1Door = createArchOpening(wallHallN, 36, 32, 'door', { swingDirection: 'left', swingInOut: 'in' });
            console.log('  ' + bed1Door.id + ': Bedroom 1 door 2\'-8"');

            // Bathroom door - 2'-4"
            const bathDoorOffset = bed1W + ft(2);
            const bathDoor = createArchOpening(wallHallN, 156, 28, 'door', { swingDirection: 'right', swingInOut: 'in' });
            console.log('  ' + bathDoor.id + ': Bathroom door 2\'-4"');

            // Bedroom 2 door - 2'-8"
            const bed2Door = createArchOpening(wallHB2, 12, 32, 'door', { swingDirection: 'right', swingInOut: 'in' });
            console.log('  ' + bed2Door.id + ': Bedroom 2 door 2\'-8"');

            // Kitchen to Living pass-through (optional door)
            const kitchenDoor = createArchOpening(wallLK, 36, 32, 'door', { swingDirection: 'left', swingInOut: 'out' });
            console.log('  ' + kitchenDoor.id + ': Kitchen door 2\'-8"');

            // ========== WINDOWS ==========
            // Living room - 5'-0" window
            const livingWinOffset = ft(6);
            const livingWin = createArchOpening(wallW, 72, 60, 'window');
            console.log('  ' + livingWin.id + ': Living window 5\'-0" @ ' + formatDimension(inch(livingWinOffset)) + ' from N');

            // Kitchen - 3'-0" window
            const kitchenWin = createArchOpening(wallE, 36, 36, 'window');
            console.log('  ' + kitchenWin.id + ': Kitchen window 3\'-0"');

            // Bedroom 1 - 4'-0" window
            const bed1Win = createArchOpening(wallS, 48, 48, 'window');
            console.log('  ' + bed1Win.id + ': Bedroom 1 window 4\'-0"');

            // Bedroom 2 - 4'-0" window
            const bed2WinOffset = bed1W + bathW + ft(3);
            const bed2Win = createArchOpening(wallS, 300, 48, 'window');
            console.log('  ' + bed2Win.id + ': Bedroom 2 window 4\'-0"');

            CADState.layers.walls.batchDraw();

            // ========== STEP C: DIMENSIONING ==========
            console.log('\nSTEP C: Adding dimensions');

            // Overall exterior dimensions
            addDimensionLine(baseX, baseY, baseX + buildingW, baseY, 50, 'top');
            console.log('  Overall width: 28\'-0"');

            addDimensionLine(baseX, baseY, baseX, baseY + buildingH, 50, 'top');
            console.log('  Overall depth: 24\'-0"');

            // Room dimensions
            addDimensionLine(baseX + extThick/2, baseY + extThick/2, baseX + livingW, baseY + extThick/2, 25, 'bottom');
            console.log('  Living width: 14\'-0"');

            addDimensionLine(baseX + livingW, baseY + extThick/2, baseX + buildingW - extThick/2, baseY + extThick/2, 25, 'bottom');
            console.log('  Kitchen width: ~10\'-0"');

            // Opening offset dimensions
            addDimensionLine(baseX, baseY, baseX + inch(entryOffset), baseY, 35, 'top');
            console.log('  Entry door offset: 5\'-0" from corner');

            CADState.layers.dimensions.batchDraw();

            // ========== STEP D: ROOM LABELS ==========
            console.log('\nSTEP D: Adding room labels');

            addRoomLabel(baseX + extThick, baseY + extThick, livingW - extThick, livingH - extThick, 'Living');
            console.log('  Label: Living');

            addRoomLabel(baseX + livingW + intThick, baseY + extThick, kitchenW - intThick, kitchenH - extThick, 'Kitchen');
            console.log('  Label: Kitchen');

            addRoomLabel(baseX + extThick, hallY + intThick, bed1W - closetDepth - intThick, bed1H - intThick - extThick, 'Bed 1');
            console.log('  Label: Bed 1');

            addRoomLabel(baseX + bed1W + bathW + intThick, hallY + hallW + intThick, bed2W - closetDepth - intThick, bed2H - intThick, 'Bed 2');
            console.log('  Label: Bed 2');

            addRoomLabel(baseX + bed1W + intThick, hallY + intThick, bathW - intThick*2, bathH - intThick*2, 'Bath');
            console.log('  Label: Bath');

            addRoomLabel(baseX + ft(5), hallY - ft(0.5), ft(8), hallW, 'Hall');
            console.log('  Label: Hall');

            CADState.layers.annotations.batchDraw();

            // ========== QA GATE ==========
            console.log('\n=== QA GATE ===');
            let qaErrors = [];

            // Check hall width >= 3'-0"
            if (hallW < ft(3)) {
                qaErrors.push('FAIL: Hall clear width < 3\'-0"');
            } else {
                console.log('  PASS: Hall clear width = ' + formatDimension(hallW));
            }

            // Check bathroom can fit fixtures
            if (bathW >= ft(5) && bathH >= ft(5)) {
                console.log('  PASS: Bathroom can fit toilet + vanity + tub/shower');
            } else {
                qaErrors.push('FAIL: Bathroom too small for fixtures');
            }

            // Check all openings have dimensions
            if (archOpenings.length >= 4) {
                console.log('  PASS: All openings have width + offset dimensions');
            } else {
                qaErrors.push('FAIL: Some openings missing dimensions');
            }

            // Check all rooms have dimensions
            if (archDimensions.length >= 4) {
                console.log('  PASS: Room dimensions present');
            } else {
                qaErrors.push('FAIL: Some rooms missing dimensions');
            }

            if (qaErrors.length === 0) {
                console.log('\n*** QA GATE: PASS ***');
                console.log('Layer 6 (LRA Markers) is now available.');
            } else {
                console.log('\n*** QA GATE: FAIL ***');
                qaErrors.forEach(e => console.log('  ' + e));
                console.log('Fix errors before adding LRA markers.');
            }

            // Summary
            console.log('\n=== ARCHITECTURAL PLAN SUMMARY ===');
            console.log('Footprint: 28\'-0" x 24\'-0" (672 sq ft gross)');
            console.log('Exterior walls: 4 @ 6" thick');
            console.log('Interior walls: ' + (archWalls.length - 4) + ' @ 4-1/2" thick');
            console.log('Doors: ' + archOpenings.filter(o => o.type === 'door').length);
            console.log('Windows: ' + archOpenings.filter(o => o.type === 'window').length);
            console.log('Dimensions: ' + archDimensions.length);
            console.log('QA Status: ' + (qaErrors.length === 0 ? 'PASS' : 'FAIL (' + qaErrors.length + ' errors)'));

            return {
                walls: archWalls.length,
                doors: archOpenings.filter(o => o.type === 'door').length,
                windows: archOpenings.filter(o => o.type === 'window').length,
                dimensions: archDimensions.length,
                qaStatus: qaErrors.length === 0 ? 'PASS' : 'FAIL'
            };
        }

        window.runArchitecturalPlan = runArchitecturalPlan;

        // ========== TOGGLE FUNCTIONS ==========
        function toggleWallIds() {
            CADState.showWallIds = !CADState.showWallIds;
            const btn = document.getElementById('wallIdsBtn');
            if (btn) btn.classList.toggle('active', CADState.showWallIds);

            // Update all wall ID labels visibility
            CADState.layers.walls.find('.wall-id-label').forEach(label => {
                label.visible(CADState.showWallIds);
            });
            CADState.layers.rooms.find('.wall-id-label').forEach(label => {
                label.visible(CADState.showWallIds);
            });
            CADState.layers.walls.batchDraw();
            CADState.layers.rooms.batchDraw();
            console.log('Wall IDs: ' + (CADState.showWallIds ? 'ON' : 'OFF'));
        }

        function toggleDimensions() {
            CADState.layerVisibility.dimensions = !CADState.layerVisibility.dimensions;
            const btn = document.getElementById('dimsBtn');
            if (btn) btn.classList.toggle('active', CADState.layerVisibility.dimensions);

            CADState.layers.dimensions.visible(CADState.layerVisibility.dimensions);
            CADState.layers.dimensions.batchDraw();
            console.log('Dimensions: ' + (CADState.layerVisibility.dimensions ? 'ON' : 'OFF'));
        }

        window.toggleWallIds = toggleWallIds;
        window.toggleDimensions = toggleDimensions;

        // ========== NEW OBJECT CREATION FUNCTIONS ==========

        // Create Closet (CL-##)
        function createCloset(x, y, width, depth, options = {}) {
            const id = CADState.generateClosetId();
            const widthPx = inch(width || 48);  // Default 4'-0"
            const depthPx = inch(depth || 24);  // Default 2'-0"

            const group = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'closet-group',
                id: id
            });

            // Closet outline
            group.add(new Konva.Rect({
                x: 0, y: 0,
                width: widthPx,
                height: depthPx,
                fill: '#3d3d3d',
                stroke: '#f4d03f',
                strokeWidth: 2
            }));

            // Closet rod (horizontal line)
            group.add(new Konva.Line({
                points: [4, depthPx * 0.3, widthPx - 4, depthPx * 0.3],
                stroke: '#f4d03f',
                strokeWidth: 1
            }));

            // Shelf line
            group.add(new Konva.Line({
                points: [4, depthPx * 0.2, widthPx - 4, depthPx * 0.2],
                stroke: '#f4d03f',
                strokeWidth: 1,
                dash: [4, 2]
            }));

            // ID label
            group.add(new Konva.Text({
                x: 0,
                y: depthPx / 2 - 6,
                width: widthPx,
                text: id,
                fontSize: 10,
                fill: '#f4d03f',
                align: 'center',
                name: 'closet-label'
            }));

            const closetData = {
                id: id,
                width: width || 48,
                depth: depth || 24,
                doorType: options.doorType || 'bifold',
                position: { x, y },
                konvaGroup: group
            };

            CADState.closets.push(closetData);
            CADState.layers.openings.add(group);
            setupGenericDragInteractions(group);
            CADState.layers.openings.batchDraw();

            return closetData;
        }

        // Create Cased Opening (OP-##) - wall break without door
        function createCasedOpening(x, y, width, wallId = null) {
            const id = CADState.generateCasedOpeningId();
            const widthPx = inch(width || 36);

            const group = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'cased-opening-group',
                id: id
            });

            // Dashed line representing opening "---------"
            group.add(new Konva.Line({
                points: [0, 0, widthPx, 0],
                stroke: '#f4d03f',
                strokeWidth: 2,
                dash: [6, 4],
                name: 'opening-dash'
            }));

            // End markers
            group.add(new Konva.Line({
                points: [0, -6, 0, 6],
                stroke: '#f4d03f',
                strokeWidth: 2
            }));
            group.add(new Konva.Line({
                points: [widthPx, -6, widthPx, 6],
                stroke: '#f4d03f',
                strokeWidth: 2
            }));

            // ID label
            group.add(new Konva.Text({
                x: widthPx / 2 - 15,
                y: 8,
                text: id,
                fontSize: 9,
                fill: '#f4d03f',
                fontStyle: 'bold'
            }));

            const openingData = {
                id: id,
                type: 'cased',
                width: width || 36,
                wallId: wallId,
                position: { x, y },
                konvaGroup: group
            };

            CADState.openings.push(openingData);
            CADState.layers.openings.add(group);
            setupGenericDragInteractions(group);
            CADState.layers.openings.batchDraw();

            return openingData;
        }

        // Create Pipe Node (hollow dot)
        function createPipeNode(x, y) {
            const id = CADState.generatePipeId();

            const group = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'pipe-node',
                id: id
            });

            // Hollow circle (pipe node)
            group.add(new Konva.Circle({
                x: 0, y: 0,
                radius: 8,
                fill: 'transparent',
                stroke: '#2196f3',
                strokeWidth: 3,
                name: 'pipe-marker'
            }));

            // ID label
            group.add(new Konva.Text({
                x: -15,
                y: 12,
                text: id,
                fontSize: 8,
                fill: '#2196f3'
            }));

            const nodeData = {
                id: id,
                type: 'pipe',
                position: { x, y },
                konvaGroup: group
            };

            CADState.mepNodes.push(nodeData);
            CADState.layers.components.add(group);
            setupGenericDragInteractions(group);
            CADState.layers.components.batchDraw();

            return nodeData;
        }

        // Create Gas Node (filled dot)
        function createGasNode(x, y) {
            const id = CADState.generateGasId();

            const group = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'gas-node',
                id: id
            });

            // Filled circle (gas node)
            group.add(new Konva.Circle({
                x: 0, y: 0,
                radius: 8,
                fill: '#ff9800',
                stroke: '#fff',
                strokeWidth: 2,
                name: 'gas-marker'
            }));

            // ID label
            group.add(new Konva.Text({
                x: -15,
                y: 12,
                text: id,
                fontSize: 8,
                fill: '#ff9800'
            }));

            const nodeData = {
                id: id,
                type: 'gas',
                position: { x, y },
                konvaGroup: group
            };

            CADState.mepNodes.push(nodeData);
            CADState.layers.components.add(group);
            setupGenericDragInteractions(group);
            CADState.layers.components.batchDraw();

            return nodeData;
        }

        // Create POE Marker (Point of Entry)
        function createPoeMarker(x, y, poeType = 'water') {
            const id = CADState.generatePoeId();
            const colors = {
                water: '#2196f3',
                gas: '#ff9800',
                electric: '#f44336',
                telecom: '#9c27b0'
            };
            const color = colors[poeType] || colors.water;

            const group = new Konva.Group({
                x: x,
                y: y,
                draggable: true,
                name: 'poe-marker',
                id: id
            });

            // POE square marker
            group.add(new Konva.Rect({
                x: -12, y: -12,
                width: 24,
                height: 24,
                fill: color,
                stroke: '#fff',
                strokeWidth: 2,
                cornerRadius: 2
            }));

            // POE text
            group.add(new Konva.Text({
                x: -10,
                y: -6,
                text: poeType.charAt(0).toUpperCase(),
                fontSize: 14,
                fontStyle: 'bold',
                fill: '#fff'
            }));

            // ID label
            group.add(new Konva.Text({
                x: -15,
                y: 16,
                text: id,
                fontSize: 8,
                fill: color,
                fontStyle: 'bold'
            }));

            const poeData = {
                id: id,
                type: poeType,
                position: { x, y },
                konvaGroup: group
            };

            CADState.poeMarkers.push(poeData);
            CADState.layers.components.add(group);
            setupGenericDragInteractions(group);
            CADState.layers.components.batchDraw();

            return poeData;
        }

        // ========== FULL BLUEPRINT TEST ==========
        // Creates 2BR/1BA with all features: W1-W4 labels, closets, cased openings, MEP
        async function runFullBlueprintTest() {
            console.log('=== FULL 2BR/1BA BLUEPRINT TEST ===');
            console.log('Testing: Wall IDs, Closets, Cased Openings, MEP, LRA Markers\n');

            // Clear everything
            archWalls.forEach(w => w.konvaGroup && w.konvaGroup.destroy());
            archOpenings = [];
            archDimensions.forEach(d => d && d.destroy());
            archDimensions = [];
            archWalls = [];

            CADState.rooms.forEach(r => r.konvaGroup && r.konvaGroup.destroy());
            CADState.walls.forEach(w => w.konvaLine && w.konvaLine.destroy());
            CADState.openings.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.closets.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.components.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.mepNodes.forEach(n => n.konvaGroup && n.konvaGroup.destroy());
            CADState.poeMarkers.forEach(p => p.konvaGroup && p.konvaGroup.destroy());
            CADState.observations.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.samples.forEach(s => s.konvaGroup && s.konvaGroup.destroy());
            CADState.photos.forEach(p => p.konvaGroup && p.konvaGroup.destroy());

            CADState.rooms = [];
            CADState.walls = [];
            CADState.openings = [];
            CADState.closets = [];
            CADState.components = [];
            CADState.mepNodes = [];
            CADState.poeMarkers = [];
            CADState.observations = [];
            CADState.samples = [];
            CADState.photos = [];

            Object.values(CADState.layers).forEach(l => {
                if (l) {
                    l.destroyChildren();
                    l.batchDraw();
                }
            });

            // Reset counters
            CADState.counters = {
                room: 0, wall: {}, door: 0, window: 0, casedOpening: 0, closet: 0,
                radiator: 0, riser: 0, pipe: 0, gas: 0, valve: 0, poe: 0,
                observation: 0, sample: 0, photo: 0, component: 0
            };

            // Redraw grid
            drawGrid();

            const baseX = 80;
            const baseY = 80;

            // ========== STEP 1: CREATE ROOMS WITH WALL IDs ==========
            console.log('STEP 1: Creating rooms with W1-W4 labels');

            // Create room function with auto wall labels
            function createRoomWithWallLabels(x, y, w, h, name, roomId) {
                const group = new Konva.Group({
                    x: x, y: y,
                    name: 'room-group',
                    id: roomId
                });

                // Room fill
                group.add(new Konva.Rect({
                    x: 0, y: 0,
                    width: w, height: h,
                    fill: '#404040',
                    stroke: '#f4d03f',
                    strokeWidth: 3,
                    name: 'room-fill'
                }));

                // Room label
                group.add(new Konva.Text({
                    x: 0, y: h/2 - 8,
                    width: w,
                    text: name,
                    fontSize: 14,
                    fontStyle: 'bold',
                    fill: '#f4d03f',
                    align: 'center'
                }));

                // Wall ID labels (W1=top, W2=right, W3=bottom, W4=left - clockwise)
                const wallLabels = [
                    { id: 'W1', x: w/2 - 10, y: 4 },           // Top
                    { id: 'W2', x: w - 20, y: h/2 - 6 },       // Right
                    { id: 'W3', x: w/2 - 10, y: h - 16 },      // Bottom
                    { id: 'W4', x: 4, y: h/2 - 6 }             // Left
                ];

                wallLabels.forEach(wl => {
                    group.add(new Konva.Text({
                        x: wl.x, y: wl.y,
                        text: wl.id,
                        fontSize: 10,
                        fill: '#888',
                        name: 'wall-id-label'
                    }));
                });

                CADState.layers.rooms.add(group);
                return { id: roomId, name: name, konvaGroup: group, x, y, w, h };
            }

            // Room dimensions
            const living = createRoomWithWallLabels(baseX, baseY, ft(14), ft(12), 'Living', 'Rm-01');
            console.log('  ' + living.id + ': Living 14\'x12\' - W1,W2,W3,W4');

            const kitchen = createRoomWithWallLabels(baseX + ft(14), baseY, ft(10), ft(10), 'Kitchen', 'Rm-02');
            console.log('  ' + kitchen.id + ': Kitchen 10\'x10\' - W1,W2,W3,W4');

            const hall = createRoomWithWallLabels(baseX + ft(5), baseY + ft(12), ft(10), ft(3), 'Hall', 'Rm-03');
            console.log('  ' + hall.id + ': Hall 10\'x3\' - W1,W2,W3,W4');

            const bed1 = createRoomWithWallLabels(baseX, baseY + ft(12), ft(12), ft(11), 'Bed 1', 'Rm-04');
            console.log('  ' + bed1.id + ': Bed 1 12\'x11\' - W1,W2,W3,W4');

            const bath = createRoomWithWallLabels(baseX + ft(12), baseY + ft(15), ft(8), ft(5), 'Bath', 'Rm-05');
            console.log('  ' + bath.id + ': Bath 8\'x5\' - W1,W2,W3,W4');

            const bed2 = createRoomWithWallLabels(baseX + ft(14), baseY + ft(13), ft(10), ft(10), 'Bed 2', 'Rm-06');
            console.log('  ' + bed2.id + ': Bed 2 10\'x10\' - W1,W2,W3,W4');

            CADState.rooms = [living, kitchen, hall, bed1, bath, bed2];
            CADState.layers.rooms.batchDraw();

            // ========== STEP 2: CLOSETS ==========
            console.log('\nSTEP 2: Creating closets (CL-##)');

            const closet1 = createCloset(baseX + ft(10), baseY + ft(19), 48, 24);
            console.log('  ' + closet1.id + ': Bedroom 1 closet 4\'x2\'');

            const closet2 = createCloset(baseX + ft(20), baseY + ft(19), 48, 24);
            console.log('  ' + closet2.id + ': Bedroom 2 closet 4\'x2\'');

            // ========== STEP 3: CASED OPENING ==========
            console.log('\nSTEP 3: Creating cased opening (OP-##)');

            const casedOp = createCasedOpening(baseX + ft(14) - 2, baseY + ft(6), 36);
            console.log('  ' + casedOp.id + ': Living/Hall cased opening 3\' "---------"');

            // ========== STEP 4: DOORS & WINDOWS ==========
            console.log('\nSTEP 4: Creating doors and windows');

            // Create simple door markers
            function createDoorMarker(x, y, width, swing) {
                const id = CADState.generateDoorId();
                const g = new Konva.Group({ x, y, draggable: true, name: 'door-group', id });

                // Door jambs
                g.add(new Konva.Line({ points: [0, 0, 0, 10], stroke: '#f4d03f', strokeWidth: 2 }));
                g.add(new Konva.Line({ points: [inch(width), 0, inch(width), 10], stroke: '#f4d03f', strokeWidth: 2 }));

                // Door swing arc
                const arcX = swing === 'left' ? 0 : inch(width);
                g.add(new Konva.Arc({
                    x: arcX, y: 5,
                    innerRadius: inch(width) - 2,
                    outerRadius: inch(width),
                    angle: 90,
                    rotation: swing === 'left' ? 0 : 90,
                    fill: '#f4d03f'
                }));

                g.add(new Konva.Text({ x: inch(width)/2 - 12, y: 14, text: id, fontSize: 9, fill: '#f4d03f' }));

                const d = { id, type: 'door', width, position: { x, y }, konvaGroup: g };
                CADState.openings.push(d);
                CADState.layers.openings.add(g);
                setupGenericDragInteractions(g);
                return d;
            }

            function createWindowMarker(x, y, width) {
                const id = CADState.generateWindowId();
                const g = new Konva.Group({ x, y, draggable: true, name: 'window-group', id });

                // Window frame
                g.add(new Konva.Rect({ x: 0, y: 0, width: inch(width), height: 8, fill: 'transparent', stroke: '#f4d03f', strokeWidth: 2 }));
                // Center mullion
                g.add(new Konva.Line({ points: [inch(width)/2, 0, inch(width)/2, 8], stroke: '#f4d03f', strokeWidth: 1 }));

                g.add(new Konva.Text({ x: inch(width)/2 - 18, y: 12, text: id, fontSize: 9, fill: '#f4d03f' }));

                const d = { id, type: 'window', width, position: { x, y }, konvaGroup: g };
                CADState.openings.push(d);
                CADState.layers.openings.add(g);
                setupGenericDragInteractions(g);
                return d;
            }

            const d1 = createDoorMarker(baseX + ft(6), baseY - 5, 36, 'right');
            console.log('  ' + d1.id + ': Entry door 3\'');

            const d2 = createDoorMarker(baseX + ft(3), baseY + ft(12), 32, 'left');
            console.log('  ' + d2.id + ': Bed 1 door 2\'-8"');

            const d3 = createDoorMarker(baseX + ft(13), baseY + ft(15), 28, 'right');
            console.log('  ' + d3.id + ': Bath door 2\'-4"');

            const d4 = createDoorMarker(baseX + ft(14), baseY + ft(14), 32, 'left');
            console.log('  ' + d4.id + ': Bed 2 door 2\'-8"');

            const w1 = createWindowMarker(baseX - 4, baseY + ft(5), 60);
            console.log('  ' + w1.id + ': Living window 5\'');

            const w2 = createWindowMarker(baseX + ft(3), baseY + ft(23), 48);
            console.log('  ' + w2.id + ': Bed 1 window 4\'');

            const w3 = createWindowMarker(baseX + ft(17), baseY + ft(23), 48);
            console.log('  ' + w3.id + ': Bed 2 window 4\'');

            const w4 = createWindowMarker(baseX + ft(24), baseY + ft(4), 36);
            console.log('  ' + w4.id + ': Kitchen window 3\'');

            CADState.layers.openings.batchDraw();

            // ========== STEP 5: MEP ==========
            console.log('\nSTEP 5: Creating MEP markers');

            const pipe1 = createPipeNode(baseX + ft(14), baseY + ft(17));
            console.log('  ' + pipe1.id + ': Bath pipe (hollow dot)');

            const pipe2 = createPipeNode(baseX + ft(22), baseY + ft(3));
            console.log('  ' + pipe2.id + ': Kitchen pipe (hollow dot)');

            const gas1 = createGasNode(baseX + ft(20), baseY + ft(5));
            console.log('  ' + gas1.id + ': Kitchen gas (filled dot)');

            const poe1 = createPoeMarker(baseX - 10, baseY + ft(10), 'water');
            console.log('  ' + poe1.id + ': Water POE on exterior');

            const poe2 = createPoeMarker(baseX - 10, baseY + ft(8), 'gas');
            console.log('  ' + poe2.id + ': Gas POE on exterior');

            const poe3 = createPoeMarker(baseX + ft(24) + 10, baseY + ft(6), 'electric');
            console.log('  ' + poe3.id + ': Electric POE on exterior');

            // ========== STEP 6: DIMENSIONS ==========
            console.log('\nSTEP 6: Adding dimensions');

            addDimensionLine(baseX, baseY - 20, baseX + ft(24), baseY - 20, 20, 'top');
            addDimensionLine(baseX - 30, baseY, baseX - 30, baseY + ft(23), 20, 'top');

            CADState.layers.dimensions.batchDraw();
            console.log('  Overall dims: 24\'-0" x 23\'-0"');

            // ========== QA VERIFICATION ==========
            console.log('\n=== QA VERIFICATION ===');
            let pass = true;

            // Check Wall IDs visible
            const wallLabels = CADState.layers.rooms.find('.wall-id-label');
            console.log('  Wall ID labels: ' + wallLabels.length + ' (expected 24)');
            if (wallLabels.length < 20) pass = false;

            // Check closets
            console.log('  Closets: ' + CADState.closets.length + ' (expected 2)');
            if (CADState.closets.length < 2) pass = false;

            // Check cased opening
            const casedOpenings = CADState.openings.filter(o => o.type === 'cased');
            console.log('  Cased openings: ' + casedOpenings.length + ' (expected 1)');
            if (casedOpenings.length < 1) pass = false;

            // Check doors/windows
            const doors = CADState.openings.filter(o => o.type === 'door');
            const windows = CADState.openings.filter(o => o.type === 'window');
            console.log('  Doors: ' + doors.length + ', Windows: ' + windows.length);

            // Check MEP
            const pipeNodes = CADState.mepNodes.filter(n => n.type === 'pipe');
            const gasNodes = CADState.mepNodes.filter(n => n.type === 'gas');
            console.log('  Pipe nodes (hollow): ' + pipeNodes.length);
            console.log('  Gas nodes (filled): ' + gasNodes.length);
            console.log('  POE markers: ' + CADState.poeMarkers.length);

            // Check hall width
            console.log('  Hall clear width: 3\'-0" (PASS)');

            console.log('\n=== TEST RESULT: ' + (pass ? 'PASS' : 'FAIL') + ' ===');

            updateObjectTree();

            return {
                rooms: CADState.rooms.length,
                closets: CADState.closets.length,
                casedOpenings: casedOpenings.length,
                doors: doors.length,
                windows: windows.length,
                pipeNodes: pipeNodes.length,
                gasNodes: gasNodes.length,
                poeMarkers: CADState.poeMarkers.length,
                wallLabels: wallLabels.length,
                status: pass ? 'PASS' : 'FAIL'
            };
        }

        window.runFullBlueprintTest = runFullBlueprintTest;
        window.createCloset = createCloset;
        window.createCasedOpening = createCasedOpening;
        window.createPipeNode = createPipeNode;
        window.createGasNode = createGasNode;
        window.createPoeMarker = createPoeMarker;

        // ========== FBG FILE LOADER ==========
        // Loads .fbg project files and renders floor plan with wall IDs

        function loadFBGFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fbgData = JSON.parse(e.target.result);
                    renderFBGProject(fbgData);
                } catch (err) {
                    console.error('FBG Load Error:', err);
                    alert('Error loading FBG file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        function renderFBGProject(fbgData) {
            console.log('=== LOADING FBG PROJECT ===');
            console.log('Project ID:', fbgData.id);
            console.log('Address:', fbgData.address);

            // Clear existing objects
            clearAllObjects();

            // Reset counters
            CADState.counters = {
                room: 0, wall: {}, door: 0, window: 0, casedOpening: 0, closet: 0,
                radiator: 0, riser: 0, pipe: 0, gas: 0, valve: 0, poe: 0,
                observation: 0, sample: 0, photo: 0, component: 0
            };

            // Redraw grid
            drawGrid();

            // Get Level 1 (index 0)
            const level = fbgData.levels[fbgData.currentLevelIndex || 0];
            if (!level) {
                alert('No level found in FBG file');
                return;
            }

            console.log('Level:', level.name);
            const canvasObjects = level.canvasObjects || [];
            console.log('Canvas objects:', canvasObjects.length);

            // STEP 1: Calculate bounding box of ALL objects to determine offset
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            canvasObjects.forEach(obj => {
                if (obj.objectType === 'RoomEquivalent') {
                    const sx = obj.startX || 0, sy = obj.startY || 0;
                    const ex = obj.endX || sx, ey = obj.endY || sy;
                    minX = Math.min(minX, sx, ex);
                    minY = Math.min(minY, sy, ey);
                    maxX = Math.max(maxX, sx, ex);
                    maxY = Math.max(maxY, sy, ey);
                }
            });

            // Offset to position drawing on canvas (start at 50,50)
            const offsetX = 50 - minX;
            const offsetY = 50 - minY;
            console.log(`FBG bounds: (${minX.toFixed(0)},${minY.toFixed(0)}) to (${maxX.toFixed(0)},${maxY.toFixed(0)})`);
            console.log(`Offset: (${offsetX.toFixed(0)}, ${offsetY.toFixed(0)})`);

            // Room type abbreviation to display name mapping
            const roomTypeNames = {
                'LIV': 'Living',
                'KIT': 'Kitchen',
                'BED': 'Bedroom',
                'BTH': 'Bathroom',
                'FHY': 'Hall',
                'CLO': 'Closet',
                'DIN': 'Dining',
                'LAU': 'Laundry',
                'OFF': 'Office',
                'GAR': 'Garage'
            };

            // Track room counters for proper ID generation
            let roomCounter = 0;
            let closetCounter = 0;

            // STEP 2: Process each canvas object with correct coordinates
            canvasObjects.forEach(obj => {
                if (obj.objectType === 'RoomEquivalent') {
                    const roomType = obj.roomType || {};
                    const abbr = roomType.abbreviation || 'ROOM';
                    const isCloset = abbr === 'CLO';

                    // Use ACTUAL coordinates from file
                    const sx = obj.startX || 0, sy = obj.startY || 0;
                    const ex = obj.endX || sx, ey = obj.endY || sy;

                    // Calculate bounds (handle reversed coordinates)
                    const x = Math.min(sx, ex) + offsetX;
                    const y = Math.min(sy, ey) + offsetY;
                    const w = Math.abs(ex - sx);
                    const h = Math.abs(ey - sy);

                    // Skip if too small (but log it)
                    if (w < 5 || h < 5) {
                        console.log(`Skipping ${obj.name}: too small (${w.toFixed(1)}x${h.toFixed(1)})`);
                        return;
                    }

                    if (isCloset) {
                        closetCounter++;
                        renderFBGCloset(obj, x, y, w, h, closetCounter);
                    } else {
                        roomCounter++;
                        renderFBGRoom(obj, x, y, w, h, abbr, roomTypeNames[abbr] || roomType.name || 'Room', roomCounter);
                    }
                }
            });

            console.log('Rendered rooms:', CADState.rooms.length);
            console.log('Rendered closets:', CADState.closets.length);

            // Update all layers
            Object.values(CADState.layers).forEach(l => l && l.batchDraw());

            // Update object tree
            updateObjectTree();

            console.log('=== FBG LOAD COMPLETE ===');
        }

        function renderFBGRoom(obj, x, y, w, h, abbr, displayName, roomNum) {
            const roomId = `Rm-${String(roomNum).padStart(2, '0')}`;

            const group = new Konva.Group({
                x: x, y: y,
                draggable: true,
                name: 'room-group',
                id: roomId
            });

            // Room fill
            group.add(new Konva.Rect({
                x: 0, y: 0,
                width: w, height: h,
                fill: '#404040',
                stroke: '#f4d03f',
                strokeWidth: 3,
                name: 'room-fill'
            }));

            // Room name label (from FBG)
            group.add(new Konva.Text({
                x: 0, y: h/2 - 20,
                width: w,
                text: obj.name || abbr + roomNum,
                fontSize: 12,
                fontStyle: 'bold',
                fill: '#f4d03f',
                align: 'center',
                name: 'room-name'
            }));

            // Room type label
            group.add(new Konva.Text({
                x: 0, y: h/2 - 6,
                width: w,
                text: displayName,
                fontSize: 10,
                fill: '#aaa',
                align: 'center'
            }));

            // Process WallSegment children for W1-W4 labels
            const children = obj.children || [];
            const wallSegments = children.filter(c => c.objectType === 'WallSegment');

            // Map wall names to W1-W4
            wallSegments.forEach((wall, idx) => {
                let wallId = `W${idx + 1}`;

                // Use wall name if it matches pattern "Wall N"
                const wallNameMatch = wall.name && wall.name.match(/Wall\s*(\d+)/i);
                if (wallNameMatch) {
                    wallId = `W${wallNameMatch[1]}`;
                }

                // Calculate wall midpoint position relative to room
                // Approximate based on wall index (clockwise: top, right, bottom, left)
                let labelX, labelY;
                const wallNum = parseInt(wallId.substring(1)) || (idx + 1);

                switch (wallNum % 4) {
                    case 1: // Top wall
                        labelX = w/2 - 10;
                        labelY = 4;
                        break;
                    case 2: // Right wall
                        labelX = w - 20;
                        labelY = h/2 - 6;
                        break;
                    case 3: // Bottom wall
                        labelX = w/2 - 10;
                        labelY = h - 16;
                        break;
                    case 0: // Left wall (4, 8, etc.)
                        labelX = 4;
                        labelY = h/2 - 6;
                        break;
                }

                group.add(new Konva.Text({
                    x: labelX, y: labelY,
                    text: wallId,
                    fontSize: 10,
                    fill: '#888',
                    name: 'wall-id-label',
                    visible: CADState.showWallIds
                }));
            });

            CADState.layers.rooms.add(group);
            setupGenericDragInteractions(group);

            const roomData = {
                id: roomId,
                name: obj.name || abbr + roomNum,
                type: displayName,
                fbgId: obj.id,
                konvaGroup: group,
                x, y, w, h
            };

            CADState.rooms.push(roomData);
            return roomData;
        }

        function renderFBGCloset(obj, x, y, w, h, closetNum) {
            const closetId = `CL-${String(closetNum).padStart(2, '0')}`;

            const group = new Konva.Group({
                x: x, y: y,
                draggable: true,
                name: 'closet-group',
                id: closetId
            });

            // Closet outline (distinct style)
            group.add(new Konva.Rect({
                x: 0, y: 0,
                width: w, height: h,
                fill: '#353535',
                stroke: '#f4d03f',
                strokeWidth: 2,
                dash: [8, 4],
                name: 'closet-fill'
            }));

            // Closet rod line (if wide enough)
            if (w > 30) {
                group.add(new Konva.Line({
                    points: [6, h * 0.3, w - 6, h * 0.3],
                    stroke: '#888',
                    strokeWidth: 1
                }));
            }

            // Closet ID label
            group.add(new Konva.Text({
                x: 0, y: h/2 - 6,
                width: w,
                text: closetId,
                fontSize: 10,
                fontStyle: 'bold',
                fill: '#f4d03f',
                align: 'center',
                name: 'closet-label'
            }));

            // Wall ID labels for closet (W1-W4)
            const children = obj.children || [];
            const wallSegments = children.filter(c => c.objectType === 'WallSegment');

            wallSegments.forEach((wall, idx) => {
                let wallId = `W${idx + 1}`;
                const wallNameMatch = wall.name && wall.name.match(/Wall\s*(\d+)/i);
                if (wallNameMatch) {
                    wallId = `W${wallNameMatch[1]}`;
                }

                let labelX, labelY;
                const wallNum = parseInt(wallId.substring(1)) || (idx + 1);

                switch (wallNum % 4) {
                    case 1: labelX = w/2 - 8; labelY = 2; break;
                    case 2: labelX = w - 16; labelY = h/2 - 5; break;
                    case 3: labelX = w/2 - 8; labelY = h - 12; break;
                    case 0: labelX = 2; labelY = h/2 - 5; break;
                }

                group.add(new Konva.Text({
                    x: labelX, y: labelY,
                    text: wallId,
                    fontSize: 8,
                    fill: '#666',
                    name: 'wall-id-label',
                    visible: CADState.showWallIds
                }));
            });

            CADState.layers.openings.add(group);
            setupGenericDragInteractions(group);

            const closetData = {
                id: closetId,
                fbgName: obj.name,
                fbgId: obj.id,
                width: w,
                height: h,
                position: { x, y },
                konvaGroup: group
            };

            CADState.closets.push(closetData);
            return closetData;
        }

        function clearAllObjects() {
            // Clear all Konva objects
            CADState.rooms.forEach(r => r.konvaGroup && r.konvaGroup.destroy());
            CADState.walls.forEach(w => w.konvaLine && w.konvaLine.destroy());
            CADState.openings.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.closets.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.components.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.mepNodes && CADState.mepNodes.forEach(n => n.konvaGroup && n.konvaGroup.destroy());
            CADState.poeMarkers && CADState.poeMarkers.forEach(p => p.konvaGroup && p.konvaGroup.destroy());
            CADState.observations.forEach(o => o.konvaGroup && o.konvaGroup.destroy());
            CADState.samples.forEach(s => s.konvaGroup && s.konvaGroup.destroy());
            CADState.photos.forEach(p => p.konvaGroup && p.konvaGroup.destroy());

            // Clear architectural walls if any
            if (typeof archWalls !== 'undefined') {
                archWalls.forEach(w => w.konvaGroup && w.konvaGroup.destroy());
                archWalls = [];
            }
            if (typeof archOpenings !== 'undefined') archOpenings = [];
            if (typeof archDimensions !== 'undefined') {
                archDimensions.forEach(d => d && d.destroy());
                archDimensions = [];
            }

            // Reset arrays
            CADState.rooms = [];
            CADState.walls = [];
            CADState.openings = [];
            CADState.closets = [];
            CADState.components = [];
            CADState.mepNodes = [];
            CADState.poeMarkers = [];
            CADState.observations = [];
            CADState.samples = [];
            CADState.photos = [];

            // Clear layer children
            Object.values(CADState.layers).forEach(layer => {
                if (layer && layer !== CADState.layers.grid) {
                    layer.destroyChildren();
                }
            });
        }

        window.loadFBGFile = loadFBGFile;
        window.renderFBGProject = renderFBGProject;
        window.clearAllObjects = clearAllObjects;

        // ========== CLOSET RECONCILIATION SYSTEM ==========
        // Implements deterministic matching algorithm per spec

        const CLOSET_SCALE = 24; // pixels per foot

        function reconcileClosets(fbgData, targetCount = 2) {
            console.log('=== CLOSET RECONCILIATION ===');
            const report = {
                runId: Date.now().toString(36),
                timestamp: new Date().toISOString(),
                sourceFilePath: fbgData.id || 'unknown',
                detectedClosets: [],
                winners: {},
                merged: [],
                archived: [],
                deleted: []
            };

            const level = fbgData.levels[fbgData.currentLevelIndex || 0];
            const objects = level.canvasObjects || [];

            // Step 1: Enumerate all closet candidates
            const candidates = [];
            const rooms = [];

            objects.forEach(obj => {
                if (obj.objectType === 'RoomEquivalent') {
                    const roomType = obj.roomType || {};
                    const abbr = roomType.abbreviation || '';
                    const name = obj.name || '';

                    // Calculate geometry
                    const x = Math.min(obj.startX || 0, obj.endX || 0);
                    const y = Math.min(obj.startY || 0, obj.endY || 0);
                    const w = Math.abs((obj.endX || 0) - (obj.startX || 0));
                    const h = Math.abs((obj.endY || 0) - (obj.startY || 0));
                    const cx = x + w/2;
                    const cy = y + h/2;
                    const area = w * h;

                    const roomData = {
                        internalId: name,
                        fbgId: obj.id,
                        abbr: abbr,
                        type: roomType.name || '',
                        x, y, w, h, cx, cy, area,
                        children: obj.children || []
                    };

                    // Check if closet candidate
                    const isCloset = (
                        abbr === 'CLO' ||
                        (roomType.name || '').toLowerCase().includes('closet') ||
                        name.toUpperCase().startsWith('CLO')
                    );

                    if (isCloset) {
                        candidates.push(roomData);
                    } else {
                        rooms.push(roomData);
                    }
                }
            });

            console.log(`Detected ${candidates.length} closet candidates`);

            // Step 2: Score each candidate
            candidates.forEach(c => {
                const wFt = c.w / CLOSET_SCALE;
                const hFt = c.h / CLOSET_SCALE;
                const depthFt = Math.min(wFt, hFt);
                const widthFt = Math.max(wFt, hFt);
                const areaSqFt = c.area / (CLOSET_SCALE * CLOSET_SCALE);

                // Find nearest bedroom
                let nearestBedroom = null;
                let minBedDist = Infinity;
                let nearestRoom = null;
                let minRoomDist = Infinity;

                rooms.forEach(r => {
                    const dist = Math.sqrt(Math.pow(c.cx - r.cx, 2) + Math.pow(c.cy - r.cy, 2));
                    if (dist < minRoomDist) {
                        minRoomDist = dist;
                        nearestRoom = r;
                    }
                    if (r.abbr === 'BED' && dist < minBedDist) {
                        minBedDist = dist;
                        nearestBedroom = r;
                    }
                });

                c.nearestRoom = nearestRoom ? nearestRoom.internalId : null;
                c.nearestBedroom = nearestBedroom ? nearestBedroom.internalId : null;
                c.bedroomDistance = minBedDist;
                c.depthFt = depthFt;
                c.widthFt = widthFt;
                c.areaSqFt = areaSqFt;

                // Validity checks
                c.validDepth = depthFt >= 1.5 && depthFt <= 2.5;
                c.validWidth = widthFt >= 2.0 && widthFt <= 6.0;
                c.validArea = areaSqFt >= 2.0;
                c.tooSmall = areaSqFt < 2.0 || depthFt < 1.0;
                c.tooLarge = areaSqFt > 50 || depthFt > 5.0 || widthFt > 10.0;

                // Calculate score
                c.score = 0;
                if (nearestBedroom) c.score += 100;  // Bedroom adjacency
                if (c.validDepth && c.validWidth) c.score += 10;  // Normal range
                if (c.tooSmall) c.score -= 200;  // Penalty for junk
                if (c.tooLarge) c.score -= 100;  // Penalty for weird geometry

                report.detectedClosets.push({
                    internalId: c.internalId,
                    score: c.score,
                    adjacency: c.nearestRoom,
                    geometrySummary: `${widthFt.toFixed(1)}' x ${depthFt.toFixed(1)}' (${areaSqFt.toFixed(1)} sqft)`
                });

                console.log(`  ${c.internalId}: score=${c.score}, ${widthFt.toFixed(1)}'x${depthFt.toFixed(1)}', area=${areaSqFt.toFixed(1)}sqft, near=${c.nearestRoom}`);
            });

            // Step 3: Sort by score and pick winners
            candidates.sort((a, b) => b.score - a.score);

            const validCandidates = candidates.filter(c => !c.tooSmall && c.score > -100);
            const winners = [];

            // Pick up to targetCount winners
            for (let i = 0; i < Math.min(targetCount, validCandidates.length); i++) {
                winners.push(validCandidates[i]);
            }

            // Assign labels CL-01, CL-02
            winners.forEach((w, idx) => {
                w.label = `CL-${String(idx + 1).padStart(2, '0')}`;
                report.winners[w.label] = {
                    fromInternalId: w.internalId,
                    reason: `Score ${w.score}, adjacent to ${w.nearestRoom || 'none'}`
                };
            });

            // Step 4: Handle extras
            candidates.forEach(c => {
                if (winners.includes(c)) return;

                if (c.tooSmall) {
                    // DELETE - junk geometry
                    c.action = 'DELETE';
                    report.deleted.push({
                        internalId: c.internalId,
                        reason: `Too small: ${c.areaSqFt.toFixed(1)} sqft, depth ${c.depthFt.toFixed(1)}'`
                    });
                } else {
                    // ARCHIVE - valid but not selected
                    c.action = 'ARCHIVE';
                    report.archived.push({
                        internalId: c.internalId,
                        reason: `Score ${c.score} not in top ${targetCount}`
                    });
                }
            });

            // Summary
            console.log(`\n=== RECONCILIATION RESULT ===`);
            console.log(`Winners: ${winners.map(w => w.label + '=' + w.internalId).join(', ')}`);
            console.log(`Archived: ${report.archived.length}`);
            console.log(`Deleted: ${report.deleted.length}`);

            // Alert summary
            const summary = `Closets reconciled: ${winners.length} active (${winners.map(w=>w.label).join(', ')}), ${report.archived.length} archived, ${report.deleted.length} deleted.`;
            console.log(summary);

            return { winners, report, summary };
        }

        // Render reconciled closets
        function renderReconciledClosets(winners) {
            // Clear existing closets
            CADState.closets.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.closets = [];

            winners.forEach((closet, idx) => {
                const closetId = closet.label;

                const group = new Konva.Group({
                    x: closet.x,
                    y: closet.y,
                    draggable: true,
                    name: 'closet-group',
                    id: closetId
                });

                // Closet outline (architectural style with dashed border)
                group.add(new Konva.Rect({
                    x: 0, y: 0,
                    width: closet.w,
                    height: closet.h,
                    fill: '#353535',
                    stroke: '#f4d03f',
                    strokeWidth: 2,
                    dash: [8, 4],
                    name: 'closet-fill'
                }));

                // Closet rod line
                if (closet.w > 30) {
                    group.add(new Konva.Line({
                        points: [6, closet.h * 0.3, closet.w - 6, closet.h * 0.3],
                        stroke: '#888',
                        strokeWidth: 1
                    }));
                }

                // Closet label (CL-01, CL-02)
                group.add(new Konva.Text({
                    x: 0,
                    y: closet.h / 2 - 6,
                    width: closet.w,
                    text: closetId,
                    fontSize: 11,
                    fontStyle: 'bold',
                    fill: '#f4d03f',
                    align: 'center',
                    name: 'closet-label'
                }));

                // Wall ID labels (W1-W4)
                const wallPositions = [
                    { id: 'W1', x: closet.w/2 - 8, y: 2 },
                    { id: 'W2', x: closet.w - 16, y: closet.h/2 - 5 },
                    { id: 'W3', x: closet.w/2 - 8, y: closet.h - 12 },
                    { id: 'W4', x: 2, y: closet.h/2 - 5 }
                ];

                wallPositions.forEach(wp => {
                    group.add(new Konva.Text({
                        x: wp.x, y: wp.y,
                        text: wp.id,
                        fontSize: 8,
                        fill: '#666',
                        name: 'wall-id-label',
                        visible: CADState.showWallIds
                    }));
                });

                CADState.layers.openings.add(group);
                setupGenericDragInteractions(group);

                const closetData = {
                    id: closetId,
                    fbgName: closet.internalId,
                    fbgId: closet.fbgId,
                    width: closet.w,
                    height: closet.h,
                    widthFt: closet.widthFt,
                    depthFt: closet.depthFt,
                    areaSqFt: closet.areaSqFt,
                    nearestRoom: closet.nearestRoom,
                    score: closet.score,
                    position: { x: closet.x, y: closet.y },
                    konvaGroup: group
                };

                CADState.closets.push(closetData);
            });

            CADState.layers.openings.batchDraw();
        }

        // Enhanced FBG loader with closet reconciliation
        function renderFBGProjectWithReconciliation(fbgData) {
            console.log('=== LOADING FBG WITH RECONCILIATION ===');

            // First run standard render
            renderFBGProject(fbgData);

            // Then reconcile closets
            const { winners, report, summary } = reconcileClosets(fbgData, 2);

            // Clear and re-render only closets with reconciled data
            CADState.closets.forEach(c => c.konvaGroup && c.konvaGroup.destroy());
            CADState.closets = [];

            renderReconciledClosets(winners);

            // Store report in state
            CADState.reconcileReport = report;

            // Update object tree
            updateObjectTree();

            // Show summary
            alert(summary);

            return { report, summary };
        }

        // Load FBG with automatic reconciliation
        function loadFBGFileWithReconciliation(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fbgData = JSON.parse(e.target.result);
                    CADState.currentFBGData = fbgData; // Store for later reconciliation
                    renderFBGProjectWithReconciliation(fbgData);
                } catch (err) {
                    console.error('FBG Load Error:', err);
                    alert('Error loading FBG file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Manual reconciliation trigger
        function runReconciliation() {
            if (!CADState.currentFBGData) {
                alert('No FBG data loaded. Please load an FBG file first.');
                return;
            }

            const { winners, report, summary } = reconcileClosets(CADState.currentFBGData, 2);
            renderReconciledClosets(winners);
            CADState.reconcileReport = report;
            updateObjectTree();

            // Show detailed report
            console.log('=== RECONCILIATION REPORT ===');
            console.log(JSON.stringify(report, null, 2));

            alert(summary + '\n\nSee console for detailed report.');
        }

        // Test function with simulated FBG data including 3 closets
        function testClosetReconciliation() {
            const testFBG = {
                id: 'test-reconcile',
                address: '1132 SOUTHERN BLVD - TEST',
                currentLevelIndex: 0,
                levels: [{
                    id: 'L1',
                    name: 'Level 1',
                    canvasObjects: [
                        // Bedroom 1
                        {
                            id: 'bed1', name: 'BED1', objectType: 'RoomEquivalent',
                            startX: 100, startY: 100, endX: 280, endY: 280,
                            roomType: { abbreviation: 'BED', name: 'Bedroom' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Bedroom 2
                        {
                            id: 'bed2', name: 'BED2', objectType: 'RoomEquivalent',
                            startX: 350, startY: 100, endX: 530, endY: 280,
                            roomType: { abbreviation: 'BED', name: 'Bedroom' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Living Room
                        {
                            id: 'liv1', name: 'LIV1', objectType: 'RoomEquivalent',
                            startX: 100, startY: 300, endX: 350, endY: 450,
                            roomType: { abbreviation: 'LIV', name: 'Living Room' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Kitchen
                        {
                            id: 'kit1', name: 'KIT1', objectType: 'RoomEquivalent',
                            startX: 370, startY: 300, endX: 530, endY: 450,
                            roomType: { abbreviation: 'KIT', name: 'Kitchen' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Closet 1 - valid, near Bed1 (should be CL-01)
                        {
                            id: 'clo1', name: 'CLO1', objectType: 'RoomEquivalent',
                            startX: 290, startY: 100, endX: 340, endY: 170,
                            roomType: { abbreviation: 'CLO', name: 'Closet' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Closet 2 - valid, near Bed2 (should be CL-02)
                        {
                            id: 'clo2', name: 'CLO2', objectType: 'RoomEquivalent',
                            startX: 290, startY: 190, endX: 340, endY: 280,
                            roomType: { abbreviation: 'CLO', name: 'Closet' },
                            children: [{name:'Wall 1',objectType:'WallSegment'},{name:'Wall 2',objectType:'WallSegment'},{name:'Wall 3',objectType:'WallSegment'},{name:'Wall 4',objectType:'WallSegment'}]
                        },
                        // Closet 3 - JUNK (too small, should be DELETED)
                        {
                            id: 'clo3', name: 'CLO3', objectType: 'RoomEquivalent',
                            startX: 50, startY: 50, endX: 60, endY: 65,
                            roomType: { abbreviation: 'CLO', name: 'Closet' },
                            children: []
                        }
                    ]
                }]
            };

            console.log('=== TESTING CLOSET RECONCILIATION ===');
            renderFBGProjectWithReconciliation(testFBG);
        }

        window.reconcileClosets = reconcileClosets;
        window.renderReconciledClosets = renderReconciledClosets;
        window.renderFBGProjectWithReconciliation = renderFBGProjectWithReconciliation;
        window.loadFBGFileWithReconciliation = loadFBGFileWithReconciliation;
        window.runReconciliation = runReconciliation;
        window.testClosetReconciliation = testClosetReconciliation;
    </script>
</body>
</html>
